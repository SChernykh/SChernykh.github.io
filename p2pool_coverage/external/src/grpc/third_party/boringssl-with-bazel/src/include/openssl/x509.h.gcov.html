<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - external/src/grpc/third_party/boringssl-with-bazel/src/include/openssl/x509.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../../../../gcov.css">
</head>

<body>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="title">LCOV - code coverage report</td></tr>
            <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>

            <tr>
              <td width="100%">
                <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="10%" class="headerValue"><a href="../../../../../../../../index.html">top level</a> - <a href="index.html">external/src/grpc/third_party/boringssl-with-bazel/src/include/openssl</a> - x509.h<span style="font-size: 80%;"> (source / <a href="x509.h.func-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="5%"></td>
            <td width="5%" class="headerCovTableHead">Coverage</td>
            <td width="5%" class="headerCovTableHead" title="Covered + Uncovered code">Total</td>
            <td width="5%" class="headerCovTableHead" title="Exercised code only">Hit</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntryHi">100.0&nbsp;%</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
          </tr>
          <tr>
            <td class="headerItem">Test Date:</td>
            <td class="headerValue">2025-06-21 14:45:59</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntryHi">100.0&nbsp;%</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">1</td>
          </tr>
                  <tr><td><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
                </table>
              </td>
            </tr>

            <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
          </table>

          <table cellpadding=0 cellspacing=0 border=0>
            <tr>
              <td><br></td>
            </tr>
            <tr>
              <td>
<pre class="sourceHeading">            Line data    Source code</pre>
<pre class="source">
<span id="L1"><span class="lineNum">       1</span>              : /* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)</span>
<span id="L2"><span class="lineNum">       2</span>              :  * All rights reserved.</span>
<span id="L3"><span class="lineNum">       3</span>              :  *</span>
<span id="L4"><span class="lineNum">       4</span>              :  * This package is an SSL implementation written</span>
<span id="L5"><span class="lineNum">       5</span>              :  * by Eric Young (eay@cryptsoft.com).</span>
<span id="L6"><span class="lineNum">       6</span>              :  * The implementation was written so as to conform with Netscapes SSL.</span>
<span id="L7"><span class="lineNum">       7</span>              :  *</span>
<span id="L8"><span class="lineNum">       8</span>              :  * This library is free for commercial and non-commercial use as long as</span>
<span id="L9"><span class="lineNum">       9</span>              :  * the following conditions are aheared to.  The following conditions</span>
<span id="L10"><span class="lineNum">      10</span>              :  * apply to all code found in this distribution, be it the RC4, RSA,</span>
<span id="L11"><span class="lineNum">      11</span>              :  * lhash, DES, etc., code; not just the SSL code.  The SSL documentation</span>
<span id="L12"><span class="lineNum">      12</span>              :  * included with this distribution is covered by the same copyright terms</span>
<span id="L13"><span class="lineNum">      13</span>              :  * except that the holder is Tim Hudson (tjh@cryptsoft.com).</span>
<span id="L14"><span class="lineNum">      14</span>              :  *</span>
<span id="L15"><span class="lineNum">      15</span>              :  * Copyright remains Eric Young's, and as such any Copyright notices in</span>
<span id="L16"><span class="lineNum">      16</span>              :  * the code are not to be removed.</span>
<span id="L17"><span class="lineNum">      17</span>              :  * If this package is used in a product, Eric Young should be given attribution</span>
<span id="L18"><span class="lineNum">      18</span>              :  * as the author of the parts of the library used.</span>
<span id="L19"><span class="lineNum">      19</span>              :  * This can be in the form of a textual message at program startup or</span>
<span id="L20"><span class="lineNum">      20</span>              :  * in documentation (online or textual) provided with the package.</span>
<span id="L21"><span class="lineNum">      21</span>              :  *</span>
<span id="L22"><span class="lineNum">      22</span>              :  * Redistribution and use in source and binary forms, with or without</span>
<span id="L23"><span class="lineNum">      23</span>              :  * modification, are permitted provided that the following conditions</span>
<span id="L24"><span class="lineNum">      24</span>              :  * are met:</span>
<span id="L25"><span class="lineNum">      25</span>              :  * 1. Redistributions of source code must retain the copyright</span>
<span id="L26"><span class="lineNum">      26</span>              :  *    notice, this list of conditions and the following disclaimer.</span>
<span id="L27"><span class="lineNum">      27</span>              :  * 2. Redistributions in binary form must reproduce the above copyright</span>
<span id="L28"><span class="lineNum">      28</span>              :  *    notice, this list of conditions and the following disclaimer in the</span>
<span id="L29"><span class="lineNum">      29</span>              :  *    documentation and/or other materials provided with the distribution.</span>
<span id="L30"><span class="lineNum">      30</span>              :  * 3. All advertising materials mentioning features or use of this software</span>
<span id="L31"><span class="lineNum">      31</span>              :  *    must display the following acknowledgement:</span>
<span id="L32"><span class="lineNum">      32</span>              :  *    &quot;This product includes cryptographic software written by</span>
<span id="L33"><span class="lineNum">      33</span>              :  *     Eric Young (eay@cryptsoft.com)&quot;</span>
<span id="L34"><span class="lineNum">      34</span>              :  *    The word 'cryptographic' can be left out if the rouines from the library</span>
<span id="L35"><span class="lineNum">      35</span>              :  *    being used are not cryptographic related :-).</span>
<span id="L36"><span class="lineNum">      36</span>              :  * 4. If you include any Windows specific code (or a derivative thereof) from</span>
<span id="L37"><span class="lineNum">      37</span>              :  *    the apps directory (application code) you must include an acknowledgement:</span>
<span id="L38"><span class="lineNum">      38</span>              :  *    &quot;This product includes software written by Tim Hudson (tjh@cryptsoft.com)&quot;</span>
<span id="L39"><span class="lineNum">      39</span>              :  *</span>
<span id="L40"><span class="lineNum">      40</span>              :  * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND</span>
<span id="L41"><span class="lineNum">      41</span>              :  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span id="L42"><span class="lineNum">      42</span>              :  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span>
<span id="L43"><span class="lineNum">      43</span>              :  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE</span>
<span id="L44"><span class="lineNum">      44</span>              :  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span id="L45"><span class="lineNum">      45</span>              :  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</span>
<span id="L46"><span class="lineNum">      46</span>              :  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</span>
<span id="L47"><span class="lineNum">      47</span>              :  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</span>
<span id="L48"><span class="lineNum">      48</span>              :  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</span>
<span id="L49"><span class="lineNum">      49</span>              :  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
<span id="L50"><span class="lineNum">      50</span>              :  * SUCH DAMAGE.</span>
<span id="L51"><span class="lineNum">      51</span>              :  *</span>
<span id="L52"><span class="lineNum">      52</span>              :  * The licence and distribution terms for any publically available version or</span>
<span id="L53"><span class="lineNum">      53</span>              :  * derivative of this code cannot be changed.  i.e. this code cannot simply be</span>
<span id="L54"><span class="lineNum">      54</span>              :  * copied and put under another distribution licence</span>
<span id="L55"><span class="lineNum">      55</span>              :  * [including the GNU Public Licence.]</span>
<span id="L56"><span class="lineNum">      56</span>              :  */</span>
<span id="L57"><span class="lineNum">      57</span>              : /* ====================================================================</span>
<span id="L58"><span class="lineNum">      58</span>              :  * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.</span>
<span id="L59"><span class="lineNum">      59</span>              :  * ECDH support in OpenSSL originally developed by</span>
<span id="L60"><span class="lineNum">      60</span>              :  * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.</span>
<span id="L61"><span class="lineNum">      61</span>              :  */</span>
<span id="L62"><span class="lineNum">      62</span>              : </span>
<span id="L63"><span class="lineNum">      63</span>              : #ifndef OPENSSL_HEADER_X509_H</span>
<span id="L64"><span class="lineNum">      64</span>              : #define OPENSSL_HEADER_X509_H</span>
<span id="L65"><span class="lineNum">      65</span>              : </span>
<span id="L66"><span class="lineNum">      66</span>              : #include &lt;openssl/base.h&gt;</span>
<span id="L67"><span class="lineNum">      67</span>              : </span>
<span id="L68"><span class="lineNum">      68</span>              : #include &lt;time.h&gt;</span>
<span id="L69"><span class="lineNum">      69</span>              : </span>
<span id="L70"><span class="lineNum">      70</span>              : #include &lt;openssl/asn1.h&gt;</span>
<span id="L71"><span class="lineNum">      71</span>              : #include &lt;openssl/bio.h&gt;</span>
<span id="L72"><span class="lineNum">      72</span>              : #include &lt;openssl/cipher.h&gt;</span>
<span id="L73"><span class="lineNum">      73</span>              : #include &lt;openssl/conf.h&gt;</span>
<span id="L74"><span class="lineNum">      74</span>              : #include &lt;openssl/dh.h&gt;</span>
<span id="L75"><span class="lineNum">      75</span>              : #include &lt;openssl/dsa.h&gt;</span>
<span id="L76"><span class="lineNum">      76</span>              : #include &lt;openssl/ec.h&gt;</span>
<span id="L77"><span class="lineNum">      77</span>              : #include &lt;openssl/ecdh.h&gt;</span>
<span id="L78"><span class="lineNum">      78</span>              : #include &lt;openssl/ecdsa.h&gt;</span>
<span id="L79"><span class="lineNum">      79</span>              : #include &lt;openssl/evp.h&gt;</span>
<span id="L80"><span class="lineNum">      80</span>              : #include &lt;openssl/lhash.h&gt;</span>
<span id="L81"><span class="lineNum">      81</span>              : #include &lt;openssl/obj.h&gt;</span>
<span id="L82"><span class="lineNum">      82</span>              : #include &lt;openssl/pkcs7.h&gt;</span>
<span id="L83"><span class="lineNum">      83</span>              : #include &lt;openssl/pool.h&gt;</span>
<span id="L84"><span class="lineNum">      84</span>              : #include &lt;openssl/rsa.h&gt;</span>
<span id="L85"><span class="lineNum">      85</span>              : #include &lt;openssl/sha.h&gt;</span>
<span id="L86"><span class="lineNum">      86</span>              : #include &lt;openssl/stack.h&gt;</span>
<span id="L87"><span class="lineNum">      87</span>              : #include &lt;openssl/thread.h&gt;</span>
<span id="L88"><span class="lineNum">      88</span>              : #include &lt;openssl/x509v3_errors.h&gt;  // IWYU pragma: export</span>
<span id="L89"><span class="lineNum">      89</span>              : </span>
<span id="L90"><span class="lineNum">      90</span>              : #if defined(__cplusplus)</span>
<span id="L91"><span class="lineNum">      91</span>              : extern &quot;C&quot; {</span>
<span id="L92"><span class="lineNum">      92</span>              : #endif</span>
<span id="L93"><span class="lineNum">      93</span>              : </span>
<span id="L94"><span class="lineNum">      94</span>              : </span>
<span id="L95"><span class="lineNum">      95</span>              : // Legacy X.509 library.</span>
<span id="L96"><span class="lineNum">      96</span>              : //</span>
<span id="L97"><span class="lineNum">      97</span>              : // This header is part of OpenSSL's X.509 implementation. It is retained for</span>
<span id="L98"><span class="lineNum">      98</span>              : // compatibility but should not be used by new code. The functions are difficult</span>
<span id="L99"><span class="lineNum">      99</span>              : // to use correctly, and have buggy or non-standard behaviors. They are thus</span>
<span id="L100"><span class="lineNum">     100</span>              : // particularly prone to behavior changes and API removals, as BoringSSL</span>
<span id="L101"><span class="lineNum">     101</span>              : // iterates on these issues.</span>
<span id="L102"><span class="lineNum">     102</span>              : //</span>
<span id="L103"><span class="lineNum">     103</span>              : // In the future, a replacement library will be available. Meanwhile, minimize</span>
<span id="L104"><span class="lineNum">     104</span>              : // dependencies on this header where possible.</span>
<span id="L105"><span class="lineNum">     105</span>              : </span>
<span id="L106"><span class="lineNum">     106</span>              : </span>
<span id="L107"><span class="lineNum">     107</span>              : // Certificates.</span>
<span id="L108"><span class="lineNum">     108</span>              : //</span>
<span id="L109"><span class="lineNum">     109</span>              : // An |X509| object represents an X.509 certificate, defined in RFC 5280.</span>
<span id="L110"><span class="lineNum">     110</span>              : //</span>
<span id="L111"><span class="lineNum">     111</span>              : // Although an |X509| is a mutable object, mutating an |X509| can give incorrect</span>
<span id="L112"><span class="lineNum">     112</span>              : // results. Callers typically obtain |X509|s by parsing some input with</span>
<span id="L113"><span class="lineNum">     113</span>              : // |d2i_X509|, etc. Such objects carry information such as the serialized</span>
<span id="L114"><span class="lineNum">     114</span>              : // TBSCertificate and decoded extensions, which will become inconsistent when</span>
<span id="L115"><span class="lineNum">     115</span>              : // mutated.</span>
<span id="L116"><span class="lineNum">     116</span>              : //</span>
<span id="L117"><span class="lineNum">     117</span>              : // Instead, mutation functions should only be used when issuing new</span>
<span id="L118"><span class="lineNum">     118</span>              : // certificates, as described in a later section.</span>
<span id="L119"><span class="lineNum">     119</span>              : </span>
<span id="L120"><span class="lineNum">     120</span>              : DEFINE_STACK_OF(X509)</span>
<span id="L121"><span class="lineNum">     121</span>              : </span>
<span id="L122"><span class="lineNum">     122</span>              : // X509 is an |ASN1_ITEM| whose ASN.1 type is X.509 Certificate (RFC 5280) and C</span>
<span id="L123"><span class="lineNum">     123</span>              : // type is |X509*|.</span>
<span id="L124"><span class="lineNum">     124</span>              : DECLARE_ASN1_ITEM(X509)</span>
<span id="L125"><span class="lineNum">     125</span>              : </span>
<span id="L126"><span class="lineNum">     126</span>              : // X509_up_ref adds one to the reference count of |x509| and returns one.</span>
<span id="L127"><span class="lineNum">     127</span>              : OPENSSL_EXPORT int X509_up_ref(X509 *x509);</span>
<span id="L128"><span class="lineNum">     128</span>              : </span>
<span id="L129"><span class="lineNum">     129</span>              : // X509_chain_up_ref returns a newly-allocated |STACK_OF(X509)| containing a</span>
<span id="L130"><span class="lineNum">     130</span>              : // shallow copy of |chain|, or NULL on error. That is, the return value has the</span>
<span id="L131"><span class="lineNum">     131</span>              : // same contents as |chain|, and each |X509|'s reference count is incremented by</span>
<span id="L132"><span class="lineNum">     132</span>              : // one.</span>
<span id="L133"><span class="lineNum">     133</span>              : OPENSSL_EXPORT STACK_OF(X509) *X509_chain_up_ref(STACK_OF(X509) *chain);</span>
<span id="L134"><span class="lineNum">     134</span>              : </span>
<span id="L135"><span class="lineNum">     135</span>              : // X509_dup returns a newly-allocated copy of |x509|, or NULL on error. This</span>
<span id="L136"><span class="lineNum">     136</span>              : // function works by serializing the structure, so auxiliary properties (see</span>
<span id="L137"><span class="lineNum">     137</span>              : // |i2d_X509_AUX|) are not preserved. Additionally, if |x509| is incomplete,</span>
<span id="L138"><span class="lineNum">     138</span>              : // this function may fail.</span>
<span id="L139"><span class="lineNum">     139</span>              : //</span>
<span id="L140"><span class="lineNum">     140</span>              : // TODO(https://crbug.com/boringssl/407): This function should be const and</span>
<span id="L141"><span class="lineNum">     141</span>              : // thread-safe but is currently neither in some cases, notably if |crl| was</span>
<span id="L142"><span class="lineNum">     142</span>              : // mutated.</span>
<span id="L143"><span class="lineNum">     143</span>              : OPENSSL_EXPORT X509 *X509_dup(X509 *x509);</span>
<span id="L144"><span class="lineNum">     144</span>              : </span>
<span id="L145"><span class="lineNum">     145</span>              : // X509_free decrements |x509|'s reference count and, if zero, releases memory</span>
<span id="L146"><span class="lineNum">     146</span>              : // associated with |x509|.</span>
<span id="L147"><span class="lineNum">     147</span>              : OPENSSL_EXPORT void X509_free(X509 *x509);</span>
<span id="L148"><span class="lineNum">     148</span>              : </span>
<span id="L149"><span class="lineNum">     149</span>              : // d2i_X509 parses up to |len| bytes from |*inp| as a DER-encoded X.509</span>
<span id="L150"><span class="lineNum">     150</span>              : // Certificate (RFC 5280), as described in |d2i_SAMPLE|.</span>
<span id="L151"><span class="lineNum">     151</span>              : OPENSSL_EXPORT X509 *d2i_X509(X509 **out, const uint8_t **inp, long len);</span>
<span id="L152"><span class="lineNum">     152</span>              : </span>
<span id="L153"><span class="lineNum">     153</span>              : // X509_parse_from_buffer parses an X.509 structure from |buf| and returns a</span>
<span id="L154"><span class="lineNum">     154</span>              : // fresh X509 or NULL on error. There must not be any trailing data in |buf|.</span>
<span id="L155"><span class="lineNum">     155</span>              : // The returned structure (if any) holds a reference to |buf| rather than</span>
<span id="L156"><span class="lineNum">     156</span>              : // copying parts of it as a normal |d2i_X509| call would do.</span>
<span id="L157"><span class="lineNum">     157</span>              : OPENSSL_EXPORT X509 *X509_parse_from_buffer(CRYPTO_BUFFER *buf);</span>
<span id="L158"><span class="lineNum">     158</span>              : </span>
<span id="L159"><span class="lineNum">     159</span>              : // i2d_X509 marshals |x509| as a DER-encoded X.509 Certificate (RFC 5280), as</span>
<span id="L160"><span class="lineNum">     160</span>              : // described in |i2d_SAMPLE|.</span>
<span id="L161"><span class="lineNum">     161</span>              : //</span>
<span id="L162"><span class="lineNum">     162</span>              : // TODO(https://crbug.com/boringssl/407): This function should be const and</span>
<span id="L163"><span class="lineNum">     163</span>              : // thread-safe but is currently neither in some cases, notably if |x509| was</span>
<span id="L164"><span class="lineNum">     164</span>              : // mutated.</span>
<span id="L165"><span class="lineNum">     165</span>              : OPENSSL_EXPORT int i2d_X509(X509 *x509, uint8_t **outp);</span>
<span id="L166"><span class="lineNum">     166</span>              : </span>
<span id="L167"><span class="lineNum">     167</span>              : // X509_VERSION_* are X.509 version numbers. Note the numerical values of all</span>
<span id="L168"><span class="lineNum">     168</span>              : // defined X.509 versions are one less than the named version.</span>
<span id="L169"><span class="lineNum">     169</span>              : #define X509_VERSION_1 0</span>
<span id="L170"><span class="lineNum">     170</span>              : #define X509_VERSION_2 1</span>
<span id="L171"><span class="lineNum">     171</span>              : #define X509_VERSION_3 2</span>
<span id="L172"><span class="lineNum">     172</span>              : </span>
<span id="L173"><span class="lineNum">     173</span>              : // X509_get_version returns the numerical value of |x509|'s version, which will</span>
<span id="L174"><span class="lineNum">     174</span>              : // be one of the |X509_VERSION_*| constants.</span>
<span id="L175"><span class="lineNum">     175</span>              : OPENSSL_EXPORT long X509_get_version(const X509 *x509);</span>
<span id="L176"><span class="lineNum">     176</span>              : </span>
<span id="L177"><span class="lineNum">     177</span>              : // X509_get0_serialNumber returns |x509|'s serial number.</span>
<span id="L178"><span class="lineNum">     178</span>              : OPENSSL_EXPORT const ASN1_INTEGER *X509_get0_serialNumber(const X509 *x509);</span>
<span id="L179"><span class="lineNum">     179</span>              : </span>
<span id="L180"><span class="lineNum">     180</span>              : // X509_get0_notBefore returns |x509|'s notBefore time.</span>
<span id="L181"><span class="lineNum">     181</span>              : OPENSSL_EXPORT const ASN1_TIME *X509_get0_notBefore(const X509 *x509);</span>
<span id="L182"><span class="lineNum">     182</span>              : </span>
<span id="L183"><span class="lineNum">     183</span>              : // X509_get0_notAfter returns |x509|'s notAfter time.</span>
<span id="L184"><span class="lineNum">     184</span>              : OPENSSL_EXPORT const ASN1_TIME *X509_get0_notAfter(const X509 *x509);</span>
<span id="L185"><span class="lineNum">     185</span>              : </span>
<span id="L186"><span class="lineNum">     186</span>              : // X509_get_issuer_name returns |x509|'s issuer.</span>
<span id="L187"><span class="lineNum">     187</span>              : OPENSSL_EXPORT X509_NAME *X509_get_issuer_name(const X509 *x509);</span>
<span id="L188"><span class="lineNum">     188</span>              : </span>
<span id="L189"><span class="lineNum">     189</span>              : // X509_get_subject_name returns |x509|'s subject.</span>
<span id="L190"><span class="lineNum">     190</span>              : OPENSSL_EXPORT X509_NAME *X509_get_subject_name(const X509 *x509);</span>
<span id="L191"><span class="lineNum">     191</span>              : </span>
<span id="L192"><span class="lineNum">     192</span>              : // X509_get_X509_PUBKEY returns the public key of |x509|. Note this function is</span>
<span id="L193"><span class="lineNum">     193</span>              : // not const-correct for legacy reasons. Callers should not modify the returned</span>
<span id="L194"><span class="lineNum">     194</span>              : // object.</span>
<span id="L195"><span class="lineNum">     195</span>              : OPENSSL_EXPORT X509_PUBKEY *X509_get_X509_PUBKEY(const X509 *x509);</span>
<span id="L196"><span class="lineNum">     196</span>              : </span>
<span id="L197"><span class="lineNum">     197</span>              : // X509_get0_pubkey returns |x509|'s public key as an |EVP_PKEY|, or NULL if the</span>
<span id="L198"><span class="lineNum">     198</span>              : // public key was unsupported or could not be decoded. The |EVP_PKEY| is cached</span>
<span id="L199"><span class="lineNum">     199</span>              : // in |x509|, so callers must not mutate the result.</span>
<span id="L200"><span class="lineNum">     200</span>              : OPENSSL_EXPORT EVP_PKEY *X509_get0_pubkey(const X509 *x509);</span>
<span id="L201"><span class="lineNum">     201</span>              : </span>
<span id="L202"><span class="lineNum">     202</span>              : // X509_get_pubkey behaves like |X509_get0_pubkey| but increments the reference</span>
<span id="L203"><span class="lineNum">     203</span>              : // count on the |EVP_PKEY|. The caller must release the result with</span>
<span id="L204"><span class="lineNum">     204</span>              : // |EVP_PKEY_free| when done. The |EVP_PKEY| is cached in |x509|, so callers</span>
<span id="L205"><span class="lineNum">     205</span>              : // must not mutate the result.</span>
<span id="L206"><span class="lineNum">     206</span>              : OPENSSL_EXPORT EVP_PKEY *X509_get_pubkey(const X509 *x509);</span>
<span id="L207"><span class="lineNum">     207</span>              : </span>
<span id="L208"><span class="lineNum">     208</span>              : // X509_get0_pubkey_bitstr returns the BIT STRING portion of |x509|'s public</span>
<span id="L209"><span class="lineNum">     209</span>              : // key. Note this does not contain the AlgorithmIdentifier portion.</span>
<span id="L210"><span class="lineNum">     210</span>              : //</span>
<span id="L211"><span class="lineNum">     211</span>              : // WARNING: This function returns a non-const pointer for OpenSSL compatibility,</span>
<span id="L212"><span class="lineNum">     212</span>              : // but the caller must not modify the resulting object. Doing so will break</span>
<span id="L213"><span class="lineNum">     213</span>              : // internal invariants in |x509|.</span>
<span id="L214"><span class="lineNum">     214</span>              : OPENSSL_EXPORT ASN1_BIT_STRING *X509_get0_pubkey_bitstr(const X509 *x509);</span>
<span id="L215"><span class="lineNum">     215</span>              : </span>
<span id="L216"><span class="lineNum">     216</span>              : // X509_check_private_key returns one if |x509|'s public key matches |pkey| and</span>
<span id="L217"><span class="lineNum">     217</span>              : // zero otherwise.</span>
<span id="L218"><span class="lineNum">     218</span>              : OPENSSL_EXPORT int X509_check_private_key(const X509 *x509,</span>
<span id="L219"><span class="lineNum">     219</span>              :                                           const EVP_PKEY *pkey);</span>
<span id="L220"><span class="lineNum">     220</span>              : </span>
<span id="L221"><span class="lineNum">     221</span>              : // X509_get0_uids sets |*out_issuer_uid| to a non-owning pointer to the</span>
<span id="L222"><span class="lineNum">     222</span>              : // issuerUID field of |x509|, or NULL if |x509| has no issuerUID. It similarly</span>
<span id="L223"><span class="lineNum">     223</span>              : // outputs |x509|'s subjectUID field to |*out_subject_uid|.</span>
<span id="L224"><span class="lineNum">     224</span>              : //</span>
<span id="L225"><span class="lineNum">     225</span>              : // Callers may pass NULL to either |out_issuer_uid| or |out_subject_uid| to</span>
<span id="L226"><span class="lineNum">     226</span>              : // ignore the corresponding field.</span>
<span id="L227"><span class="lineNum">     227</span>              : OPENSSL_EXPORT void X509_get0_uids(const X509 *x509,</span>
<span id="L228"><span class="lineNum">     228</span>              :                                    const ASN1_BIT_STRING **out_issuer_uid,</span>
<span id="L229"><span class="lineNum">     229</span>              :                                    const ASN1_BIT_STRING **out_subject_uid);</span>
<span id="L230"><span class="lineNum">     230</span>              : </span>
<span id="L231"><span class="lineNum">     231</span>              : // The following bits are returned from |X509_get_extension_flags|.</span>
<span id="L232"><span class="lineNum">     232</span>              : </span>
<span id="L233"><span class="lineNum">     233</span>              : // EXFLAG_BCONS indicates the certificate has a basic constraints extension.</span>
<span id="L234"><span class="lineNum">     234</span>              : #define EXFLAG_BCONS 0x1</span>
<span id="L235"><span class="lineNum">     235</span>              : // EXFLAG_KUSAGE indicates the certifcate has a key usage extension.</span>
<span id="L236"><span class="lineNum">     236</span>              : #define EXFLAG_KUSAGE 0x2</span>
<span id="L237"><span class="lineNum">     237</span>              : // EXFLAG_XKUSAGE indicates the certifcate has an extended key usage extension.</span>
<span id="L238"><span class="lineNum">     238</span>              : #define EXFLAG_XKUSAGE 0x4</span>
<span id="L239"><span class="lineNum">     239</span>              : // EXFLAG_CA indicates the certificate has a basic constraints extension with</span>
<span id="L240"><span class="lineNum">     240</span>              : // the CA bit set.</span>
<span id="L241"><span class="lineNum">     241</span>              : #define EXFLAG_CA 0x10</span>
<span id="L242"><span class="lineNum">     242</span>              : // EXFLAG_SI indicates the certificate is self-issued, i.e. its subject and</span>
<span id="L243"><span class="lineNum">     243</span>              : // issuer names match.</span>
<span id="L244"><span class="lineNum">     244</span>              : #define EXFLAG_SI 0x20</span>
<span id="L245"><span class="lineNum">     245</span>              : // EXFLAG_V1 indicates an X.509v1 certificate.</span>
<span id="L246"><span class="lineNum">     246</span>              : #define EXFLAG_V1 0x40</span>
<span id="L247"><span class="lineNum">     247</span>              : // EXFLAG_INVALID indicates an error processing some extension. The certificate</span>
<span id="L248"><span class="lineNum">     248</span>              : // should not be accepted. Note the lack of this bit does not imply all</span>
<span id="L249"><span class="lineNum">     249</span>              : // extensions are valid, only those used to compute extension flags.</span>
<span id="L250"><span class="lineNum">     250</span>              : #define EXFLAG_INVALID 0x80</span>
<span id="L251"><span class="lineNum">     251</span>              : // EXFLAG_SET is an internal bit that indicates extension flags were computed.</span>
<span id="L252"><span class="lineNum">     252</span>              : #define EXFLAG_SET 0x100</span>
<span id="L253"><span class="lineNum">     253</span>              : // EXFLAG_CRITICAL indicates an unsupported critical extension. The certificate</span>
<span id="L254"><span class="lineNum">     254</span>              : // should not be accepted.</span>
<span id="L255"><span class="lineNum">     255</span>              : #define EXFLAG_CRITICAL 0x200</span>
<span id="L256"><span class="lineNum">     256</span>              : // EXFLAG_SS indicates the certificate is likely self-signed. That is, if it is</span>
<span id="L257"><span class="lineNum">     257</span>              : // self-issued, its authority key identifier (if any) matches itself, and its</span>
<span id="L258"><span class="lineNum">     258</span>              : // key usage extension (if any) allows certificate signatures. The signature</span>
<span id="L259"><span class="lineNum">     259</span>              : // itself is not checked in computing this bit.</span>
<span id="L260"><span class="lineNum">     260</span>              : #define EXFLAG_SS 0x2000</span>
<span id="L261"><span class="lineNum">     261</span>              : </span>
<span id="L262"><span class="lineNum">     262</span>              : // X509_get_extension_flags decodes a set of extensions from |x509| and returns</span>
<span id="L263"><span class="lineNum">     263</span>              : // a collection of |EXFLAG_*| bits which reflect |x509|. If there was an error</span>
<span id="L264"><span class="lineNum">     264</span>              : // in computing this bitmask, the result will include the |EXFLAG_INVALID| bit.</span>
<span id="L265"><span class="lineNum">     265</span>              : OPENSSL_EXPORT uint32_t X509_get_extension_flags(X509 *x509);</span>
<span id="L266"><span class="lineNum">     266</span>              : </span>
<span id="L267"><span class="lineNum">     267</span>              : // X509_get_pathlen returns path length constraint from the basic constraints</span>
<span id="L268"><span class="lineNum">     268</span>              : // extension in |x509|. (See RFC 5280, section 4.2.1.9.) It returns -1 if the</span>
<span id="L269"><span class="lineNum">     269</span>              : // constraint is not present, or if some extension in |x509| was invalid.</span>
<span id="L270"><span class="lineNum">     270</span>              : //</span>
<span id="L271"><span class="lineNum">     271</span>              : // TODO(crbug.com/boringssl/381): Decoding an |X509| object will not check for</span>
<span id="L272"><span class="lineNum">     272</span>              : // invalid extensions. To detect the error case, call</span>
<span id="L273"><span class="lineNum">     273</span>              : // |X509_get_extension_flags| and check the |EXFLAG_INVALID| bit.</span>
<span id="L274"><span class="lineNum">     274</span>              : OPENSSL_EXPORT long X509_get_pathlen(X509 *x509);</span>
<span id="L275"><span class="lineNum">     275</span>              : </span>
<span id="L276"><span class="lineNum">     276</span>              : // X509v3_KU_* are key usage bits returned from |X509_get_key_usage|.</span>
<span id="L277"><span class="lineNum">     277</span>              : #define X509v3_KU_DIGITAL_SIGNATURE 0x0080</span>
<span id="L278"><span class="lineNum">     278</span>              : #define X509v3_KU_NON_REPUDIATION 0x0040</span>
<span id="L279"><span class="lineNum">     279</span>              : #define X509v3_KU_KEY_ENCIPHERMENT 0x0020</span>
<span id="L280"><span class="lineNum">     280</span>              : #define X509v3_KU_DATA_ENCIPHERMENT 0x0010</span>
<span id="L281"><span class="lineNum">     281</span>              : #define X509v3_KU_KEY_AGREEMENT 0x0008</span>
<span id="L282"><span class="lineNum">     282</span>              : #define X509v3_KU_KEY_CERT_SIGN 0x0004</span>
<span id="L283"><span class="lineNum">     283</span>              : #define X509v3_KU_CRL_SIGN 0x0002</span>
<span id="L284"><span class="lineNum">     284</span>              : #define X509v3_KU_ENCIPHER_ONLY 0x0001</span>
<span id="L285"><span class="lineNum">     285</span>              : #define X509v3_KU_DECIPHER_ONLY 0x8000</span>
<span id="L286"><span class="lineNum">     286</span>              : </span>
<span id="L287"><span class="lineNum">     287</span>              : // X509_get_key_usage returns a bitmask of key usages (see Section 4.2.1.3 of</span>
<span id="L288"><span class="lineNum">     288</span>              : // RFC 5280) which |x509| is valid for. This function only reports the first 16</span>
<span id="L289"><span class="lineNum">     289</span>              : // bits, in a little-endian byte order, but big-endian bit order. That is, bits</span>
<span id="L290"><span class="lineNum">     290</span>              : // 0 though 7 are reported at 1&lt;&lt;7 through 1&lt;&lt;0, and bits 8 through 15 are</span>
<span id="L291"><span class="lineNum">     291</span>              : // reported at 1&lt;&lt;15 through 1&lt;&lt;8.</span>
<span id="L292"><span class="lineNum">     292</span>              : //</span>
<span id="L293"><span class="lineNum">     293</span>              : // Instead of depending on this bit order, callers should compare against the</span>
<span id="L294"><span class="lineNum">     294</span>              : // |X509v3_KU_*| constants.</span>
<span id="L295"><span class="lineNum">     295</span>              : //</span>
<span id="L296"><span class="lineNum">     296</span>              : // If |x509| has no key usage extension, all key usages are valid and this</span>
<span id="L297"><span class="lineNum">     297</span>              : // function returns |UINT32_MAX|. If there was an error processing |x509|'s</span>
<span id="L298"><span class="lineNum">     298</span>              : // extensions, or if the first 16 bits in the key usage extension were all zero,</span>
<span id="L299"><span class="lineNum">     299</span>              : // this function returns zero.</span>
<span id="L300"><span class="lineNum">     300</span>              : OPENSSL_EXPORT uint32_t X509_get_key_usage(X509 *x509);</span>
<span id="L301"><span class="lineNum">     301</span>              : </span>
<span id="L302"><span class="lineNum">     302</span>              : // XKU_* are extended key usage bits returned from</span>
<span id="L303"><span class="lineNum">     303</span>              : // |X509_get_extended_key_usage|.</span>
<span id="L304"><span class="lineNum">     304</span>              : #define XKU_SSL_SERVER 0x1</span>
<span id="L305"><span class="lineNum">     305</span>              : #define XKU_SSL_CLIENT 0x2</span>
<span id="L306"><span class="lineNum">     306</span>              : #define XKU_SMIME 0x4</span>
<span id="L307"><span class="lineNum">     307</span>              : #define XKU_CODE_SIGN 0x8</span>
<span id="L308"><span class="lineNum">     308</span>              : #define XKU_SGC 0x10</span>
<span id="L309"><span class="lineNum">     309</span>              : #define XKU_OCSP_SIGN 0x20</span>
<span id="L310"><span class="lineNum">     310</span>              : #define XKU_TIMESTAMP 0x40</span>
<span id="L311"><span class="lineNum">     311</span>              : #define XKU_DVCS 0x80</span>
<span id="L312"><span class="lineNum">     312</span>              : #define XKU_ANYEKU 0x100</span>
<span id="L313"><span class="lineNum">     313</span>              : </span>
<span id="L314"><span class="lineNum">     314</span>              : // X509_get_extended_key_usage returns a bitmask of extended key usages (see</span>
<span id="L315"><span class="lineNum">     315</span>              : // Section 4.2.1.12 of RFC 5280) which |x509| is valid for. The result will be</span>
<span id="L316"><span class="lineNum">     316</span>              : // a combination of |XKU_*| constants. If checking an extended key usage not</span>
<span id="L317"><span class="lineNum">     317</span>              : // defined above, callers should extract the extended key usage extension</span>
<span id="L318"><span class="lineNum">     318</span>              : // separately, e.g. via |X509_get_ext_d2i|.</span>
<span id="L319"><span class="lineNum">     319</span>              : //</span>
<span id="L320"><span class="lineNum">     320</span>              : // If |x509| has no extended key usage extension, all extended key usages are</span>
<span id="L321"><span class="lineNum">     321</span>              : // valid and this function returns |UINT32_MAX|. If there was an error</span>
<span id="L322"><span class="lineNum">     322</span>              : // processing |x509|'s extensions, or if |x509|'s extended key usage extension</span>
<span id="L323"><span class="lineNum">     323</span>              : // contained no recognized usages, this function returns zero.</span>
<span id="L324"><span class="lineNum">     324</span>              : OPENSSL_EXPORT uint32_t X509_get_extended_key_usage(X509 *x509);</span>
<span id="L325"><span class="lineNum">     325</span>              : </span>
<span id="L326"><span class="lineNum">     326</span>              : // X509_get0_subject_key_id returns |x509|'s subject key identifier, if present.</span>
<span id="L327"><span class="lineNum">     327</span>              : // (See RFC 5280, section 4.2.1.2.) It returns NULL if the extension is not</span>
<span id="L328"><span class="lineNum">     328</span>              : // present or if some extension in |x509| was invalid.</span>
<span id="L329"><span class="lineNum">     329</span>              : //</span>
<span id="L330"><span class="lineNum">     330</span>              : // TODO(crbug.com/boringssl/381): Decoding an |X509| object will not check for</span>
<span id="L331"><span class="lineNum">     331</span>              : // invalid extensions. To detect the error case, call</span>
<span id="L332"><span class="lineNum">     332</span>              : // |X509_get_extension_flags| and check the |EXFLAG_INVALID| bit.</span>
<span id="L333"><span class="lineNum">     333</span>              : OPENSSL_EXPORT const ASN1_OCTET_STRING *X509_get0_subject_key_id(X509 *x509);</span>
<span id="L334"><span class="lineNum">     334</span>              : </span>
<span id="L335"><span class="lineNum">     335</span>              : // X509_get0_authority_key_id returns keyIdentifier of |x509|'s authority key</span>
<span id="L336"><span class="lineNum">     336</span>              : // identifier, if the extension and field are present. (See RFC 5280,</span>
<span id="L337"><span class="lineNum">     337</span>              : // section 4.2.1.1.) It returns NULL if the extension is not present, if it is</span>
<span id="L338"><span class="lineNum">     338</span>              : // present but lacks a keyIdentifier field, or if some extension in |x509| was</span>
<span id="L339"><span class="lineNum">     339</span>              : // invalid.</span>
<span id="L340"><span class="lineNum">     340</span>              : //</span>
<span id="L341"><span class="lineNum">     341</span>              : // TODO(crbug.com/boringssl/381): Decoding an |X509| object will not check for</span>
<span id="L342"><span class="lineNum">     342</span>              : // invalid extensions. To detect the error case, call</span>
<span id="L343"><span class="lineNum">     343</span>              : // |X509_get_extension_flags| and check the |EXFLAG_INVALID| bit.</span>
<span id="L344"><span class="lineNum">     344</span>              : OPENSSL_EXPORT const ASN1_OCTET_STRING *X509_get0_authority_key_id(X509 *x509);</span>
<span id="L345"><span class="lineNum">     345</span>              : </span>
<span id="L346"><span class="lineNum">     346</span>              : DEFINE_STACK_OF(GENERAL_NAME)</span>
<span id="L347"><span class="lineNum">     347</span>              : typedef STACK_OF(GENERAL_NAME) GENERAL_NAMES;</span>
<span id="L348"><span class="lineNum">     348</span>              : </span>
<span id="L349"><span class="lineNum">     349</span>              : // X509_get0_authority_issuer returns the authorityCertIssuer of |x509|'s</span>
<span id="L350"><span class="lineNum">     350</span>              : // authority key identifier, if the extension and field are present. (See</span>
<span id="L351"><span class="lineNum">     351</span>              : // RFC 5280, section 4.2.1.1.) It returns NULL if the extension is not present,</span>
<span id="L352"><span class="lineNum">     352</span>              : // if it is present but lacks a authorityCertIssuer field, or if some extension</span>
<span id="L353"><span class="lineNum">     353</span>              : // in |x509| was invalid.</span>
<span id="L354"><span class="lineNum">     354</span>              : //</span>
<span id="L355"><span class="lineNum">     355</span>              : // TODO(crbug.com/boringssl/381): Decoding an |X509| object will not check for</span>
<span id="L356"><span class="lineNum">     356</span>              : // invalid extensions. To detect the error case, call</span>
<span id="L357"><span class="lineNum">     357</span>              : // |X509_get_extension_flags| and check the |EXFLAG_INVALID| bit.</span>
<span id="L358"><span class="lineNum">     358</span>              : OPENSSL_EXPORT const GENERAL_NAMES *X509_get0_authority_issuer(X509 *x509);</span>
<span id="L359"><span class="lineNum">     359</span>              : </span>
<span id="L360"><span class="lineNum">     360</span>              : // X509_get0_authority_serial returns the authorityCertSerialNumber of |x509|'s</span>
<span id="L361"><span class="lineNum">     361</span>              : // authority key identifier, if the extension and field are present. (See</span>
<span id="L362"><span class="lineNum">     362</span>              : // RFC 5280, section 4.2.1.1.) It returns NULL if the extension is not present,</span>
<span id="L363"><span class="lineNum">     363</span>              : // if it is present but lacks a authorityCertSerialNumber field, or if some</span>
<span id="L364"><span class="lineNum">     364</span>              : // extension in |x509| was invalid.</span>
<span id="L365"><span class="lineNum">     365</span>              : //</span>
<span id="L366"><span class="lineNum">     366</span>              : // TODO(crbug.com/boringssl/381): Decoding an |X509| object will not check for</span>
<span id="L367"><span class="lineNum">     367</span>              : // invalid extensions. To detect the error case, call</span>
<span id="L368"><span class="lineNum">     368</span>              : // |X509_get_extension_flags| and check the |EXFLAG_INVALID| bit.</span>
<span id="L369"><span class="lineNum">     369</span>              : OPENSSL_EXPORT const ASN1_INTEGER *X509_get0_authority_serial(X509 *x509);</span>
<span id="L370"><span class="lineNum">     370</span>              : </span>
<span id="L371"><span class="lineNum">     371</span>              : // X509_get0_extensions returns |x509|'s extension list, or NULL if |x509| omits</span>
<span id="L372"><span class="lineNum">     372</span>              : // it.</span>
<span id="L373"><span class="lineNum">     373</span>              : OPENSSL_EXPORT const STACK_OF(X509_EXTENSION) *X509_get0_extensions(</span>
<span id="L374"><span class="lineNum">     374</span>              :     const X509 *x509);</span>
<span id="L375"><span class="lineNum">     375</span>              : </span>
<span id="L376"><span class="lineNum">     376</span>              : // X509_get_ext_count returns the number of extensions in |x|.</span>
<span id="L377"><span class="lineNum">     377</span>              : OPENSSL_EXPORT int X509_get_ext_count(const X509 *x);</span>
<span id="L378"><span class="lineNum">     378</span>              : </span>
<span id="L379"><span class="lineNum">     379</span>              : // X509_get_ext_by_NID behaves like |X509v3_get_ext_by_NID| but searches for</span>
<span id="L380"><span class="lineNum">     380</span>              : // extensions in |x|.</span>
<span id="L381"><span class="lineNum">     381</span>              : OPENSSL_EXPORT int X509_get_ext_by_NID(const X509 *x, int nid, int lastpos);</span>
<span id="L382"><span class="lineNum">     382</span>              : </span>
<span id="L383"><span class="lineNum">     383</span>              : // X509_get_ext_by_OBJ behaves like |X509v3_get_ext_by_OBJ| but searches for</span>
<span id="L384"><span class="lineNum">     384</span>              : // extensions in |x|.</span>
<span id="L385"><span class="lineNum">     385</span>              : OPENSSL_EXPORT int X509_get_ext_by_OBJ(const X509 *x, const ASN1_OBJECT *obj,</span>
<span id="L386"><span class="lineNum">     386</span>              :                                        int lastpos);</span>
<span id="L387"><span class="lineNum">     387</span>              : </span>
<span id="L388"><span class="lineNum">     388</span>              : // X509_get_ext_by_critical behaves like |X509v3_get_ext_by_critical| but</span>
<span id="L389"><span class="lineNum">     389</span>              : // searches for extensions in |x|.</span>
<span id="L390"><span class="lineNum">     390</span>              : OPENSSL_EXPORT int X509_get_ext_by_critical(const X509 *x, int crit,</span>
<span id="L391"><span class="lineNum">     391</span>              :                                             int lastpos);</span>
<span id="L392"><span class="lineNum">     392</span>              : </span>
<span id="L393"><span class="lineNum">     393</span>              : // X509_get_ext returns the extension in |x| at index |loc|, or NULL if |loc| is</span>
<span id="L394"><span class="lineNum">     394</span>              : // out of bounds. This function returns a non-const pointer for OpenSSL</span>
<span id="L395"><span class="lineNum">     395</span>              : // compatibility, but callers should not mutate the result.</span>
<span id="L396"><span class="lineNum">     396</span>              : OPENSSL_EXPORT X509_EXTENSION *X509_get_ext(const X509 *x, int loc);</span>
<span id="L397"><span class="lineNum">     397</span>              : </span>
<span id="L398"><span class="lineNum">     398</span>              : // X509_get_ext_d2i behaves like |X509V3_get_d2i| but looks for the extension in</span>
<span id="L399"><span class="lineNum">     399</span>              : // |x509|'s extension list.</span>
<span id="L400"><span class="lineNum">     400</span>              : //</span>
<span id="L401"><span class="lineNum">     401</span>              : // WARNING: This function is difficult to use correctly. See the documentation</span>
<span id="L402"><span class="lineNum">     402</span>              : // for |X509V3_get_d2i| for details.</span>
<span id="L403"><span class="lineNum">     403</span>              : OPENSSL_EXPORT void *X509_get_ext_d2i(const X509 *x509, int nid,</span>
<span id="L404"><span class="lineNum">     404</span>              :                                       int *out_critical, int *out_idx);</span>
<span id="L405"><span class="lineNum">     405</span>              : </span>
<span id="L406"><span class="lineNum">     406</span>              : // X509_get0_tbs_sigalg returns the signature algorithm in |x509|'s</span>
<span id="L407"><span class="lineNum">     407</span>              : // TBSCertificate. For the outer signature algorithm, see |X509_get0_signature|.</span>
<span id="L408"><span class="lineNum">     408</span>              : //</span>
<span id="L409"><span class="lineNum">     409</span>              : // Certificates with mismatched signature algorithms will successfully parse,</span>
<span id="L410"><span class="lineNum">     410</span>              : // but they will be rejected when verifying.</span>
<span id="L411"><span class="lineNum">     411</span>              : OPENSSL_EXPORT const X509_ALGOR *X509_get0_tbs_sigalg(const X509 *x509);</span>
<span id="L412"><span class="lineNum">     412</span>              : </span>
<span id="L413"><span class="lineNum">     413</span>              : // X509_get0_signature sets |*out_sig| and |*out_alg| to the signature and</span>
<span id="L414"><span class="lineNum">     414</span>              : // signature algorithm of |x509|, respectively. Either output pointer may be</span>
<span id="L415"><span class="lineNum">     415</span>              : // NULL to ignore the value.</span>
<span id="L416"><span class="lineNum">     416</span>              : //</span>
<span id="L417"><span class="lineNum">     417</span>              : // This function outputs the outer signature algorithm. For the one in the</span>
<span id="L418"><span class="lineNum">     418</span>              : // TBSCertificate, see |X509_get0_tbs_sigalg|. Certificates with mismatched</span>
<span id="L419"><span class="lineNum">     419</span>              : // signature algorithms will successfully parse, but they will be rejected when</span>
<span id="L420"><span class="lineNum">     420</span>              : // verifying.</span>
<span id="L421"><span class="lineNum">     421</span>              : OPENSSL_EXPORT void X509_get0_signature(const ASN1_BIT_STRING **out_sig,</span>
<span id="L422"><span class="lineNum">     422</span>              :                                         const X509_ALGOR **out_alg,</span>
<span id="L423"><span class="lineNum">     423</span>              :                                         const X509 *x509);</span>
<span id="L424"><span class="lineNum">     424</span>              : </span>
<span id="L425"><span class="lineNum">     425</span>              : // X509_get_signature_nid returns the NID corresponding to |x509|'s signature</span>
<span id="L426"><span class="lineNum">     426</span>              : // algorithm, or |NID_undef| if the signature algorithm does not correspond to</span>
<span id="L427"><span class="lineNum">     427</span>              : // a known NID.</span>
<span id="L428"><span class="lineNum">     428</span>              : OPENSSL_EXPORT int X509_get_signature_nid(const X509 *x509);</span>
<span id="L429"><span class="lineNum">     429</span>              : </span>
<span id="L430"><span class="lineNum">     430</span>              : // i2d_X509_tbs serializes the TBSCertificate portion of |x509|, as described in</span>
<span id="L431"><span class="lineNum">     431</span>              : // |i2d_SAMPLE|.</span>
<span id="L432"><span class="lineNum">     432</span>              : //</span>
<span id="L433"><span class="lineNum">     433</span>              : // This function preserves the original encoding of the TBSCertificate and may</span>
<span id="L434"><span class="lineNum">     434</span>              : // not reflect modifications made to |x509|. It may be used to manually verify</span>
<span id="L435"><span class="lineNum">     435</span>              : // the signature of an existing certificate. To generate certificates, use</span>
<span id="L436"><span class="lineNum">     436</span>              : // |i2d_re_X509_tbs| instead.</span>
<span id="L437"><span class="lineNum">     437</span>              : OPENSSL_EXPORT int i2d_X509_tbs(X509 *x509, unsigned char **outp);</span>
<span id="L438"><span class="lineNum">     438</span>              : </span>
<span id="L439"><span class="lineNum">     439</span>              : // X509_verify checks that |x509| has a valid signature by |pkey|. It returns</span>
<span id="L440"><span class="lineNum">     440</span>              : // one if the signature is valid and zero otherwise. Note this function only</span>
<span id="L441"><span class="lineNum">     441</span>              : // checks the signature itself and does not perform a full certificate</span>
<span id="L442"><span class="lineNum">     442</span>              : // validation.</span>
<span id="L443"><span class="lineNum">     443</span>              : OPENSSL_EXPORT int X509_verify(X509 *x509, EVP_PKEY *pkey);</span>
<span id="L444"><span class="lineNum">     444</span>              : </span>
<span id="L445"><span class="lineNum">     445</span>              : // X509_get1_email returns a newly-allocated list of NUL-terminated strings</span>
<span id="L446"><span class="lineNum">     446</span>              : // containing all email addresses in |x509|'s subject and all rfc822name names</span>
<span id="L447"><span class="lineNum">     447</span>              : // in |x509|'s subject alternative names. Email addresses which contain embedded</span>
<span id="L448"><span class="lineNum">     448</span>              : // NUL bytes are skipped.</span>
<span id="L449"><span class="lineNum">     449</span>              : //</span>
<span id="L450"><span class="lineNum">     450</span>              : // On error, or if there are no such email addresses, it returns NULL. When</span>
<span id="L451"><span class="lineNum">     451</span>              : // done, the caller must release the result with |X509_email_free|.</span>
<span id="L452"><span class="lineNum">     452</span>              : OPENSSL_EXPORT STACK_OF(OPENSSL_STRING) *X509_get1_email(const X509 *x509);</span>
<span id="L453"><span class="lineNum">     453</span>              : </span>
<span id="L454"><span class="lineNum">     454</span>              : // X509_get1_ocsp returns a newly-allocated list of NUL-terminated strings</span>
<span id="L455"><span class="lineNum">     455</span>              : // containing all OCSP URIs in |x509|. That is, it collects all URI</span>
<span id="L456"><span class="lineNum">     456</span>              : // AccessDescriptions with an accessMethod of id-ad-ocsp in |x509|'s authority</span>
<span id="L457"><span class="lineNum">     457</span>              : // information access extension. URIs which contain embedded NUL bytes are</span>
<span id="L458"><span class="lineNum">     458</span>              : // skipped.</span>
<span id="L459"><span class="lineNum">     459</span>              : //</span>
<span id="L460"><span class="lineNum">     460</span>              : // On error, or if there are no such URIs, it returns NULL. When done, the</span>
<span id="L461"><span class="lineNum">     461</span>              : // caller must release the result with |X509_email_free|.</span>
<span id="L462"><span class="lineNum">     462</span>              : OPENSSL_EXPORT STACK_OF(OPENSSL_STRING) *X509_get1_ocsp(const X509 *x509);</span>
<span id="L463"><span class="lineNum">     463</span>              : </span>
<span id="L464"><span class="lineNum">     464</span>              : // X509_email_free releases memory associated with |sk|, including |sk| itself.</span>
<span id="L465"><span class="lineNum">     465</span>              : // Each |OPENSSL_STRING| in |sk| must be a NUL-terminated string allocated with</span>
<span id="L466"><span class="lineNum">     466</span>              : // |OPENSSL_malloc|. If |sk| is NULL, no action is taken.</span>
<span id="L467"><span class="lineNum">     467</span>              : OPENSSL_EXPORT void X509_email_free(STACK_OF(OPENSSL_STRING) *sk);</span>
<span id="L468"><span class="lineNum">     468</span>              : </span>
<span id="L469"><span class="lineNum">     469</span>              : // X509_cmp compares |a| and |b| and returns zero if they are equal, a negative</span>
<span id="L470"><span class="lineNum">     470</span>              : // number if |b| sorts after |a| and a negative number if |a| sorts after |b|.</span>
<span id="L471"><span class="lineNum">     471</span>              : // The sort order implemented by this function is arbitrary and does not</span>
<span id="L472"><span class="lineNum">     472</span>              : // reflect properties of the certificate such as expiry. Applications should not</span>
<span id="L473"><span class="lineNum">     473</span>              : // rely on the order itself.</span>
<span id="L474"><span class="lineNum">     474</span>              : //</span>
<span id="L475"><span class="lineNum">     475</span>              : // TODO(https://crbug.com/boringssl/355): This function works by comparing a</span>
<span id="L476"><span class="lineNum">     476</span>              : // cached hash of the encoded certificate. If |a| or |b| could not be</span>
<span id="L477"><span class="lineNum">     477</span>              : // serialized, the current behavior is to compare all unencodable certificates</span>
<span id="L478"><span class="lineNum">     478</span>              : // as equal. This function should only be used with |X509| objects that were</span>
<span id="L479"><span class="lineNum">     479</span>              : // parsed from bytes and never mutated.</span>
<span id="L480"><span class="lineNum">     480</span>              : //</span>
<span id="L481"><span class="lineNum">     481</span>              : // TODO(https://crbug.com/boringssl/407): This function is const, but it is not</span>
<span id="L482"><span class="lineNum">     482</span>              : // always thread-safe, notably if |a| and |b| were mutated.</span>
<span id="L483"><span class="lineNum">     483</span>              : OPENSSL_EXPORT int X509_cmp(const X509 *a, const X509 *b);</span>
<span id="L484"><span class="lineNum">     484</span>              : </span>
<span id="L485"><span class="lineNum">     485</span>              : </span>
<span id="L486"><span class="lineNum">     486</span>              : // Issuing certificates.</span>
<span id="L487"><span class="lineNum">     487</span>              : //</span>
<span id="L488"><span class="lineNum">     488</span>              : // An |X509| object may also represent an incomplete certificate. Callers may</span>
<span id="L489"><span class="lineNum">     489</span>              : // construct empty |X509| objects, fill in fields individually, and finally sign</span>
<span id="L490"><span class="lineNum">     490</span>              : // the result. The following functions may be used for this purpose.</span>
<span id="L491"><span class="lineNum">     491</span>              : </span>
<span id="L492"><span class="lineNum">     492</span>              : // X509_new returns a newly-allocated, empty |X509| object, or NULL on error.</span>
<span id="L493"><span class="lineNum">     493</span>              : // This produces an incomplete certificate which may be filled in to issue a new</span>
<span id="L494"><span class="lineNum">     494</span>              : // certificate.</span>
<span id="L495"><span class="lineNum">     495</span>              : OPENSSL_EXPORT X509 *X509_new(void);</span>
<span id="L496"><span class="lineNum">     496</span>              : </span>
<span id="L497"><span class="lineNum">     497</span>              : // X509_set_version sets |x509|'s version to |version|, which should be one of</span>
<span id="L498"><span class="lineNum">     498</span>              : // the |X509V_VERSION_*| constants. It returns one on success and zero on error.</span>
<span id="L499"><span class="lineNum">     499</span>              : //</span>
<span id="L500"><span class="lineNum">     500</span>              : // If unsure, use |X509_VERSION_3|.</span>
<span id="L501"><span class="lineNum">     501</span>              : OPENSSL_EXPORT int X509_set_version(X509 *x509, long version);</span>
<span id="L502"><span class="lineNum">     502</span>              : </span>
<span id="L503"><span class="lineNum">     503</span>              : // X509_set_serialNumber sets |x509|'s serial number to |serial|. It returns one</span>
<span id="L504"><span class="lineNum">     504</span>              : // on success and zero on error.</span>
<span id="L505"><span class="lineNum">     505</span>              : OPENSSL_EXPORT int X509_set_serialNumber(X509 *x509,</span>
<span id="L506"><span class="lineNum">     506</span>              :                                          const ASN1_INTEGER *serial);</span>
<span id="L507"><span class="lineNum">     507</span>              : </span>
<span id="L508"><span class="lineNum">     508</span>              : // X509_set1_notBefore sets |x509|'s notBefore time to |tm|. It returns one on</span>
<span id="L509"><span class="lineNum">     509</span>              : // success and zero on error.</span>
<span id="L510"><span class="lineNum">     510</span>              : OPENSSL_EXPORT int X509_set1_notBefore(X509 *x509, const ASN1_TIME *tm);</span>
<span id="L511"><span class="lineNum">     511</span>              : </span>
<span id="L512"><span class="lineNum">     512</span>              : // X509_set1_notAfter sets |x509|'s notAfter time to |tm|. it returns one on</span>
<span id="L513"><span class="lineNum">     513</span>              : // success and zero on error.</span>
<span id="L514"><span class="lineNum">     514</span>              : OPENSSL_EXPORT int X509_set1_notAfter(X509 *x509, const ASN1_TIME *tm);</span>
<span id="L515"><span class="lineNum">     515</span>              : </span>
<span id="L516"><span class="lineNum">     516</span>              : // X509_getm_notBefore returns a mutable pointer to |x509|'s notBefore time.</span>
<span id="L517"><span class="lineNum">     517</span>              : OPENSSL_EXPORT ASN1_TIME *X509_getm_notBefore(X509 *x509);</span>
<span id="L518"><span class="lineNum">     518</span>              : </span>
<span id="L519"><span class="lineNum">     519</span>              : // X509_getm_notAfter returns a mutable pointer to |x509|'s notAfter time.</span>
<span id="L520"><span class="lineNum">     520</span>              : OPENSSL_EXPORT ASN1_TIME *X509_getm_notAfter(X509 *x);</span>
<span id="L521"><span class="lineNum">     521</span>              : </span>
<span id="L522"><span class="lineNum">     522</span>              : // X509_set_issuer_name sets |x509|'s issuer to a copy of |name|. It returns one</span>
<span id="L523"><span class="lineNum">     523</span>              : // on success and zero on error.</span>
<span id="L524"><span class="lineNum">     524</span>              : OPENSSL_EXPORT int X509_set_issuer_name(X509 *x509, X509_NAME *name);</span>
<span id="L525"><span class="lineNum">     525</span>              : </span>
<span id="L526"><span class="lineNum">     526</span>              : // X509_set_subject_name sets |x509|'s subject to a copy of |name|. It returns</span>
<span id="L527"><span class="lineNum">     527</span>              : // one on success and zero on error.</span>
<span id="L528"><span class="lineNum">     528</span>              : OPENSSL_EXPORT int X509_set_subject_name(X509 *x509, X509_NAME *name);</span>
<span id="L529"><span class="lineNum">     529</span>              : </span>
<span id="L530"><span class="lineNum">     530</span>              : // X509_set_pubkey sets |x509|'s public key to |pkey|. It returns one on success</span>
<span id="L531"><span class="lineNum">     531</span>              : // and zero on error. This function does not take ownership of |pkey| and</span>
<span id="L532"><span class="lineNum">     532</span>              : // internally copies and updates reference counts as needed.</span>
<span id="L533"><span class="lineNum">     533</span>              : OPENSSL_EXPORT int X509_set_pubkey(X509 *x509, EVP_PKEY *pkey);</span>
<span id="L534"><span class="lineNum">     534</span>              : </span>
<span id="L535"><span class="lineNum">     535</span>              : // X509_delete_ext removes the extension in |x| at index |loc| and returns the</span>
<span id="L536"><span class="lineNum">     536</span>              : // removed extension, or NULL if |loc| was out of bounds. If non-NULL, the</span>
<span id="L537"><span class="lineNum">     537</span>              : // caller must release the result with |X509_EXTENSION_free|.</span>
<span id="L538"><span class="lineNum">     538</span>              : OPENSSL_EXPORT X509_EXTENSION *X509_delete_ext(X509 *x, int loc);</span>
<span id="L539"><span class="lineNum">     539</span>              : </span>
<span id="L540"><span class="lineNum">     540</span>              : // X509_add_ext adds a copy of |ex| to |x|. It returns one on success and zero</span>
<span id="L541"><span class="lineNum">     541</span>              : // on failure. The caller retains ownership of |ex| and can release it</span>
<span id="L542"><span class="lineNum">     542</span>              : // independently of |x|.</span>
<span id="L543"><span class="lineNum">     543</span>              : //</span>
<span id="L544"><span class="lineNum">     544</span>              : // The new extension is inserted at index |loc|, shifting extensions to the</span>
<span id="L545"><span class="lineNum">     545</span>              : // right. If |loc| is -1 or out of bounds, the new extension is appended to the</span>
<span id="L546"><span class="lineNum">     546</span>              : // list.</span>
<span id="L547"><span class="lineNum">     547</span>              : OPENSSL_EXPORT int X509_add_ext(X509 *x, const X509_EXTENSION *ex, int loc);</span>
<span id="L548"><span class="lineNum">     548</span>              : </span>
<span id="L549"><span class="lineNum">     549</span>              : // X509_add1_ext_i2d behaves like |X509V3_add1_i2d| but adds the extension to</span>
<span id="L550"><span class="lineNum">     550</span>              : // |x|'s extension list.</span>
<span id="L551"><span class="lineNum">     551</span>              : //</span>
<span id="L552"><span class="lineNum">     552</span>              : // WARNING: This function may return zero or -1 on error. The caller must also</span>
<span id="L553"><span class="lineNum">     553</span>              : // ensure |value|'s type matches |nid|. See the documentation for</span>
<span id="L554"><span class="lineNum">     554</span>              : // |X509V3_add1_i2d| for details.</span>
<span id="L555"><span class="lineNum">     555</span>              : OPENSSL_EXPORT int X509_add1_ext_i2d(X509 *x, int nid, void *value, int crit,</span>
<span id="L556"><span class="lineNum">     556</span>              :                                      unsigned long flags);</span>
<span id="L557"><span class="lineNum">     557</span>              : </span>
<span id="L558"><span class="lineNum">     558</span>              : // X509_sign signs |x509| with |pkey| and replaces the signature algorithm and</span>
<span id="L559"><span class="lineNum">     559</span>              : // signature fields. It returns the length of the signature on success and zero</span>
<span id="L560"><span class="lineNum">     560</span>              : // on error. This function uses digest algorithm |md|, or |pkey|'s default if</span>
<span id="L561"><span class="lineNum">     561</span>              : // NULL. Other signing parameters use |pkey|'s defaults. To customize them, use</span>
<span id="L562"><span class="lineNum">     562</span>              : // |X509_sign_ctx|.</span>
<span id="L563"><span class="lineNum">     563</span>              : OPENSSL_EXPORT int X509_sign(X509 *x509, EVP_PKEY *pkey, const EVP_MD *md);</span>
<span id="L564"><span class="lineNum">     564</span>              : </span>
<span id="L565"><span class="lineNum">     565</span>              : // X509_sign_ctx signs |x509| with |ctx| and replaces the signature algorithm</span>
<span id="L566"><span class="lineNum">     566</span>              : // and signature fields. It returns the length of the signature on success and</span>
<span id="L567"><span class="lineNum">     567</span>              : // zero on error. The signature algorithm and parameters come from |ctx|, which</span>
<span id="L568"><span class="lineNum">     568</span>              : // must have been initialized with |EVP_DigestSignInit|. The caller should</span>
<span id="L569"><span class="lineNum">     569</span>              : // configure the corresponding |EVP_PKEY_CTX| before calling this function.</span>
<span id="L570"><span class="lineNum">     570</span>              : //</span>
<span id="L571"><span class="lineNum">     571</span>              : // On success or failure, this function mutates |ctx| and resets it to the empty</span>
<span id="L572"><span class="lineNum">     572</span>              : // state. Caller should not rely on its contents after the function returns.</span>
<span id="L573"><span class="lineNum">     573</span>              : OPENSSL_EXPORT int X509_sign_ctx(X509 *x509, EVP_MD_CTX *ctx);</span>
<span id="L574"><span class="lineNum">     574</span>              : </span>
<span id="L575"><span class="lineNum">     575</span>              : // i2d_re_X509_tbs serializes the TBSCertificate portion of |x509|, as described</span>
<span id="L576"><span class="lineNum">     576</span>              : // in |i2d_SAMPLE|.</span>
<span id="L577"><span class="lineNum">     577</span>              : //</span>
<span id="L578"><span class="lineNum">     578</span>              : // This function re-encodes the TBSCertificate and may not reflect |x509|'s</span>
<span id="L579"><span class="lineNum">     579</span>              : // original encoding. It may be used to manually generate a signature for a new</span>
<span id="L580"><span class="lineNum">     580</span>              : // certificate. To verify certificates, use |i2d_X509_tbs| instead.</span>
<span id="L581"><span class="lineNum">     581</span>              : OPENSSL_EXPORT int i2d_re_X509_tbs(X509 *x509, unsigned char **outp);</span>
<span id="L582"><span class="lineNum">     582</span>              : </span>
<span id="L583"><span class="lineNum">     583</span>              : // X509_set1_signature_algo sets |x509|'s signature algorithm to |algo| and</span>
<span id="L584"><span class="lineNum">     584</span>              : // returns one on success or zero on error. It updates both the signature field</span>
<span id="L585"><span class="lineNum">     585</span>              : // of the TBSCertificate structure, and the signatureAlgorithm field of the</span>
<span id="L586"><span class="lineNum">     586</span>              : // Certificate.</span>
<span id="L587"><span class="lineNum">     587</span>              : OPENSSL_EXPORT int X509_set1_signature_algo(X509 *x509, const X509_ALGOR *algo);</span>
<span id="L588"><span class="lineNum">     588</span>              : </span>
<span id="L589"><span class="lineNum">     589</span>              : // X509_set1_signature_value sets |x509|'s signature to a copy of the |sig_len|</span>
<span id="L590"><span class="lineNum">     590</span>              : // bytes pointed by |sig|. It returns one on success and zero on error.</span>
<span id="L591"><span class="lineNum">     591</span>              : //</span>
<span id="L592"><span class="lineNum">     592</span>              : // Due to a specification error, X.509 certificates store signatures in ASN.1</span>
<span id="L593"><span class="lineNum">     593</span>              : // BIT STRINGs, but signature algorithms return byte strings rather than bit</span>
<span id="L594"><span class="lineNum">     594</span>              : // strings. This function creates a BIT STRING containing a whole number of</span>
<span id="L595"><span class="lineNum">     595</span>              : // bytes, with the bit order matching the DER encoding. This matches the</span>
<span id="L596"><span class="lineNum">     596</span>              : // encoding used by all X.509 signature algorithms.</span>
<span id="L597"><span class="lineNum">     597</span>              : OPENSSL_EXPORT int X509_set1_signature_value(X509 *x509, const uint8_t *sig,</span>
<span id="L598"><span class="lineNum">     598</span>              :                                              size_t sig_len);</span>
<span id="L599"><span class="lineNum">     599</span>              : </span>
<span id="L600"><span class="lineNum">     600</span>              : </span>
<span id="L601"><span class="lineNum">     601</span>              : // Auxiliary certificate properties.</span>
<span id="L602"><span class="lineNum">     602</span>              : //</span>
<span id="L603"><span class="lineNum">     603</span>              : // |X509| objects optionally maintain auxiliary properties. These are not part</span>
<span id="L604"><span class="lineNum">     604</span>              : // of the certificates themselves, and thus are not covered by signatures or</span>
<span id="L605"><span class="lineNum">     605</span>              : // preserved by the standard serialization. They are used as inputs or outputs</span>
<span id="L606"><span class="lineNum">     606</span>              : // to other functions in this library.</span>
<span id="L607"><span class="lineNum">     607</span>              : </span>
<span id="L608"><span class="lineNum">     608</span>              : // i2d_X509_AUX marshals |x509| as a DER-encoded X.509 Certificate (RFC 5280),</span>
<span id="L609"><span class="lineNum">     609</span>              : // followed optionally by a separate, OpenSSL-specific structure with auxiliary</span>
<span id="L610"><span class="lineNum">     610</span>              : // properties. It behaves as described in |i2d_SAMPLE|.</span>
<span id="L611"><span class="lineNum">     611</span>              : //</span>
<span id="L612"><span class="lineNum">     612</span>              : // Unlike similarly-named functions, this function does not output a single</span>
<span id="L613"><span class="lineNum">     613</span>              : // ASN.1 element. Directly embedding the output in a larger ASN.1 structure will</span>
<span id="L614"><span class="lineNum">     614</span>              : // not behave correctly.</span>
<span id="L615"><span class="lineNum">     615</span>              : //</span>
<span id="L616"><span class="lineNum">     616</span>              : // TODO(crbug.com/boringssl/407): |x509| should be const.</span>
<span id="L617"><span class="lineNum">     617</span>              : OPENSSL_EXPORT int i2d_X509_AUX(X509 *x509, uint8_t **outp);</span>
<span id="L618"><span class="lineNum">     618</span>              : </span>
<span id="L619"><span class="lineNum">     619</span>              : // d2i_X509_AUX parses up to |length| bytes from |*inp| as a DER-encoded X.509</span>
<span id="L620"><span class="lineNum">     620</span>              : // Certificate (RFC 5280), followed optionally by a separate, OpenSSL-specific</span>
<span id="L621"><span class="lineNum">     621</span>              : // structure with auxiliary properties. It behaves as described in |d2i_SAMPLE|.</span>
<span id="L622"><span class="lineNum">     622</span>              : //</span>
<span id="L623"><span class="lineNum">     623</span>              : // WARNING: Passing untrusted input to this function allows an attacker to</span>
<span id="L624"><span class="lineNum">     624</span>              : // control auxiliary properties. This can allow unexpected influence over the</span>
<span id="L625"><span class="lineNum">     625</span>              : // application if the certificate is used in a context that reads auxiliary</span>
<span id="L626"><span class="lineNum">     626</span>              : // properties. This includes PKCS#12 serialization, trusted certificates in</span>
<span id="L627"><span class="lineNum">     627</span>              : // |X509_STORE|, and callers of |X509_alias_get0| or |X509_keyid_get0|.</span>
<span id="L628"><span class="lineNum">     628</span>              : //</span>
<span id="L629"><span class="lineNum">     629</span>              : // Unlike similarly-named functions, this function does not parse a single</span>
<span id="L630"><span class="lineNum">     630</span>              : // ASN.1 element. Trying to parse data directly embedded in a larger ASN.1</span>
<span id="L631"><span class="lineNum">     631</span>              : // structure will not behave correctly.</span>
<span id="L632"><span class="lineNum">     632</span>              : OPENSSL_EXPORT X509 *d2i_X509_AUX(X509 **x509, const uint8_t **inp,</span>
<span id="L633"><span class="lineNum">     633</span>              :                                   long length);</span>
<span id="L634"><span class="lineNum">     634</span>              : </span>
<span id="L635"><span class="lineNum">     635</span>              : // X509_alias_set1 sets |x509|'s alias to |len| bytes from |name|. If |name| is</span>
<span id="L636"><span class="lineNum">     636</span>              : // NULL, the alias is cleared instead. Aliases are not part of the certificate</span>
<span id="L637"><span class="lineNum">     637</span>              : // itself and will not be serialized by |i2d_X509|. If |x509| is serialized in</span>
<span id="L638"><span class="lineNum">     638</span>              : // a PKCS#12 structure, the friendlyName attribute (RFC 2985) will contain this</span>
<span id="L639"><span class="lineNum">     639</span>              : // alias.</span>
<span id="L640"><span class="lineNum">     640</span>              : OPENSSL_EXPORT int X509_alias_set1(X509 *x509, const uint8_t *name,</span>
<span id="L641"><span class="lineNum">     641</span>              :                                    ossl_ssize_t len);</span>
<span id="L642"><span class="lineNum">     642</span>              : </span>
<span id="L643"><span class="lineNum">     643</span>              : // X509_keyid_set1 sets |x509|'s key ID to |len| bytes from |id|. If |id| is</span>
<span id="L644"><span class="lineNum">     644</span>              : // NULL, the key ID is cleared instead. Key IDs are not part of the certificate</span>
<span id="L645"><span class="lineNum">     645</span>              : // itself and will not be serialized by |i2d_X509|.</span>
<span id="L646"><span class="lineNum">     646</span>              : OPENSSL_EXPORT int X509_keyid_set1(X509 *x509, const uint8_t *id,</span>
<span id="L647"><span class="lineNum">     647</span>              :                                    ossl_ssize_t len);</span>
<span id="L648"><span class="lineNum">     648</span>              : </span>
<span id="L649"><span class="lineNum">     649</span>              : // X509_alias_get0 looks up |x509|'s alias. If found, it sets |*out_len| to the</span>
<span id="L650"><span class="lineNum">     650</span>              : // alias's length and returns a pointer to a buffer containing the contents. If</span>
<span id="L651"><span class="lineNum">     651</span>              : // not found, it outputs the empty string by returning NULL and setting</span>
<span id="L652"><span class="lineNum">     652</span>              : // |*out_len| to zero.</span>
<span id="L653"><span class="lineNum">     653</span>              : //</span>
<span id="L654"><span class="lineNum">     654</span>              : // If |x509| was parsed from a PKCS#12 structure (see</span>
<span id="L655"><span class="lineNum">     655</span>              : // |PKCS12_get_key_and_certs|), the alias will reflect the friendlyName</span>
<span id="L656"><span class="lineNum">     656</span>              : // attribute (RFC 2985).</span>
<span id="L657"><span class="lineNum">     657</span>              : //</span>
<span id="L658"><span class="lineNum">     658</span>              : // WARNING: In OpenSSL, this function did not set |*out_len| when the alias was</span>
<span id="L659"><span class="lineNum">     659</span>              : // missing. Callers that target both OpenSSL and BoringSSL should set the value</span>
<span id="L660"><span class="lineNum">     660</span>              : // to zero before calling this function.</span>
<span id="L661"><span class="lineNum">     661</span>              : OPENSSL_EXPORT const uint8_t *X509_alias_get0(const X509 *x509, int *out_len);</span>
<span id="L662"><span class="lineNum">     662</span>              : </span>
<span id="L663"><span class="lineNum">     663</span>              : // X509_keyid_get0 looks up |x509|'s key ID. If found, it sets |*out_len| to the</span>
<span id="L664"><span class="lineNum">     664</span>              : // key ID's length and returns a pointer to a buffer containing the contents. If</span>
<span id="L665"><span class="lineNum">     665</span>              : // not found, it outputs the empty string by returning NULL and setting</span>
<span id="L666"><span class="lineNum">     666</span>              : // |*out_len| to zero.</span>
<span id="L667"><span class="lineNum">     667</span>              : //</span>
<span id="L668"><span class="lineNum">     668</span>              : // WARNING: In OpenSSL, this function did not set |*out_len| when the alias was</span>
<span id="L669"><span class="lineNum">     669</span>              : // missing. Callers that target both OpenSSL and BoringSSL should set the value</span>
<span id="L670"><span class="lineNum">     670</span>              : // to zero before calling this function.</span>
<span id="L671"><span class="lineNum">     671</span>              : OPENSSL_EXPORT const uint8_t *X509_keyid_get0(const X509 *x509, int *out_len);</span>
<span id="L672"><span class="lineNum">     672</span>              : </span>
<span id="L673"><span class="lineNum">     673</span>              : // X509_add1_trust_object configures |x509| as a valid trust anchor for |obj|.</span>
<span id="L674"><span class="lineNum">     674</span>              : // It returns one on success and zero on error. |obj| should be a certificate</span>
<span id="L675"><span class="lineNum">     675</span>              : // usage OID associated with an |X509_TRUST_*| constant.</span>
<span id="L676"><span class="lineNum">     676</span>              : //</span>
<span id="L677"><span class="lineNum">     677</span>              : // See |X509_VERIFY_PARAM_set_trust| for details on how this value is evaluated.</span>
<span id="L678"><span class="lineNum">     678</span>              : // Note this only takes effect if |x509| was configured as a trusted certificate</span>
<span id="L679"><span class="lineNum">     679</span>              : // via |X509_STORE|.</span>
<span id="L680"><span class="lineNum">     680</span>              : OPENSSL_EXPORT int X509_add1_trust_object(X509 *x509, const ASN1_OBJECT *obj);</span>
<span id="L681"><span class="lineNum">     681</span>              : </span>
<span id="L682"><span class="lineNum">     682</span>              : // X509_add1_reject_object configures |x509| as distrusted for |obj|. It returns</span>
<span id="L683"><span class="lineNum">     683</span>              : // one on success and zero on error. |obj| should be a certificate usage OID</span>
<span id="L684"><span class="lineNum">     684</span>              : // associated with an |X509_TRUST_*| constant.</span>
<span id="L685"><span class="lineNum">     685</span>              : //</span>
<span id="L686"><span class="lineNum">     686</span>              : // See |X509_VERIFY_PARAM_set_trust| for details on how this value is evaluated.</span>
<span id="L687"><span class="lineNum">     687</span>              : // Note this only takes effect if |x509| was configured as a trusted certificate</span>
<span id="L688"><span class="lineNum">     688</span>              : // via |X509_STORE|.</span>
<span id="L689"><span class="lineNum">     689</span>              : OPENSSL_EXPORT int X509_add1_reject_object(X509 *x509, const ASN1_OBJECT *obj);</span>
<span id="L690"><span class="lineNum">     690</span>              : </span>
<span id="L691"><span class="lineNum">     691</span>              : // X509_trust_clear clears the list of OIDs for which |x509| is trusted. See</span>
<span id="L692"><span class="lineNum">     692</span>              : // also |X509_add1_trust_object|.</span>
<span id="L693"><span class="lineNum">     693</span>              : OPENSSL_EXPORT void X509_trust_clear(X509 *x509);</span>
<span id="L694"><span class="lineNum">     694</span>              : </span>
<span id="L695"><span class="lineNum">     695</span>              : // X509_reject_clear clears the list of OIDs for which |x509| is distrusted. See</span>
<span id="L696"><span class="lineNum">     696</span>              : // also |X509_add1_reject_object|.</span>
<span id="L697"><span class="lineNum">     697</span>              : OPENSSL_EXPORT void X509_reject_clear(X509 *x509);</span>
<span id="L698"><span class="lineNum">     698</span>              : </span>
<span id="L699"><span class="lineNum">     699</span>              : </span>
<span id="L700"><span class="lineNum">     700</span>              : // Certificate revocation lists.</span>
<span id="L701"><span class="lineNum">     701</span>              : //</span>
<span id="L702"><span class="lineNum">     702</span>              : // An |X509_CRL| object represents an X.509 certificate revocation list (CRL),</span>
<span id="L703"><span class="lineNum">     703</span>              : // defined in RFC 5280. A CRL is a signed list of certificates, the</span>
<span id="L704"><span class="lineNum">     704</span>              : // revokedCertificates field, which are no longer considered valid. Each entry</span>
<span id="L705"><span class="lineNum">     705</span>              : // of this list is represented with an |X509_REVOKED| object, documented in the</span>
<span id="L706"><span class="lineNum">     706</span>              : // &quot;CRL entries&quot; section below.</span>
<span id="L707"><span class="lineNum">     707</span>              : //</span>
<span id="L708"><span class="lineNum">     708</span>              : // Although an |X509_CRL| is a mutable object, mutating an |X509_CRL| or its</span>
<span id="L709"><span class="lineNum">     709</span>              : // |X509_REVOKED|s can give incorrect results. Callers typically obtain</span>
<span id="L710"><span class="lineNum">     710</span>              : // |X509_CRL|s by parsing some input with |d2i_X509_CRL|, etc. Such objects</span>
<span id="L711"><span class="lineNum">     711</span>              : // carry information such as the serialized TBSCertList and decoded extensions,</span>
<span id="L712"><span class="lineNum">     712</span>              : // which will become inconsistent when mutated.</span>
<span id="L713"><span class="lineNum">     713</span>              : //</span>
<span id="L714"><span class="lineNum">     714</span>              : // Instead, mutation functions should only be used when issuing new CRLs, as</span>
<span id="L715"><span class="lineNum">     715</span>              : // described in a later section.</span>
<span id="L716"><span class="lineNum">     716</span>              : </span>
<span id="L717"><span class="lineNum">     717</span>              : DEFINE_STACK_OF(X509_CRL)</span>
<span id="L718"><span class="lineNum">     718</span>              : DEFINE_STACK_OF(X509_REVOKED)</span>
<span id="L719"><span class="lineNum">     719</span>              : </span>
<span id="L720"><span class="lineNum">     720</span>              : // X509_CRL_up_ref adds one to the reference count of |crl| and returns one.</span>
<span id="L721"><span class="lineNum">     721</span>              : OPENSSL_EXPORT int X509_CRL_up_ref(X509_CRL *crl);</span>
<span id="L722"><span class="lineNum">     722</span>              : </span>
<span id="L723"><span class="lineNum">     723</span>              : // X509_CRL_dup returns a newly-allocated copy of |crl|, or NULL on error. This</span>
<span id="L724"><span class="lineNum">     724</span>              : // function works by serializing the structure, so if |crl| is incomplete, it</span>
<span id="L725"><span class="lineNum">     725</span>              : // may fail.</span>
<span id="L726"><span class="lineNum">     726</span>              : //</span>
<span id="L727"><span class="lineNum">     727</span>              : // TODO(https://crbug.com/boringssl/407): This function should be const and</span>
<span id="L728"><span class="lineNum">     728</span>              : // thread-safe but is currently neither in some cases, notably if |crl| was</span>
<span id="L729"><span class="lineNum">     729</span>              : // mutated.</span>
<span id="L730"><span class="lineNum">     730</span>              : OPENSSL_EXPORT X509_CRL *X509_CRL_dup(X509_CRL *crl);</span>
<span id="L731"><span class="lineNum">     731</span>              : </span>
<span id="L732"><span class="lineNum">     732</span>              : // X509_CRL_free decrements |crl|'s reference count and, if zero, releases</span>
<span id="L733"><span class="lineNum">     733</span>              : // memory associated with |crl|.</span>
<span id="L734"><span class="lineNum">     734</span>              : OPENSSL_EXPORT void X509_CRL_free(X509_CRL *crl);</span>
<span id="L735"><span class="lineNum">     735</span>              : </span>
<span id="L736"><span class="lineNum">     736</span>              : // d2i_X509_CRL parses up to |len| bytes from |*inp| as a DER-encoded X.509</span>
<span id="L737"><span class="lineNum">     737</span>              : // CertificateList (RFC 5280), as described in |d2i_SAMPLE|.</span>
<span id="L738"><span class="lineNum">     738</span>              : OPENSSL_EXPORT X509_CRL *d2i_X509_CRL(X509_CRL **out, const uint8_t **inp,</span>
<span id="L739"><span class="lineNum">     739</span>              :                                       long len);</span>
<span id="L740"><span class="lineNum">     740</span>              : </span>
<span id="L741"><span class="lineNum">     741</span>              : // i2d_X509_CRL marshals |crl| as a X.509 CertificateList (RFC 5280), as</span>
<span id="L742"><span class="lineNum">     742</span>              : // described in |i2d_SAMPLE|.</span>
<span id="L743"><span class="lineNum">     743</span>              : //</span>
<span id="L744"><span class="lineNum">     744</span>              : // TODO(https://crbug.com/boringssl/407): This function should be const and</span>
<span id="L745"><span class="lineNum">     745</span>              : // thread-safe but is currently neither in some cases, notably if |crl| was</span>
<span id="L746"><span class="lineNum">     746</span>              : // mutated.</span>
<span id="L747"><span class="lineNum">     747</span>              : OPENSSL_EXPORT int i2d_X509_CRL(X509_CRL *crl, uint8_t **outp);</span>
<span id="L748"><span class="lineNum">     748</span>              : </span>
<span id="L749"><span class="lineNum">     749</span>              : // X509_CRL_match compares |a| and |b| and returns zero if they are equal, a</span>
<span id="L750"><span class="lineNum">     750</span>              : // negative number if |b| sorts after |a| and a negative number if |a| sorts</span>
<span id="L751"><span class="lineNum">     751</span>              : // after |b|. The sort order implemented by this function is arbitrary and does</span>
<span id="L752"><span class="lineNum">     752</span>              : // not reflect properties of the CRL such as expiry. Applications should not</span>
<span id="L753"><span class="lineNum">     753</span>              : // rely on the order itself.</span>
<span id="L754"><span class="lineNum">     754</span>              : //</span>
<span id="L755"><span class="lineNum">     755</span>              : // TODO(https://crbug.com/boringssl/355): This function works by comparing a</span>
<span id="L756"><span class="lineNum">     756</span>              : // cached hash of the encoded CRL. This cached hash is computed when the CRL is</span>
<span id="L757"><span class="lineNum">     757</span>              : // parsed, but not when mutating or issuing CRLs. This function should only be</span>
<span id="L758"><span class="lineNum">     758</span>              : // used with |X509_CRL| objects that were parsed from bytes and never mutated.</span>
<span id="L759"><span class="lineNum">     759</span>              : OPENSSL_EXPORT int X509_CRL_match(const X509_CRL *a, const X509_CRL *b);</span>
<span id="L760"><span class="lineNum">     760</span>              : </span>
<span id="L761"><span class="lineNum">     761</span>              : #define X509_CRL_VERSION_1 0</span>
<span id="L762"><span class="lineNum">     762</span>              : #define X509_CRL_VERSION_2 1</span>
<span id="L763"><span class="lineNum">     763</span>              : </span>
<span id="L764"><span class="lineNum">     764</span>              : // X509_CRL_get_version returns the numerical value of |crl|'s version, which</span>
<span id="L765"><span class="lineNum">     765</span>              : // will be one of the |X509_CRL_VERSION_*| constants.</span>
<span id="L766"><span class="lineNum">     766</span>              : OPENSSL_EXPORT long X509_CRL_get_version(const X509_CRL *crl);</span>
<span id="L767"><span class="lineNum">     767</span>              : </span>
<span id="L768"><span class="lineNum">     768</span>              : // X509_CRL_get0_lastUpdate returns |crl|'s thisUpdate time. The OpenSSL API</span>
<span id="L769"><span class="lineNum">     769</span>              : // refers to this field as lastUpdate.</span>
<span id="L770"><span class="lineNum">     770</span>              : OPENSSL_EXPORT const ASN1_TIME *X509_CRL_get0_lastUpdate(const X509_CRL *crl);</span>
<span id="L771"><span class="lineNum">     771</span>              : </span>
<span id="L772"><span class="lineNum">     772</span>              : // X509_CRL_get0_nextUpdate returns |crl|'s nextUpdate time, or NULL if |crl|</span>
<span id="L773"><span class="lineNum">     773</span>              : // has none.</span>
<span id="L774"><span class="lineNum">     774</span>              : OPENSSL_EXPORT const ASN1_TIME *X509_CRL_get0_nextUpdate(const X509_CRL *crl);</span>
<span id="L775"><span class="lineNum">     775</span>              : </span>
<span id="L776"><span class="lineNum">     776</span>              : // X509_CRL_get_issuer returns |crl|'s issuer name. Note this function is not</span>
<span id="L777"><span class="lineNum">     777</span>              : // const-correct for legacy reasons.</span>
<span id="L778"><span class="lineNum">     778</span>              : OPENSSL_EXPORT X509_NAME *X509_CRL_get_issuer(const X509_CRL *crl);</span>
<span id="L779"><span class="lineNum">     779</span>              : </span>
<span id="L780"><span class="lineNum">     780</span>              : // X509_CRL_get0_by_serial finds the entry in |crl| whose serial number is</span>
<span id="L781"><span class="lineNum">     781</span>              : // |serial|. If found, it sets |*out| to the entry and returns one. If not</span>
<span id="L782"><span class="lineNum">     782</span>              : // found, it returns zero.</span>
<span id="L783"><span class="lineNum">     783</span>              : //</span>
<span id="L784"><span class="lineNum">     784</span>              : // On success, |*out| continues to be owned by |crl|. It is an error to free or</span>
<span id="L785"><span class="lineNum">     785</span>              : // otherwise modify |*out|.</span>
<span id="L786"><span class="lineNum">     786</span>              : //</span>
<span id="L787"><span class="lineNum">     787</span>              : // TODO(crbug.com/boringssl/600): Ideally |crl| would be const. It is broadly</span>
<span id="L788"><span class="lineNum">     788</span>              : // thread-safe, but changes the order of entries in |crl|. It cannot be called</span>
<span id="L789"><span class="lineNum">     789</span>              : // concurrently with |i2d_X509_CRL|.</span>
<span id="L790"><span class="lineNum">     790</span>              : OPENSSL_EXPORT int X509_CRL_get0_by_serial(X509_CRL *crl, X509_REVOKED **out,</span>
<span id="L791"><span class="lineNum">     791</span>              :                                            const ASN1_INTEGER *serial);</span>
<span id="L792"><span class="lineNum">     792</span>              : </span>
<span id="L793"><span class="lineNum">     793</span>              : // X509_CRL_get0_by_cert behaves like |X509_CRL_get0_by_serial|, except it looks</span>
<span id="L794"><span class="lineNum">     794</span>              : // for the entry that matches |x509|.</span>
<span id="L795"><span class="lineNum">     795</span>              : OPENSSL_EXPORT int X509_CRL_get0_by_cert(X509_CRL *crl, X509_REVOKED **out,</span>
<span id="L796"><span class="lineNum">     796</span>              :                                          X509 *x509);</span>
<span id="L797"><span class="lineNum">     797</span>              : </span>
<span id="L798"><span class="lineNum">     798</span>              : // X509_CRL_get_REVOKED returns the list of revoked certificates in |crl|, or</span>
<span id="L799"><span class="lineNum">     799</span>              : // NULL if |crl| omits it.</span>
<span id="L800"><span class="lineNum">     800</span>              : //</span>
<span id="L801"><span class="lineNum">     801</span>              : // TOOD(davidben): This function was originally a macro, without clear const</span>
<span id="L802"><span class="lineNum">     802</span>              : // semantics. It should take a const input and give const output, but the latter</span>
<span id="L803"><span class="lineNum">     803</span>              : // would break existing callers. For now, we match upstream.</span>
<span id="L804"><span class="lineNum">     804</span>              : OPENSSL_EXPORT STACK_OF(X509_REVOKED) *X509_CRL_get_REVOKED(X509_CRL *crl);</span>
<span id="L805"><span class="lineNum">     805</span>              : </span>
<span id="L806"><span class="lineNum">     806</span>              : // X509_CRL_get0_extensions returns |crl|'s extension list, or NULL if |crl|</span>
<span id="L807"><span class="lineNum">     807</span>              : // omits it. A CRL can have extensions on individual entries, which is</span>
<span id="L808"><span class="lineNum">     808</span>              : // |X509_REVOKED_get0_extensions|, or on the overall CRL, which is this</span>
<span id="L809"><span class="lineNum">     809</span>              : // function.</span>
<span id="L810"><span class="lineNum">     810</span>              : OPENSSL_EXPORT const STACK_OF(X509_EXTENSION) *X509_CRL_get0_extensions(</span>
<span id="L811"><span class="lineNum">     811</span>              :     const X509_CRL *crl);</span>
<span id="L812"><span class="lineNum">     812</span>              : </span>
<span id="L813"><span class="lineNum">     813</span>              : // X509_CRL_get_ext_count returns the number of extensions in |x|.</span>
<span id="L814"><span class="lineNum">     814</span>              : OPENSSL_EXPORT int X509_CRL_get_ext_count(const X509_CRL *x);</span>
<span id="L815"><span class="lineNum">     815</span>              : </span>
<span id="L816"><span class="lineNum">     816</span>              : // X509_CRL_get_ext_by_NID behaves like |X509v3_get_ext_by_NID| but searches for</span>
<span id="L817"><span class="lineNum">     817</span>              : // extensions in |x|.</span>
<span id="L818"><span class="lineNum">     818</span>              : OPENSSL_EXPORT int X509_CRL_get_ext_by_NID(const X509_CRL *x, int nid,</span>
<span id="L819"><span class="lineNum">     819</span>              :                                            int lastpos);</span>
<span id="L820"><span class="lineNum">     820</span>              : </span>
<span id="L821"><span class="lineNum">     821</span>              : // X509_CRL_get_ext_by_OBJ behaves like |X509v3_get_ext_by_OBJ| but searches for</span>
<span id="L822"><span class="lineNum">     822</span>              : // extensions in |x|.</span>
<span id="L823"><span class="lineNum">     823</span>              : OPENSSL_EXPORT int X509_CRL_get_ext_by_OBJ(const X509_CRL *x,</span>
<span id="L824"><span class="lineNum">     824</span>              :                                            const ASN1_OBJECT *obj, int lastpos);</span>
<span id="L825"><span class="lineNum">     825</span>              : </span>
<span id="L826"><span class="lineNum">     826</span>              : // X509_CRL_get_ext_by_critical behaves like |X509v3_get_ext_by_critical| but</span>
<span id="L827"><span class="lineNum">     827</span>              : // searches for extensions in |x|.</span>
<span id="L828"><span class="lineNum">     828</span>              : OPENSSL_EXPORT int X509_CRL_get_ext_by_critical(const X509_CRL *x, int crit,</span>
<span id="L829"><span class="lineNum">     829</span>              :                                                 int lastpos);</span>
<span id="L830"><span class="lineNum">     830</span>              : </span>
<span id="L831"><span class="lineNum">     831</span>              : // X509_CRL_get_ext returns the extension in |x| at index |loc|, or NULL if</span>
<span id="L832"><span class="lineNum">     832</span>              : // |loc| is out of bounds. This function returns a non-const pointer for OpenSSL</span>
<span id="L833"><span class="lineNum">     833</span>              : // compatibility, but callers should not mutate the result.</span>
<span id="L834"><span class="lineNum">     834</span>              : OPENSSL_EXPORT X509_EXTENSION *X509_CRL_get_ext(const X509_CRL *x, int loc);</span>
<span id="L835"><span class="lineNum">     835</span>              : </span>
<span id="L836"><span class="lineNum">     836</span>              : // X509_CRL_get_ext_d2i behaves like |X509V3_get_d2i| but looks for the</span>
<span id="L837"><span class="lineNum">     837</span>              : // extension in |crl|'s extension list.</span>
<span id="L838"><span class="lineNum">     838</span>              : //</span>
<span id="L839"><span class="lineNum">     839</span>              : // WARNING: This function is difficult to use correctly. See the documentation</span>
<span id="L840"><span class="lineNum">     840</span>              : // for |X509V3_get_d2i| for details.</span>
<span id="L841"><span class="lineNum">     841</span>              : OPENSSL_EXPORT void *X509_CRL_get_ext_d2i(const X509_CRL *crl, int nid,</span>
<span id="L842"><span class="lineNum">     842</span>              :                                           int *out_critical, int *out_idx);</span>
<span id="L843"><span class="lineNum">     843</span>              : </span>
<span id="L844"><span class="lineNum">     844</span>              : // X509_CRL_get0_signature sets |*out_sig| and |*out_alg| to the signature and</span>
<span id="L845"><span class="lineNum">     845</span>              : // signature algorithm of |crl|, respectively. Either output pointer may be NULL</span>
<span id="L846"><span class="lineNum">     846</span>              : // to ignore the value.</span>
<span id="L847"><span class="lineNum">     847</span>              : //</span>
<span id="L848"><span class="lineNum">     848</span>              : // This function outputs the outer signature algorithm, not the one in the</span>
<span id="L849"><span class="lineNum">     849</span>              : // TBSCertList. CRLs with mismatched signature algorithms will successfully</span>
<span id="L850"><span class="lineNum">     850</span>              : // parse, but they will be rejected when verifying.</span>
<span id="L851"><span class="lineNum">     851</span>              : OPENSSL_EXPORT void X509_CRL_get0_signature(const X509_CRL *crl,</span>
<span id="L852"><span class="lineNum">     852</span>              :                                             const ASN1_BIT_STRING **out_sig,</span>
<span id="L853"><span class="lineNum">     853</span>              :                                             const X509_ALGOR **out_alg);</span>
<span id="L854"><span class="lineNum">     854</span>              : </span>
<span id="L855"><span class="lineNum">     855</span>              : // X509_CRL_get_signature_nid returns the NID corresponding to |crl|'s signature</span>
<span id="L856"><span class="lineNum">     856</span>              : // algorithm, or |NID_undef| if the signature algorithm does not correspond to</span>
<span id="L857"><span class="lineNum">     857</span>              : // a known NID.</span>
<span id="L858"><span class="lineNum">     858</span>              : OPENSSL_EXPORT int X509_CRL_get_signature_nid(const X509_CRL *crl);</span>
<span id="L859"><span class="lineNum">     859</span>              : </span>
<span id="L860"><span class="lineNum">     860</span>              : // i2d_X509_CRL_tbs serializes the TBSCertList portion of |crl|, as described in</span>
<span id="L861"><span class="lineNum">     861</span>              : // |i2d_SAMPLE|.</span>
<span id="L862"><span class="lineNum">     862</span>              : //</span>
<span id="L863"><span class="lineNum">     863</span>              : // This function preserves the original encoding of the TBSCertList and may not</span>
<span id="L864"><span class="lineNum">     864</span>              : // reflect modifications made to |crl|. It may be used to manually verify the</span>
<span id="L865"><span class="lineNum">     865</span>              : // signature of an existing CRL. To generate CRLs, use |i2d_re_X509_CRL_tbs|</span>
<span id="L866"><span class="lineNum">     866</span>              : // instead.</span>
<span id="L867"><span class="lineNum">     867</span>              : OPENSSL_EXPORT int i2d_X509_CRL_tbs(X509_CRL *crl, unsigned char **outp);</span>
<span id="L868"><span class="lineNum">     868</span>              : </span>
<span id="L869"><span class="lineNum">     869</span>              : // X509_CRL_verify checks that |crl| has a valid signature by |pkey|. It returns</span>
<span id="L870"><span class="lineNum">     870</span>              : // one if the signature is valid and zero otherwise.</span>
<span id="L871"><span class="lineNum">     871</span>              : OPENSSL_EXPORT int X509_CRL_verify(X509_CRL *crl, EVP_PKEY *pkey);</span>
<span id="L872"><span class="lineNum">     872</span>              : </span>
<span id="L873"><span class="lineNum">     873</span>              : </span>
<span id="L874"><span class="lineNum">     874</span>              : // Issuing certificate revocation lists.</span>
<span id="L875"><span class="lineNum">     875</span>              : //</span>
<span id="L876"><span class="lineNum">     876</span>              : // An |X509_CRL| object may also represent an incomplete CRL. Callers may</span>
<span id="L877"><span class="lineNum">     877</span>              : // construct empty |X509_CRL| objects, fill in fields individually, and finally</span>
<span id="L878"><span class="lineNum">     878</span>              : // sign the result. The following functions may be used for this purpose.</span>
<span id="L879"><span class="lineNum">     879</span>              : </span>
<span id="L880"><span class="lineNum">     880</span>              : // X509_CRL_new returns a newly-allocated, empty |X509_CRL| object, or NULL on</span>
<span id="L881"><span class="lineNum">     881</span>              : // error. This object may be filled in and then signed to construct a CRL.</span>
<span id="L882"><span class="lineNum">     882</span>              : OPENSSL_EXPORT X509_CRL *X509_CRL_new(void);</span>
<span id="L883"><span class="lineNum">     883</span>              : </span>
<span id="L884"><span class="lineNum">     884</span>              : // X509_CRL_set_version sets |crl|'s version to |version|, which should be one</span>
<span id="L885"><span class="lineNum">     885</span>              : // of the |X509_CRL_VERSION_*| constants. It returns one on success and zero on</span>
<span id="L886"><span class="lineNum">     886</span>              : // error.</span>
<span id="L887"><span class="lineNum">     887</span>              : //</span>
<span id="L888"><span class="lineNum">     888</span>              : // If unsure, use |X509_CRL_VERSION_2|. Note that, unlike certificates, CRL</span>
<span id="L889"><span class="lineNum">     889</span>              : // versions are only defined up to v2. Callers should not use |X509_VERSION_3|.</span>
<span id="L890"><span class="lineNum">     890</span>              : OPENSSL_EXPORT int X509_CRL_set_version(X509_CRL *crl, long version);</span>
<span id="L891"><span class="lineNum">     891</span>              : </span>
<span id="L892"><span class="lineNum">     892</span>              : // X509_CRL_set_issuer_name sets |crl|'s issuer to a copy of |name|. It returns</span>
<span id="L893"><span class="lineNum">     893</span>              : // one on success and zero on error.</span>
<span id="L894"><span class="lineNum">     894</span>              : OPENSSL_EXPORT int X509_CRL_set_issuer_name(X509_CRL *crl, X509_NAME *name);</span>
<span id="L895"><span class="lineNum">     895</span>              : </span>
<span id="L896"><span class="lineNum">     896</span>              : // X509_CRL_set1_lastUpdate sets |crl|'s thisUpdate time to |tm|. It returns one</span>
<span id="L897"><span class="lineNum">     897</span>              : // on success and zero on error. The OpenSSL API refers to this field as</span>
<span id="L898"><span class="lineNum">     898</span>              : // lastUpdate.</span>
<span id="L899"><span class="lineNum">     899</span>              : OPENSSL_EXPORT int X509_CRL_set1_lastUpdate(X509_CRL *crl, const ASN1_TIME *tm);</span>
<span id="L900"><span class="lineNum">     900</span>              : </span>
<span id="L901"><span class="lineNum">     901</span>              : // X509_CRL_set1_nextUpdate sets |crl|'s nextUpdate time to |tm|. It returns one</span>
<span id="L902"><span class="lineNum">     902</span>              : // on success and zero on error.</span>
<span id="L903"><span class="lineNum">     903</span>              : OPENSSL_EXPORT int X509_CRL_set1_nextUpdate(X509_CRL *crl, const ASN1_TIME *tm);</span>
<span id="L904"><span class="lineNum">     904</span>              : </span>
<span id="L905"><span class="lineNum">     905</span>              : // X509_CRL_add0_revoked adds |rev| to |crl|. On success, it takes ownership of</span>
<span id="L906"><span class="lineNum">     906</span>              : // |rev| and returns one. On error, it returns zero. If this function fails, the</span>
<span id="L907"><span class="lineNum">     907</span>              : // caller retains ownership of |rev| and must release it when done.</span>
<span id="L908"><span class="lineNum">     908</span>              : OPENSSL_EXPORT int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev);</span>
<span id="L909"><span class="lineNum">     909</span>              : </span>
<span id="L910"><span class="lineNum">     910</span>              : // X509_CRL_sort sorts the entries in |crl| by serial number. It returns one on</span>
<span id="L911"><span class="lineNum">     911</span>              : // success and zero on error.</span>
<span id="L912"><span class="lineNum">     912</span>              : OPENSSL_EXPORT int X509_CRL_sort(X509_CRL *crl);</span>
<span id="L913"><span class="lineNum">     913</span>              : </span>
<span id="L914"><span class="lineNum">     914</span>              : // X509_CRL_delete_ext removes the extension in |x| at index |loc| and returns</span>
<span id="L915"><span class="lineNum">     915</span>              : // the removed extension, or NULL if |loc| was out of bounds. If non-NULL, the</span>
<span id="L916"><span class="lineNum">     916</span>              : // caller must release the result with |X509_EXTENSION_free|.</span>
<span id="L917"><span class="lineNum">     917</span>              : OPENSSL_EXPORT X509_EXTENSION *X509_CRL_delete_ext(X509_CRL *x, int loc);</span>
<span id="L918"><span class="lineNum">     918</span>              : </span>
<span id="L919"><span class="lineNum">     919</span>              : // X509_CRL_add_ext adds a copy of |ex| to |x|. It returns one on success and</span>
<span id="L920"><span class="lineNum">     920</span>              : // zero on failure. The caller retains ownership of |ex| and can release it</span>
<span id="L921"><span class="lineNum">     921</span>              : // independently of |x|.</span>
<span id="L922"><span class="lineNum">     922</span>              : //</span>
<span id="L923"><span class="lineNum">     923</span>              : // The new extension is inserted at index |loc|, shifting extensions to the</span>
<span id="L924"><span class="lineNum">     924</span>              : // right. If |loc| is -1 or out of bounds, the new extension is appended to the</span>
<span id="L925"><span class="lineNum">     925</span>              : // list.</span>
<span id="L926"><span class="lineNum">     926</span>              : OPENSSL_EXPORT int X509_CRL_add_ext(X509_CRL *x, const X509_EXTENSION *ex,</span>
<span id="L927"><span class="lineNum">     927</span>              :                                     int loc);</span>
<span id="L928"><span class="lineNum">     928</span>              : </span>
<span id="L929"><span class="lineNum">     929</span>              : // X509_CRL_add1_ext_i2d behaves like |X509V3_add1_i2d| but adds the extension</span>
<span id="L930"><span class="lineNum">     930</span>              : // to |x|'s extension list.</span>
<span id="L931"><span class="lineNum">     931</span>              : //</span>
<span id="L932"><span class="lineNum">     932</span>              : // WARNING: This function may return zero or -1 on error. The caller must also</span>
<span id="L933"><span class="lineNum">     933</span>              : // ensure |value|'s type matches |nid|. See the documentation for</span>
<span id="L934"><span class="lineNum">     934</span>              : // |X509V3_add1_i2d| for details.</span>
<span id="L935"><span class="lineNum">     935</span>              : OPENSSL_EXPORT int X509_CRL_add1_ext_i2d(X509_CRL *x, int nid, void *value,</span>
<span id="L936"><span class="lineNum">     936</span>              :                                          int crit, unsigned long flags);</span>
<span id="L937"><span class="lineNum">     937</span>              : </span>
<span id="L938"><span class="lineNum">     938</span>              : // X509_CRL_sign signs |crl| with |pkey| and replaces the signature algorithm</span>
<span id="L939"><span class="lineNum">     939</span>              : // and signature fields. It returns the length of the signature on success and</span>
<span id="L940"><span class="lineNum">     940</span>              : // zero on error. This function uses digest algorithm |md|, or |pkey|'s default</span>
<span id="L941"><span class="lineNum">     941</span>              : // if NULL. Other signing parameters use |pkey|'s defaults. To customize them,</span>
<span id="L942"><span class="lineNum">     942</span>              : // use |X509_CRL_sign_ctx|.</span>
<span id="L943"><span class="lineNum">     943</span>              : OPENSSL_EXPORT int X509_CRL_sign(X509_CRL *crl, EVP_PKEY *pkey,</span>
<span id="L944"><span class="lineNum">     944</span>              :                                  const EVP_MD *md);</span>
<span id="L945"><span class="lineNum">     945</span>              : </span>
<span id="L946"><span class="lineNum">     946</span>              : // X509_CRL_sign_ctx signs |crl| with |ctx| and replaces the signature algorithm</span>
<span id="L947"><span class="lineNum">     947</span>              : // and signature fields. It returns the length of the signature on success and</span>
<span id="L948"><span class="lineNum">     948</span>              : // zero on error. The signature algorithm and parameters come from |ctx|, which</span>
<span id="L949"><span class="lineNum">     949</span>              : // must have been initialized with |EVP_DigestSignInit|. The caller should</span>
<span id="L950"><span class="lineNum">     950</span>              : // configure the corresponding |EVP_PKEY_CTX| before calling this function.</span>
<span id="L951"><span class="lineNum">     951</span>              : //</span>
<span id="L952"><span class="lineNum">     952</span>              : // On success or failure, this function mutates |ctx| and resets it to the empty</span>
<span id="L953"><span class="lineNum">     953</span>              : // state. Caller should not rely on its contents after the function returns.</span>
<span id="L954"><span class="lineNum">     954</span>              : OPENSSL_EXPORT int X509_CRL_sign_ctx(X509_CRL *crl, EVP_MD_CTX *ctx);</span>
<span id="L955"><span class="lineNum">     955</span>              : </span>
<span id="L956"><span class="lineNum">     956</span>              : // i2d_re_X509_CRL_tbs serializes the TBSCertList portion of |crl|, as described</span>
<span id="L957"><span class="lineNum">     957</span>              : // in |i2d_SAMPLE|.</span>
<span id="L958"><span class="lineNum">     958</span>              : //</span>
<span id="L959"><span class="lineNum">     959</span>              : // This function re-encodes the TBSCertList and may not reflect |crl|'s original</span>
<span id="L960"><span class="lineNum">     960</span>              : // encoding. It may be used to manually generate a signature for a new CRL. To</span>
<span id="L961"><span class="lineNum">     961</span>              : // verify CRLs, use |i2d_X509_CRL_tbs| instead.</span>
<span id="L962"><span class="lineNum">     962</span>              : OPENSSL_EXPORT int i2d_re_X509_CRL_tbs(X509_CRL *crl, unsigned char **outp);</span>
<span id="L963"><span class="lineNum">     963</span>              : </span>
<span id="L964"><span class="lineNum">     964</span>              : // X509_CRL_set1_signature_algo sets |crl|'s signature algorithm to |algo| and</span>
<span id="L965"><span class="lineNum">     965</span>              : // returns one on success or zero on error. It updates both the signature field</span>
<span id="L966"><span class="lineNum">     966</span>              : // of the TBSCertList structure, and the signatureAlgorithm field of the CRL.</span>
<span id="L967"><span class="lineNum">     967</span>              : OPENSSL_EXPORT int X509_CRL_set1_signature_algo(X509_CRL *crl,</span>
<span id="L968"><span class="lineNum">     968</span>              :                                                 const X509_ALGOR *algo);</span>
<span id="L969"><span class="lineNum">     969</span>              : </span>
<span id="L970"><span class="lineNum">     970</span>              : // X509_CRL_set1_signature_value sets |crl|'s signature to a copy of the</span>
<span id="L971"><span class="lineNum">     971</span>              : // |sig_len| bytes pointed by |sig|. It returns one on success and zero on</span>
<span id="L972"><span class="lineNum">     972</span>              : // error.</span>
<span id="L973"><span class="lineNum">     973</span>              : //</span>
<span id="L974"><span class="lineNum">     974</span>              : // Due to a specification error, X.509 CRLs store signatures in ASN.1 BIT</span>
<span id="L975"><span class="lineNum">     975</span>              : // STRINGs, but signature algorithms return byte strings rather than bit</span>
<span id="L976"><span class="lineNum">     976</span>              : // strings. This function creates a BIT STRING containing a whole number of</span>
<span id="L977"><span class="lineNum">     977</span>              : // bytes, with the bit order matching the DER encoding. This matches the</span>
<span id="L978"><span class="lineNum">     978</span>              : // encoding used by all X.509 signature algorithms.</span>
<span id="L979"><span class="lineNum">     979</span>              : OPENSSL_EXPORT int X509_CRL_set1_signature_value(X509_CRL *crl,</span>
<span id="L980"><span class="lineNum">     980</span>              :                                                  const uint8_t *sig,</span>
<span id="L981"><span class="lineNum">     981</span>              :                                                  size_t sig_len);</span>
<span id="L982"><span class="lineNum">     982</span>              : </span>
<span id="L983"><span class="lineNum">     983</span>              : </span>
<span id="L984"><span class="lineNum">     984</span>              : // CRL entries.</span>
<span id="L985"><span class="lineNum">     985</span>              : //</span>
<span id="L986"><span class="lineNum">     986</span>              : // Each entry of a CRL is represented as an |X509_REVOKED| object, which</span>
<span id="L987"><span class="lineNum">     987</span>              : // describes a revoked certificate by serial number.</span>
<span id="L988"><span class="lineNum">     988</span>              : //</span>
<span id="L989"><span class="lineNum">     989</span>              : // When an |X509_REVOKED| is obtained from an |X509_CRL| object, it is an error</span>
<span id="L990"><span class="lineNum">     990</span>              : // to mutate the object. Doing so may break |X509_CRL|'s and cause the library</span>
<span id="L991"><span class="lineNum">     991</span>              : // to behave incorrectly.</span>
<span id="L992"><span class="lineNum">     992</span>              : </span>
<span id="L993"><span class="lineNum">     993</span>              : // X509_REVOKED_new returns a newly-allocated, empty |X509_REVOKED| object, or</span>
<span id="L994"><span class="lineNum">     994</span>              : // NULL on allocation error.</span>
<span id="L995"><span class="lineNum">     995</span>              : OPENSSL_EXPORT X509_REVOKED *X509_REVOKED_new(void);</span>
<span id="L996"><span class="lineNum">     996</span>              : </span>
<span id="L997"><span class="lineNum">     997</span>              : // X509_REVOKED_free releases memory associated with |rev|.</span>
<span id="L998"><span class="lineNum">     998</span>              : OPENSSL_EXPORT void X509_REVOKED_free(X509_REVOKED *rev);</span>
<span id="L999"><span class="lineNum">     999</span>              : </span>
<span id="L1000"><span class="lineNum">    1000</span>              : // d2i_X509_REVOKED parses up to |len| bytes from |*inp| as a DER-encoded X.509</span>
<span id="L1001"><span class="lineNum">    1001</span>              : // CRL entry, as described in |d2i_SAMPLE|.</span>
<span id="L1002"><span class="lineNum">    1002</span>              : OPENSSL_EXPORT X509_REVOKED *d2i_X509_REVOKED(X509_REVOKED **out,</span>
<span id="L1003"><span class="lineNum">    1003</span>              :                                               const uint8_t **inp, long len);</span>
<span id="L1004"><span class="lineNum">    1004</span>              : </span>
<span id="L1005"><span class="lineNum">    1005</span>              : // i2d_X509_REVOKED marshals |alg| as a DER-encoded X.509 CRL entry, as</span>
<span id="L1006"><span class="lineNum">    1006</span>              : // described in |i2d_SAMPLE|.</span>
<span id="L1007"><span class="lineNum">    1007</span>              : OPENSSL_EXPORT int i2d_X509_REVOKED(const X509_REVOKED *alg, uint8_t **outp);</span>
<span id="L1008"><span class="lineNum">    1008</span>              : </span>
<span id="L1009"><span class="lineNum">    1009</span>              : // X509_REVOKED_dup returns a newly-allocated copy of |rev|, or NULL on error.</span>
<span id="L1010"><span class="lineNum">    1010</span>              : // This function works by serializing the structure, so if |rev| is incomplete,</span>
<span id="L1011"><span class="lineNum">    1011</span>              : // it may fail.</span>
<span id="L1012"><span class="lineNum">    1012</span>              : OPENSSL_EXPORT X509_REVOKED *X509_REVOKED_dup(const X509_REVOKED *rev);</span>
<span id="L1013"><span class="lineNum">    1013</span>              : </span>
<span id="L1014"><span class="lineNum">    1014</span>              : // X509_REVOKED_get0_serialNumber returns the serial number of the certificate</span>
<span id="L1015"><span class="lineNum">    1015</span>              : // revoked by |revoked|.</span>
<span id="L1016"><span class="lineNum">    1016</span>              : OPENSSL_EXPORT const ASN1_INTEGER *X509_REVOKED_get0_serialNumber(</span>
<span id="L1017"><span class="lineNum">    1017</span>              :     const X509_REVOKED *revoked);</span>
<span id="L1018"><span class="lineNum">    1018</span>              : </span>
<span id="L1019"><span class="lineNum">    1019</span>              : // X509_REVOKED_set_serialNumber sets |revoked|'s serial number to |serial|. It</span>
<span id="L1020"><span class="lineNum">    1020</span>              : // returns one on success or zero on error.</span>
<span id="L1021"><span class="lineNum">    1021</span>              : OPENSSL_EXPORT int X509_REVOKED_set_serialNumber(X509_REVOKED *revoked,</span>
<span id="L1022"><span class="lineNum">    1022</span>              :                                                  const ASN1_INTEGER *serial);</span>
<span id="L1023"><span class="lineNum">    1023</span>              : </span>
<span id="L1024"><span class="lineNum">    1024</span>              : // X509_REVOKED_get0_revocationDate returns the revocation time of the</span>
<span id="L1025"><span class="lineNum">    1025</span>              : // certificate revoked by |revoked|.</span>
<span id="L1026"><span class="lineNum">    1026</span>              : OPENSSL_EXPORT const ASN1_TIME *X509_REVOKED_get0_revocationDate(</span>
<span id="L1027"><span class="lineNum">    1027</span>              :     const X509_REVOKED *revoked);</span>
<span id="L1028"><span class="lineNum">    1028</span>              : </span>
<span id="L1029"><span class="lineNum">    1029</span>              : // X509_REVOKED_set_revocationDate sets |revoked|'s revocation time to |tm|. It</span>
<span id="L1030"><span class="lineNum">    1030</span>              : // returns one on success or zero on error.</span>
<span id="L1031"><span class="lineNum">    1031</span>              : OPENSSL_EXPORT int X509_REVOKED_set_revocationDate(X509_REVOKED *revoked,</span>
<span id="L1032"><span class="lineNum">    1032</span>              :                                                    const ASN1_TIME *tm);</span>
<span id="L1033"><span class="lineNum">    1033</span>              : </span>
<span id="L1034"><span class="lineNum">    1034</span>              : // X509_REVOKED_get0_extensions returns |r|'s extensions list, or NULL if |r|</span>
<span id="L1035"><span class="lineNum">    1035</span>              : // omits it. A CRL can have extensions on individual entries, which is this</span>
<span id="L1036"><span class="lineNum">    1036</span>              : // function, or on the overall CRL, which is |X509_CRL_get0_extensions|.</span>
<span id="L1037"><span class="lineNum">    1037</span>              : OPENSSL_EXPORT const STACK_OF(X509_EXTENSION) *X509_REVOKED_get0_extensions(</span>
<span id="L1038"><span class="lineNum">    1038</span>              :     const X509_REVOKED *r);</span>
<span id="L1039"><span class="lineNum">    1039</span>              : </span>
<span id="L1040"><span class="lineNum">    1040</span>              :     // X509_REVOKED_get_ext_count returns the number of extensions in |x|.</span>
<span id="L1041"><span class="lineNum">    1041</span>              : OPENSSL_EXPORT int X509_REVOKED_get_ext_count(const X509_REVOKED *x);</span>
<span id="L1042"><span class="lineNum">    1042</span>              : </span>
<span id="L1043"><span class="lineNum">    1043</span>              : // X509_REVOKED_get_ext_by_NID behaves like |X509v3_get_ext_by_NID| but searches</span>
<span id="L1044"><span class="lineNum">    1044</span>              : // for extensions in |x|.</span>
<span id="L1045"><span class="lineNum">    1045</span>              : OPENSSL_EXPORT int X509_REVOKED_get_ext_by_NID(const X509_REVOKED *x, int nid,</span>
<span id="L1046"><span class="lineNum">    1046</span>              :                                                int lastpos);</span>
<span id="L1047"><span class="lineNum">    1047</span>              : </span>
<span id="L1048"><span class="lineNum">    1048</span>              : // X509_REVOKED_get_ext_by_OBJ behaves like |X509v3_get_ext_by_OBJ| but searches</span>
<span id="L1049"><span class="lineNum">    1049</span>              : // for extensions in |x|.</span>
<span id="L1050"><span class="lineNum">    1050</span>              : OPENSSL_EXPORT int X509_REVOKED_get_ext_by_OBJ(const X509_REVOKED *x,</span>
<span id="L1051"><span class="lineNum">    1051</span>              :                                                const ASN1_OBJECT *obj,</span>
<span id="L1052"><span class="lineNum">    1052</span>              :                                                int lastpos);</span>
<span id="L1053"><span class="lineNum">    1053</span>              : </span>
<span id="L1054"><span class="lineNum">    1054</span>              : // X509_REVOKED_get_ext_by_critical behaves like |X509v3_get_ext_by_critical|</span>
<span id="L1055"><span class="lineNum">    1055</span>              : // but searches for extensions in |x|.</span>
<span id="L1056"><span class="lineNum">    1056</span>              : OPENSSL_EXPORT int X509_REVOKED_get_ext_by_critical(const X509_REVOKED *x,</span>
<span id="L1057"><span class="lineNum">    1057</span>              :                                                     int crit, int lastpos);</span>
<span id="L1058"><span class="lineNum">    1058</span>              : </span>
<span id="L1059"><span class="lineNum">    1059</span>              : // X509_REVOKED_get_ext returns the extension in |x| at index |loc|, or NULL if</span>
<span id="L1060"><span class="lineNum">    1060</span>              : // |loc| is out of bounds. This function returns a non-const pointer for OpenSSL</span>
<span id="L1061"><span class="lineNum">    1061</span>              : // compatibility, but callers should not mutate the result.</span>
<span id="L1062"><span class="lineNum">    1062</span>              : OPENSSL_EXPORT X509_EXTENSION *X509_REVOKED_get_ext(const X509_REVOKED *x,</span>
<span id="L1063"><span class="lineNum">    1063</span>              :                                                     int loc);</span>
<span id="L1064"><span class="lineNum">    1064</span>              : </span>
<span id="L1065"><span class="lineNum">    1065</span>              : // X509_REVOKED_delete_ext removes the extension in |x| at index |loc| and</span>
<span id="L1066"><span class="lineNum">    1066</span>              : // returns the removed extension, or NULL if |loc| was out of bounds. If</span>
<span id="L1067"><span class="lineNum">    1067</span>              : // non-NULL, the caller must release the result with |X509_EXTENSION_free|.</span>
<span id="L1068"><span class="lineNum">    1068</span>              : OPENSSL_EXPORT X509_EXTENSION *X509_REVOKED_delete_ext(X509_REVOKED *x,</span>
<span id="L1069"><span class="lineNum">    1069</span>              :                                                        int loc);</span>
<span id="L1070"><span class="lineNum">    1070</span>              : </span>
<span id="L1071"><span class="lineNum">    1071</span>              : // X509_REVOKED_add_ext adds a copy of |ex| to |x|. It returns one on success</span>
<span id="L1072"><span class="lineNum">    1072</span>              : // and zero on failure. The caller retains ownership of |ex| and can release it</span>
<span id="L1073"><span class="lineNum">    1073</span>              : // independently of |x|.</span>
<span id="L1074"><span class="lineNum">    1074</span>              : //</span>
<span id="L1075"><span class="lineNum">    1075</span>              : // The new extension is inserted at index |loc|, shifting extensions to the</span>
<span id="L1076"><span class="lineNum">    1076</span>              : // right. If |loc| is -1 or out of bounds, the new extension is appended to the</span>
<span id="L1077"><span class="lineNum">    1077</span>              : // list.</span>
<span id="L1078"><span class="lineNum">    1078</span>              : OPENSSL_EXPORT int X509_REVOKED_add_ext(X509_REVOKED *x,</span>
<span id="L1079"><span class="lineNum">    1079</span>              :                                         const X509_EXTENSION *ex, int loc);</span>
<span id="L1080"><span class="lineNum">    1080</span>              : </span>
<span id="L1081"><span class="lineNum">    1081</span>              : // X509_REVOKED_get_ext_d2i behaves like |X509V3_get_d2i| but looks for the</span>
<span id="L1082"><span class="lineNum">    1082</span>              : // extension in |revoked|'s extension list.</span>
<span id="L1083"><span class="lineNum">    1083</span>              : //</span>
<span id="L1084"><span class="lineNum">    1084</span>              : // WARNING: This function is difficult to use correctly. See the documentation</span>
<span id="L1085"><span class="lineNum">    1085</span>              : // for |X509V3_get_d2i| for details.</span>
<span id="L1086"><span class="lineNum">    1086</span>              : OPENSSL_EXPORT void *X509_REVOKED_get_ext_d2i(const X509_REVOKED *revoked,</span>
<span id="L1087"><span class="lineNum">    1087</span>              :                                               int nid, int *out_critical,</span>
<span id="L1088"><span class="lineNum">    1088</span>              :                                               int *out_idx);</span>
<span id="L1089"><span class="lineNum">    1089</span>              : </span>
<span id="L1090"><span class="lineNum">    1090</span>              : // X509_REVOKED_add1_ext_i2d behaves like |X509V3_add1_i2d| but adds the</span>
<span id="L1091"><span class="lineNum">    1091</span>              : // extension to |x|'s extension list.</span>
<span id="L1092"><span class="lineNum">    1092</span>              : //</span>
<span id="L1093"><span class="lineNum">    1093</span>              : // WARNING: This function may return zero or -1 on error. The caller must also</span>
<span id="L1094"><span class="lineNum">    1094</span>              : // ensure |value|'s type matches |nid|. See the documentation for</span>
<span id="L1095"><span class="lineNum">    1095</span>              : // |X509V3_add1_i2d| for details.</span>
<span id="L1096"><span class="lineNum">    1096</span>              : OPENSSL_EXPORT int X509_REVOKED_add1_ext_i2d(X509_REVOKED *x, int nid,</span>
<span id="L1097"><span class="lineNum">    1097</span>              :                                              void *value, int crit,</span>
<span id="L1098"><span class="lineNum">    1098</span>              :                                              unsigned long flags);</span>
<span id="L1099"><span class="lineNum">    1099</span>              : </span>
<span id="L1100"><span class="lineNum">    1100</span>              : </span>
<span id="L1101"><span class="lineNum">    1101</span>              : // Certificate requests.</span>
<span id="L1102"><span class="lineNum">    1102</span>              : //</span>
<span id="L1103"><span class="lineNum">    1103</span>              : // An |X509_REQ| represents a PKCS #10 certificate request (RFC 2986). These are</span>
<span id="L1104"><span class="lineNum">    1104</span>              : // also referred to as certificate signing requests or CSRs. CSRs are a common</span>
<span id="L1105"><span class="lineNum">    1105</span>              : // format used to request a certificate from a CA.</span>
<span id="L1106"><span class="lineNum">    1106</span>              : //</span>
<span id="L1107"><span class="lineNum">    1107</span>              : // Although an |X509_REQ| is a mutable object, mutating an |X509_REQ| can give</span>
<span id="L1108"><span class="lineNum">    1108</span>              : // incorrect results. Callers typically obtain |X509_REQ|s by parsing some input</span>
<span id="L1109"><span class="lineNum">    1109</span>              : // with |d2i_X509_REQ|, etc. Such objects carry information such as the</span>
<span id="L1110"><span class="lineNum">    1110</span>              : // serialized CertificationRequestInfo, which will become inconsistent when</span>
<span id="L1111"><span class="lineNum">    1111</span>              : // mutated.</span>
<span id="L1112"><span class="lineNum">    1112</span>              : //</span>
<span id="L1113"><span class="lineNum">    1113</span>              : // Instead, mutation functions should only be used when issuing new CRLs, as</span>
<span id="L1114"><span class="lineNum">    1114</span>              : // described in a later section.</span>
<span id="L1115"><span class="lineNum">    1115</span>              : </span>
<span id="L1116"><span class="lineNum">    1116</span>              : // X509_REQ_dup returns a newly-allocated copy of |req|, or NULL on error. This</span>
<span id="L1117"><span class="lineNum">    1117</span>              : // function works by serializing the structure, so if |req| is incomplete, it</span>
<span id="L1118"><span class="lineNum">    1118</span>              : // may fail.</span>
<span id="L1119"><span class="lineNum">    1119</span>              : //</span>
<span id="L1120"><span class="lineNum">    1120</span>              : // TODO(https://crbug.com/boringssl/407): This function should be const and</span>
<span id="L1121"><span class="lineNum">    1121</span>              : // thread-safe but is currently neither in some cases, notably if |req| was</span>
<span id="L1122"><span class="lineNum">    1122</span>              : // mutated.</span>
<span id="L1123"><span class="lineNum">    1123</span>              : OPENSSL_EXPORT X509_REQ *X509_REQ_dup(X509_REQ *req);</span>
<span id="L1124"><span class="lineNum">    1124</span>              : </span>
<span id="L1125"><span class="lineNum">    1125</span>              : // X509_REQ_free releases memory associated with |req|.</span>
<span id="L1126"><span class="lineNum">    1126</span>              : OPENSSL_EXPORT void X509_REQ_free(X509_REQ *req);</span>
<span id="L1127"><span class="lineNum">    1127</span>              : </span>
<span id="L1128"><span class="lineNum">    1128</span>              : // d2i_X509_REQ parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L1129"><span class="lineNum">    1129</span>              : // CertificateRequest (RFC 2986), as described in |d2i_SAMPLE|.</span>
<span id="L1130"><span class="lineNum">    1130</span>              : OPENSSL_EXPORT X509_REQ *d2i_X509_REQ(X509_REQ **out, const uint8_t **inp,</span>
<span id="L1131"><span class="lineNum">    1131</span>              :                                       long len);</span>
<span id="L1132"><span class="lineNum">    1132</span>              : </span>
<span id="L1133"><span class="lineNum">    1133</span>              : // i2d_X509_REQ marshals |req| as a CertificateRequest (RFC 2986), as described</span>
<span id="L1134"><span class="lineNum">    1134</span>              : // in |i2d_SAMPLE|.</span>
<span id="L1135"><span class="lineNum">    1135</span>              : //</span>
<span id="L1136"><span class="lineNum">    1136</span>              : // TODO(https://crbug.com/boringssl/407): This function should be const and</span>
<span id="L1137"><span class="lineNum">    1137</span>              : // thread-safe but is currently neither in some cases, notably if |req| was</span>
<span id="L1138"><span class="lineNum">    1138</span>              : // mutated.</span>
<span id="L1139"><span class="lineNum">    1139</span>              : OPENSSL_EXPORT int i2d_X509_REQ(X509_REQ *req, uint8_t **outp);</span>
<span id="L1140"><span class="lineNum">    1140</span>              : </span>
<span id="L1141"><span class="lineNum">    1141</span>              : // X509_REQ_VERSION_1 is the version constant for |X509_REQ| objects. No other</span>
<span id="L1142"><span class="lineNum">    1142</span>              : // versions are defined.</span>
<span id="L1143"><span class="lineNum">    1143</span>              : #define X509_REQ_VERSION_1 0</span>
<span id="L1144"><span class="lineNum">    1144</span>              : </span>
<span id="L1145"><span class="lineNum">    1145</span>              : // X509_REQ_get_version returns the numerical value of |req|'s version. This</span>
<span id="L1146"><span class="lineNum">    1146</span>              : // will always be |X509_REQ_VERSION_1| for valid CSRs. For compatibility,</span>
<span id="L1147"><span class="lineNum">    1147</span>              : // |d2i_X509_REQ| also accepts some invalid version numbers, in which case this</span>
<span id="L1148"><span class="lineNum">    1148</span>              : // function may return other values.</span>
<span id="L1149"><span class="lineNum">    1149</span>              : OPENSSL_EXPORT long X509_REQ_get_version(const X509_REQ *req);</span>
<span id="L1150"><span class="lineNum">    1150</span>              : </span>
<span id="L1151"><span class="lineNum">    1151</span>              : // X509_REQ_get_subject_name returns |req|'s subject name. Note this function is</span>
<span id="L1152"><span class="lineNum">    1152</span>              : // not const-correct for legacy reasons.</span>
<span id="L1153"><span class="lineNum">    1153</span>              : OPENSSL_EXPORT X509_NAME *X509_REQ_get_subject_name(const X509_REQ *req);</span>
<span id="L1154"><span class="lineNum">    1154</span>              : </span>
<span id="L1155"><span class="lineNum">    1155</span>              : // X509_REQ_get0_pubkey returns |req|'s public key as an |EVP_PKEY|, or NULL if</span>
<span id="L1156"><span class="lineNum">    1156</span>              : // the public key was unsupported or could not be decoded. The |EVP_PKEY| is</span>
<span id="L1157"><span class="lineNum">    1157</span>              : // cached in |req|, so callers must not mutate the result.</span>
<span id="L1158"><span class="lineNum">    1158</span>              : OPENSSL_EXPORT EVP_PKEY *X509_REQ_get0_pubkey(const X509_REQ *req);</span>
<span id="L1159"><span class="lineNum">    1159</span>              : </span>
<span id="L1160"><span class="lineNum">    1160</span>              : // X509_REQ_get_pubkey behaves like |X509_REQ_get0_pubkey| but increments the</span>
<span id="L1161"><span class="lineNum">    1161</span>              : // reference count on the |EVP_PKEY|. The caller must release the result with</span>
<span id="L1162"><span class="lineNum">    1162</span>              : // |EVP_PKEY_free| when done. The |EVP_PKEY| is cached in |req|, so callers must</span>
<span id="L1163"><span class="lineNum">    1163</span>              : // not mutate the result.</span>
<span id="L1164"><span class="lineNum">    1164</span>              : OPENSSL_EXPORT EVP_PKEY *X509_REQ_get_pubkey(const X509_REQ *req);</span>
<span id="L1165"><span class="lineNum">    1165</span>              : </span>
<span id="L1166"><span class="lineNum">    1166</span>              : // X509_REQ_check_private_key returns one if |req|'s public key matches |pkey|</span>
<span id="L1167"><span class="lineNum">    1167</span>              : // and zero otherwise.</span>
<span id="L1168"><span class="lineNum">    1168</span>              : OPENSSL_EXPORT int X509_REQ_check_private_key(const X509_REQ *req,</span>
<span id="L1169"><span class="lineNum">    1169</span>              :                                               const EVP_PKEY *pkey);</span>
<span id="L1170"><span class="lineNum">    1170</span>              : </span>
<span id="L1171"><span class="lineNum">    1171</span>              : // X509_REQ_get_attr_count returns the number of attributes in |req|.</span>
<span id="L1172"><span class="lineNum">    1172</span>              : OPENSSL_EXPORT int X509_REQ_get_attr_count(const X509_REQ *req);</span>
<span id="L1173"><span class="lineNum">    1173</span>              : </span>
<span id="L1174"><span class="lineNum">    1174</span>              : // X509_REQ_get_attr returns the attribute at index |loc| in |req|, or NULL if</span>
<span id="L1175"><span class="lineNum">    1175</span>              : // out of bounds.</span>
<span id="L1176"><span class="lineNum">    1176</span>              : OPENSSL_EXPORT X509_ATTRIBUTE *X509_REQ_get_attr(const X509_REQ *req, int loc);</span>
<span id="L1177"><span class="lineNum">    1177</span>              : </span>
<span id="L1178"><span class="lineNum">    1178</span>              : // X509_REQ_get_attr_by_NID returns the index of the attribute in |req| of type</span>
<span id="L1179"><span class="lineNum">    1179</span>              : // |nid|, or a negative number if not found. If found, callers can use</span>
<span id="L1180"><span class="lineNum">    1180</span>              : // |X509_REQ_get_attr| to look up the attribute by index.</span>
<span id="L1181"><span class="lineNum">    1181</span>              : //</span>
<span id="L1182"><span class="lineNum">    1182</span>              : // If |lastpos| is non-negative, it begins searching at |lastpos| + 1. Callers</span>
<span id="L1183"><span class="lineNum">    1183</span>              : // can thus loop over all matching attributes by first passing -1 and then</span>
<span id="L1184"><span class="lineNum">    1184</span>              : // passing the previously-returned value until no match is returned.</span>
<span id="L1185"><span class="lineNum">    1185</span>              : OPENSSL_EXPORT int X509_REQ_get_attr_by_NID(const X509_REQ *req, int nid,</span>
<span id="L1186"><span class="lineNum">    1186</span>              :                                             int lastpos);</span>
<span id="L1187"><span class="lineNum">    1187</span>              : </span>
<span id="L1188"><span class="lineNum">    1188</span>              : // X509_REQ_get_attr_by_OBJ behaves like |X509_REQ_get_attr_by_NID| but looks</span>
<span id="L1189"><span class="lineNum">    1189</span>              : // for attributes of type |obj|.</span>
<span id="L1190"><span class="lineNum">    1190</span>              : OPENSSL_EXPORT int X509_REQ_get_attr_by_OBJ(const X509_REQ *req,</span>
<span id="L1191"><span class="lineNum">    1191</span>              :                                             const ASN1_OBJECT *obj,</span>
<span id="L1192"><span class="lineNum">    1192</span>              :                                             int lastpos);</span>
<span id="L1193"><span class="lineNum">    1193</span>              : </span>
<span id="L1194"><span class="lineNum">    1194</span>              : // X509_REQ_extension_nid returns one if |nid| is a supported CSR attribute type</span>
<span id="L1195"><span class="lineNum">    1195</span>              : // for carrying extensions and zero otherwise. The supported types are</span>
<span id="L1196"><span class="lineNum">    1196</span>              : // |NID_ext_req| (pkcs-9-at-extensionRequest from RFC 2985) and |NID_ms_ext_req|</span>
<span id="L1197"><span class="lineNum">    1197</span>              : // (a Microsoft szOID_CERT_EXTENSIONS variant).</span>
<span id="L1198"><span class="lineNum">    1198</span>              : OPENSSL_EXPORT int X509_REQ_extension_nid(int nid);</span>
<span id="L1199"><span class="lineNum">    1199</span>              : </span>
<span id="L1200"><span class="lineNum">    1200</span>              : // X509_REQ_get_extensions decodes the most preferred list of requested</span>
<span id="L1201"><span class="lineNum">    1201</span>              : // extensions in |req| and returns a newly-allocated |STACK_OF(X509_EXTENSION)|</span>
<span id="L1202"><span class="lineNum">    1202</span>              : // containing the result. It returns NULL on error, or if |req| did not request</span>
<span id="L1203"><span class="lineNum">    1203</span>              : // extensions.</span>
<span id="L1204"><span class="lineNum">    1204</span>              : //</span>
<span id="L1205"><span class="lineNum">    1205</span>              : // CSRs do not store extensions directly. Instead there are attribute types</span>
<span id="L1206"><span class="lineNum">    1206</span>              : // which are defined to hold extensions. See |X509_REQ_extension_nid|. This</span>
<span id="L1207"><span class="lineNum">    1207</span>              : // function supports both pkcs-9-at-extensionRequest from RFC 2985 and the</span>
<span id="L1208"><span class="lineNum">    1208</span>              : // Microsoft szOID_CERT_EXTENSIONS variant. If both are present,</span>
<span id="L1209"><span class="lineNum">    1209</span>              : // pkcs-9-at-extensionRequest is preferred.</span>
<span id="L1210"><span class="lineNum">    1210</span>              : OPENSSL_EXPORT STACK_OF(X509_EXTENSION) *X509_REQ_get_extensions(</span>
<span id="L1211"><span class="lineNum">    1211</span>              :     const X509_REQ *req);</span>
<span id="L1212"><span class="lineNum">    1212</span>              : </span>
<span id="L1213"><span class="lineNum">    1213</span>              : // X509_REQ_get0_signature sets |*out_sig| and |*out_alg| to the signature and</span>
<span id="L1214"><span class="lineNum">    1214</span>              : // signature algorithm of |req|, respectively. Either output pointer may be NULL</span>
<span id="L1215"><span class="lineNum">    1215</span>              : // to ignore the value.</span>
<span id="L1216"><span class="lineNum">    1216</span>              : OPENSSL_EXPORT void X509_REQ_get0_signature(const X509_REQ *req,</span>
<span id="L1217"><span class="lineNum">    1217</span>              :                                             const ASN1_BIT_STRING **out_sig,</span>
<span id="L1218"><span class="lineNum">    1218</span>              :                                             const X509_ALGOR **out_alg);</span>
<span id="L1219"><span class="lineNum">    1219</span>              : </span>
<span id="L1220"><span class="lineNum">    1220</span>              : // X509_REQ_get_signature_nid returns the NID corresponding to |req|'s signature</span>
<span id="L1221"><span class="lineNum">    1221</span>              : // algorithm, or |NID_undef| if the signature algorithm does not correspond to</span>
<span id="L1222"><span class="lineNum">    1222</span>              : // a known NID.</span>
<span id="L1223"><span class="lineNum">    1223</span>              : OPENSSL_EXPORT int X509_REQ_get_signature_nid(const X509_REQ *req);</span>
<span id="L1224"><span class="lineNum">    1224</span>              : </span>
<span id="L1225"><span class="lineNum">    1225</span>              : // X509_REQ_verify checks that |req| has a valid signature by |pkey|. It returns</span>
<span id="L1226"><span class="lineNum">    1226</span>              : // one if the signature is valid and zero otherwise.</span>
<span id="L1227"><span class="lineNum">    1227</span>              : OPENSSL_EXPORT int X509_REQ_verify(X509_REQ *req, EVP_PKEY *pkey);</span>
<span id="L1228"><span class="lineNum">    1228</span>              : </span>
<span id="L1229"><span class="lineNum">    1229</span>              : // X509_REQ_get1_email returns a newly-allocated list of NUL-terminated strings</span>
<span id="L1230"><span class="lineNum">    1230</span>              : // containing all email addresses in |req|'s subject and all rfc822name names</span>
<span id="L1231"><span class="lineNum">    1231</span>              : // in |req|'s subject alternative names. The subject alternative names extension</span>
<span id="L1232"><span class="lineNum">    1232</span>              : // is extracted from the result of |X509_REQ_get_extensions|. Email addresses</span>
<span id="L1233"><span class="lineNum">    1233</span>              : // which contain embedded NUL bytes are skipped.</span>
<span id="L1234"><span class="lineNum">    1234</span>              : //</span>
<span id="L1235"><span class="lineNum">    1235</span>              : // On error, or if there are no such email addresses, it returns NULL. When</span>
<span id="L1236"><span class="lineNum">    1236</span>              : // done, the caller must release the result with |X509_email_free|.</span>
<span id="L1237"><span class="lineNum">    1237</span>              : OPENSSL_EXPORT STACK_OF(OPENSSL_STRING) *X509_REQ_get1_email(</span>
<span id="L1238"><span class="lineNum">    1238</span>              :     const X509_REQ *req);</span>
<span id="L1239"><span class="lineNum">    1239</span>              : </span>
<span id="L1240"><span class="lineNum">    1240</span>              : </span>
<span id="L1241"><span class="lineNum">    1241</span>              : // Issuing certificate requests.</span>
<span id="L1242"><span class="lineNum">    1242</span>              : //</span>
<span id="L1243"><span class="lineNum">    1243</span>              : // An |X509_REQ| object may also represent an incomplete CSR. Callers may</span>
<span id="L1244"><span class="lineNum">    1244</span>              : // construct empty |X509_REQ| objects, fill in fields individually, and finally</span>
<span id="L1245"><span class="lineNum">    1245</span>              : // sign the result. The following functions may be used for this purpose.</span>
<span id="L1246"><span class="lineNum">    1246</span>              : </span>
<span id="L1247"><span class="lineNum">    1247</span>              : // X509_REQ_new returns a newly-allocated, empty |X509_REQ| object, or NULL on</span>
<span id="L1248"><span class="lineNum">    1248</span>              : // error. This object may be filled in and then signed to construct a CSR.</span>
<span id="L1249"><span class="lineNum">    1249</span>              : OPENSSL_EXPORT X509_REQ *X509_REQ_new(void);</span>
<span id="L1250"><span class="lineNum">    1250</span>              : </span>
<span id="L1251"><span class="lineNum">    1251</span>              : // X509_REQ_set_version sets |req|'s version to |version|, which should be</span>
<span id="L1252"><span class="lineNum">    1252</span>              : // |X509_REQ_VERSION_1|. It returns one on success and zero on error.</span>
<span id="L1253"><span class="lineNum">    1253</span>              : //</span>
<span id="L1254"><span class="lineNum">    1254</span>              : // The only defined CSR version is |X509_REQ_VERSION_1|, so there is no need to</span>
<span id="L1255"><span class="lineNum">    1255</span>              : // call this function.</span>
<span id="L1256"><span class="lineNum">    1256</span>              : OPENSSL_EXPORT int X509_REQ_set_version(X509_REQ *req, long version);</span>
<span id="L1257"><span class="lineNum">    1257</span>              : </span>
<span id="L1258"><span class="lineNum">    1258</span>              : // X509_REQ_set_subject_name sets |req|'s subject to a copy of |name|. It</span>
<span id="L1259"><span class="lineNum">    1259</span>              : // returns one on success and zero on error.</span>
<span id="L1260"><span class="lineNum">    1260</span>              : OPENSSL_EXPORT int X509_REQ_set_subject_name(X509_REQ *req, X509_NAME *name);</span>
<span id="L1261"><span class="lineNum">    1261</span>              : </span>
<span id="L1262"><span class="lineNum">    1262</span>              : // X509_REQ_set_pubkey sets |req|'s public key to |pkey|. It returns one on</span>
<span id="L1263"><span class="lineNum">    1263</span>              : // success and zero on error. This function does not take ownership of |pkey|</span>
<span id="L1264"><span class="lineNum">    1264</span>              : // and internally copies and updates reference counts as needed.</span>
<span id="L1265"><span class="lineNum">    1265</span>              : OPENSSL_EXPORT int X509_REQ_set_pubkey(X509_REQ *req, EVP_PKEY *pkey);</span>
<span id="L1266"><span class="lineNum">    1266</span>              : </span>
<span id="L1267"><span class="lineNum">    1267</span>              : // X509_REQ_delete_attr removes the attribute at index |loc| in |req|. It</span>
<span id="L1268"><span class="lineNum">    1268</span>              : // returns the removed attribute to the caller, or NULL if |loc| was out of</span>
<span id="L1269"><span class="lineNum">    1269</span>              : // bounds. If non-NULL, the caller must release the result with</span>
<span id="L1270"><span class="lineNum">    1270</span>              : // |X509_ATTRIBUTE_free| when done. It is also safe, but not necessary, to call</span>
<span id="L1271"><span class="lineNum">    1271</span>              : // |X509_ATTRIBUTE_free| if the result is NULL.</span>
<span id="L1272"><span class="lineNum">    1272</span>              : OPENSSL_EXPORT X509_ATTRIBUTE *X509_REQ_delete_attr(X509_REQ *req, int loc);</span>
<span id="L1273"><span class="lineNum">    1273</span>              : </span>
<span id="L1274"><span class="lineNum">    1274</span>              : // X509_REQ_add1_attr appends a copy of |attr| to |req|'s list of attributes. It</span>
<span id="L1275"><span class="lineNum">    1275</span>              : // returns one on success and zero on error.</span>
<span id="L1276"><span class="lineNum">    1276</span>              : OPENSSL_EXPORT int X509_REQ_add1_attr(X509_REQ *req,</span>
<span id="L1277"><span class="lineNum">    1277</span>              :                                       const X509_ATTRIBUTE *attr);</span>
<span id="L1278"><span class="lineNum">    1278</span>              : </span>
<span id="L1279"><span class="lineNum">    1279</span>              : // X509_REQ_add1_attr_by_OBJ appends a new attribute to |req| with type |obj|.</span>
<span id="L1280"><span class="lineNum">    1280</span>              : // It returns one on success and zero on error. The value is determined by</span>
<span id="L1281"><span class="lineNum">    1281</span>              : // |X509_ATTRIBUTE_set1_data|.</span>
<span id="L1282"><span class="lineNum">    1282</span>              : //</span>
<span id="L1283"><span class="lineNum">    1283</span>              : // WARNING: The interpretation of |attrtype|, |data|, and |len| is complex and</span>
<span id="L1284"><span class="lineNum">    1284</span>              : // error-prone. See |X509_ATTRIBUTE_set1_data| for details.</span>
<span id="L1285"><span class="lineNum">    1285</span>              : OPENSSL_EXPORT int X509_REQ_add1_attr_by_OBJ(X509_REQ *req,</span>
<span id="L1286"><span class="lineNum">    1286</span>              :                                              const ASN1_OBJECT *obj,</span>
<span id="L1287"><span class="lineNum">    1287</span>              :                                              int attrtype,</span>
<span id="L1288"><span class="lineNum">    1288</span>              :                                              const unsigned char *data,</span>
<span id="L1289"><span class="lineNum">    1289</span>              :                                              int len);</span>
<span id="L1290"><span class="lineNum">    1290</span>              : </span>
<span id="L1291"><span class="lineNum">    1291</span>              : // X509_REQ_add1_attr_by_NID behaves like |X509_REQ_add1_attr_by_OBJ| except the</span>
<span id="L1292"><span class="lineNum">    1292</span>              : // attribute type is determined by |nid|.</span>
<span id="L1293"><span class="lineNum">    1293</span>              : OPENSSL_EXPORT int X509_REQ_add1_attr_by_NID(X509_REQ *req, int nid,</span>
<span id="L1294"><span class="lineNum">    1294</span>              :                                              int attrtype,</span>
<span id="L1295"><span class="lineNum">    1295</span>              :                                              const unsigned char *data,</span>
<span id="L1296"><span class="lineNum">    1296</span>              :                                              int len);</span>
<span id="L1297"><span class="lineNum">    1297</span>              : </span>
<span id="L1298"><span class="lineNum">    1298</span>              : // X509_REQ_add1_attr_by_txt behaves like |X509_REQ_add1_attr_by_OBJ| except the</span>
<span id="L1299"><span class="lineNum">    1299</span>              : // attribute type is determined by calling |OBJ_txt2obj| with |attrname|.</span>
<span id="L1300"><span class="lineNum">    1300</span>              : OPENSSL_EXPORT int X509_REQ_add1_attr_by_txt(X509_REQ *req,</span>
<span id="L1301"><span class="lineNum">    1301</span>              :                                              const char *attrname, int attrtype,</span>
<span id="L1302"><span class="lineNum">    1302</span>              :                                              const unsigned char *data,</span>
<span id="L1303"><span class="lineNum">    1303</span>              :                                              int len);</span>
<span id="L1304"><span class="lineNum">    1304</span>              : </span>
<span id="L1305"><span class="lineNum">    1305</span>              : // X509_REQ_add_extensions_nid adds an attribute to |req| of type |nid|, to</span>
<span id="L1306"><span class="lineNum">    1306</span>              : // request the certificate extensions in |exts|. It returns one on success and</span>
<span id="L1307"><span class="lineNum">    1307</span>              : // zero on error. |nid| should be |NID_ext_req| or |NID_ms_ext_req|.</span>
<span id="L1308"><span class="lineNum">    1308</span>              : OPENSSL_EXPORT int X509_REQ_add_extensions_nid(</span>
<span id="L1309"><span class="lineNum">    1309</span>              :     X509_REQ *req, const STACK_OF(X509_EXTENSION) *exts, int nid);</span>
<span id="L1310"><span class="lineNum">    1310</span>              : </span>
<span id="L1311"><span class="lineNum">    1311</span>              : // X509_REQ_add_extensions behaves like |X509_REQ_add_extensions_nid|, using the</span>
<span id="L1312"><span class="lineNum">    1312</span>              : // standard |NID_ext_req| for the attribute type.</span>
<span id="L1313"><span class="lineNum">    1313</span>              : OPENSSL_EXPORT int X509_REQ_add_extensions(</span>
<span id="L1314"><span class="lineNum">    1314</span>              :     X509_REQ *req, const STACK_OF(X509_EXTENSION) *exts);</span>
<span id="L1315"><span class="lineNum">    1315</span>              : </span>
<span id="L1316"><span class="lineNum">    1316</span>              : // X509_REQ_sign signs |req| with |pkey| and replaces the signature algorithm</span>
<span id="L1317"><span class="lineNum">    1317</span>              : // and signature fields. It returns the length of the signature on success and</span>
<span id="L1318"><span class="lineNum">    1318</span>              : // zero on error. This function uses digest algorithm |md|, or |pkey|'s default</span>
<span id="L1319"><span class="lineNum">    1319</span>              : // if NULL. Other signing parameters use |pkey|'s defaults. To customize them,</span>
<span id="L1320"><span class="lineNum">    1320</span>              : // use |X509_REQ_sign_ctx|.</span>
<span id="L1321"><span class="lineNum">    1321</span>              : OPENSSL_EXPORT int X509_REQ_sign(X509_REQ *req, EVP_PKEY *pkey,</span>
<span id="L1322"><span class="lineNum">    1322</span>              :                                  const EVP_MD *md);</span>
<span id="L1323"><span class="lineNum">    1323</span>              : </span>
<span id="L1324"><span class="lineNum">    1324</span>              : // X509_REQ_sign_ctx signs |req| with |ctx| and replaces the signature algorithm</span>
<span id="L1325"><span class="lineNum">    1325</span>              : // and signature fields. It returns the length of the signature on success and</span>
<span id="L1326"><span class="lineNum">    1326</span>              : // zero on error. The signature algorithm and parameters come from |ctx|, which</span>
<span id="L1327"><span class="lineNum">    1327</span>              : // must have been initialized with |EVP_DigestSignInit|. The caller should</span>
<span id="L1328"><span class="lineNum">    1328</span>              : // configure the corresponding |EVP_PKEY_CTX| before calling this function.</span>
<span id="L1329"><span class="lineNum">    1329</span>              : //</span>
<span id="L1330"><span class="lineNum">    1330</span>              : // On success or failure, this function mutates |ctx| and resets it to the empty</span>
<span id="L1331"><span class="lineNum">    1331</span>              : // state. Caller should not rely on its contents after the function returns.</span>
<span id="L1332"><span class="lineNum">    1332</span>              : OPENSSL_EXPORT int X509_REQ_sign_ctx(X509_REQ *req, EVP_MD_CTX *ctx);</span>
<span id="L1333"><span class="lineNum">    1333</span>              : </span>
<span id="L1334"><span class="lineNum">    1334</span>              : // i2d_re_X509_REQ_tbs serializes the CertificationRequestInfo (see RFC 2986)</span>
<span id="L1335"><span class="lineNum">    1335</span>              : // portion of |req|, as described in |i2d_SAMPLE|.</span>
<span id="L1336"><span class="lineNum">    1336</span>              : //</span>
<span id="L1337"><span class="lineNum">    1337</span>              : // This function re-encodes the CertificationRequestInfo and may not reflect</span>
<span id="L1338"><span class="lineNum">    1338</span>              : // |req|'s original encoding. It may be used to manually generate a signature</span>
<span id="L1339"><span class="lineNum">    1339</span>              : // for a new certificate request.</span>
<span id="L1340"><span class="lineNum">    1340</span>              : OPENSSL_EXPORT int i2d_re_X509_REQ_tbs(X509_REQ *req, uint8_t **outp);</span>
<span id="L1341"><span class="lineNum">    1341</span>              : </span>
<span id="L1342"><span class="lineNum">    1342</span>              : // X509_REQ_set1_signature_algo sets |req|'s signature algorithm to |algo| and</span>
<span id="L1343"><span class="lineNum">    1343</span>              : // returns one on success or zero on error.</span>
<span id="L1344"><span class="lineNum">    1344</span>              : OPENSSL_EXPORT int X509_REQ_set1_signature_algo(X509_REQ *req,</span>
<span id="L1345"><span class="lineNum">    1345</span>              :                                                 const X509_ALGOR *algo);</span>
<span id="L1346"><span class="lineNum">    1346</span>              : </span>
<span id="L1347"><span class="lineNum">    1347</span>              : // X509_REQ_set1_signature_value sets |req|'s signature to a copy of the</span>
<span id="L1348"><span class="lineNum">    1348</span>              : // |sig_len| bytes pointed by |sig|. It returns one on success and zero on</span>
<span id="L1349"><span class="lineNum">    1349</span>              : // error.</span>
<span id="L1350"><span class="lineNum">    1350</span>              : //</span>
<span id="L1351"><span class="lineNum">    1351</span>              : // Due to a specification error, PKCS#10 certificate requests store signatures</span>
<span id="L1352"><span class="lineNum">    1352</span>              : // in ASN.1 BIT STRINGs, but signature algorithms return byte strings rather</span>
<span id="L1353"><span class="lineNum">    1353</span>              : // than bit strings. This function creates a BIT STRING containing a whole</span>
<span id="L1354"><span class="lineNum">    1354</span>              : // number of bytes, with the bit order matching the DER encoding. This matches</span>
<span id="L1355"><span class="lineNum">    1355</span>              : // the encoding used by all X.509 signature algorithms.</span>
<span id="L1356"><span class="lineNum">    1356</span>              : OPENSSL_EXPORT int X509_REQ_set1_signature_value(X509_REQ *req,</span>
<span id="L1357"><span class="lineNum">    1357</span>              :                                                  const uint8_t *sig,</span>
<span id="L1358"><span class="lineNum">    1358</span>              :                                                  size_t sig_len);</span>
<span id="L1359"><span class="lineNum">    1359</span>              : </span>
<span id="L1360"><span class="lineNum">    1360</span>              : </span>
<span id="L1361"><span class="lineNum">    1361</span>              : // Names.</span>
<span id="L1362"><span class="lineNum">    1362</span>              : //</span>
<span id="L1363"><span class="lineNum">    1363</span>              : // An |X509_NAME| represents an X.509 Name structure (RFC 5280). X.509 names are</span>
<span id="L1364"><span class="lineNum">    1364</span>              : // a complex, hierarchical structure over a collection of attributes. Each name</span>
<span id="L1365"><span class="lineNum">    1365</span>              : // is sequence of relative distinguished names (RDNs), decreasing in</span>
<span id="L1366"><span class="lineNum">    1366</span>              : // specificity. For example, the first RDN may specify the country, while the</span>
<span id="L1367"><span class="lineNum">    1367</span>              : // next RDN may specify a locality. Each RDN is, itself, a set of attributes.</span>
<span id="L1368"><span class="lineNum">    1368</span>              : // Having more than one attribute in an RDN is uncommon, but possible. Within an</span>
<span id="L1369"><span class="lineNum">    1369</span>              : // RDN, attributes have the same level in specificity. Attribute types are</span>
<span id="L1370"><span class="lineNum">    1370</span>              : // OBJECT IDENTIFIERs. This determines the ASN.1 type of the value, which is</span>
<span id="L1371"><span class="lineNum">    1371</span>              : // commonly a string but may be other types.</span>
<span id="L1372"><span class="lineNum">    1372</span>              : //</span>
<span id="L1373"><span class="lineNum">    1373</span>              : // The |X509_NAME| representation flattens this two-level structure into a</span>
<span id="L1374"><span class="lineNum">    1374</span>              : // single list of attributes. Each attribute is stored in an |X509_NAME_ENTRY|,</span>
<span id="L1375"><span class="lineNum">    1375</span>              : // with also maintains the index of the RDN it is part of, accessible via</span>
<span id="L1376"><span class="lineNum">    1376</span>              : // |X509_NAME_ENTRY_set|. This can be used to recover the two-level structure.</span>
<span id="L1377"><span class="lineNum">    1377</span>              : //</span>
<span id="L1378"><span class="lineNum">    1378</span>              : // X.509 names are largely vestigial. Historically, DNS names were parsed out of</span>
<span id="L1379"><span class="lineNum">    1379</span>              : // the subject's common name attribute, but this is deprecated and has since</span>
<span id="L1380"><span class="lineNum">    1380</span>              : // moved to the subject alternative name extension. In modern usage, X.509 names</span>
<span id="L1381"><span class="lineNum">    1381</span>              : // are primarily opaque identifiers to link a certificate with its issuer.</span>
<span id="L1382"><span class="lineNum">    1382</span>              : </span>
<span id="L1383"><span class="lineNum">    1383</span>              : DEFINE_STACK_OF(X509_NAME_ENTRY)</span>
<span id="L1384"><span class="lineNum">    1384</span>              : DEFINE_STACK_OF(X509_NAME)</span>
<span id="L1385"><span class="lineNum">    1385</span>              : </span>
<span id="L1386"><span class="lineNum">    1386</span>              : // X509_NAME is an |ASN1_ITEM| whose ASN.1 type is X.509 Name (RFC 5280) and C</span>
<span id="L1387"><span class="lineNum">    1387</span>              : // type is |X509_NAME*|.</span>
<span id="L1388"><span class="lineNum">    1388</span>              : DECLARE_ASN1_ITEM(X509_NAME)</span>
<span id="L1389"><span class="lineNum">    1389</span>              : </span>
<span id="L1390"><span class="lineNum">    1390</span>              : // X509_NAME_new returns a new, empty |X509_NAME|, or NULL on error.</span>
<span id="L1391"><span class="lineNum">    1391</span>              : OPENSSL_EXPORT X509_NAME *X509_NAME_new(void);</span>
<span id="L1392"><span class="lineNum">    1392</span>              : </span>
<span id="L1393"><span class="lineNum">    1393</span>              : // X509_NAME_free releases memory associated with |name|.</span>
<span id="L1394"><span class="lineNum">    1394</span>              : OPENSSL_EXPORT void X509_NAME_free(X509_NAME *name);</span>
<span id="L1395"><span class="lineNum">    1395</span>              : </span>
<span id="L1396"><span class="lineNum">    1396</span>              : // d2i_X509_NAME parses up to |len| bytes from |*inp| as a DER-encoded X.509</span>
<span id="L1397"><span class="lineNum">    1397</span>              : // Name (RFC 5280), as described in |d2i_SAMPLE|.</span>
<span id="L1398"><span class="lineNum">    1398</span>              : OPENSSL_EXPORT X509_NAME *d2i_X509_NAME(X509_NAME **out, const uint8_t **inp,</span>
<span id="L1399"><span class="lineNum">    1399</span>              :                                         long len);</span>
<span id="L1400"><span class="lineNum">    1400</span>              : </span>
<span id="L1401"><span class="lineNum">    1401</span>              : // i2d_X509_NAME marshals |in| as a DER-encoded X.509 Name (RFC 5280), as</span>
<span id="L1402"><span class="lineNum">    1402</span>              : // described in |i2d_SAMPLE|.</span>
<span id="L1403"><span class="lineNum">    1403</span>              : //</span>
<span id="L1404"><span class="lineNum">    1404</span>              : // TODO(https://crbug.com/boringssl/407): This function should be const and</span>
<span id="L1405"><span class="lineNum">    1405</span>              : // thread-safe but is currently neither in some cases, notably if |in| was</span>
<span id="L1406"><span class="lineNum">    1406</span>              : // mutated.</span>
<span id="L1407"><span class="lineNum">    1407</span>              : OPENSSL_EXPORT int i2d_X509_NAME(X509_NAME *in, uint8_t **outp);</span>
<span id="L1408"><span class="lineNum">    1408</span>              : </span>
<span id="L1409"><span class="lineNum">    1409</span>              : // X509_NAME_dup returns a newly-allocated copy of |name|, or NULL on error.</span>
<span id="L1410"><span class="lineNum">    1410</span>              : //</span>
<span id="L1411"><span class="lineNum">    1411</span>              : // TODO(https://crbug.com/boringssl/407): This function should be const and</span>
<span id="L1412"><span class="lineNum">    1412</span>              : // thread-safe but is currently neither in some cases, notably if |name| was</span>
<span id="L1413"><span class="lineNum">    1413</span>              : // mutated.</span>
<span id="L1414"><span class="lineNum">    1414</span>              : OPENSSL_EXPORT X509_NAME *X509_NAME_dup(X509_NAME *name);</span>
<span id="L1415"><span class="lineNum">    1415</span>              : </span>
<span id="L1416"><span class="lineNum">    1416</span>              : // X509_NAME_cmp compares |a| and |b|'s canonicalized forms. It returns zero if</span>
<span id="L1417"><span class="lineNum">    1417</span>              : // they are equal, one if |a| sorts after |b|, -1 if |b| sorts after |a|, and -2</span>
<span id="L1418"><span class="lineNum">    1418</span>              : // on error.</span>
<span id="L1419"><span class="lineNum">    1419</span>              : //</span>
<span id="L1420"><span class="lineNum">    1420</span>              : // TODO(https://crbug.com/boringssl/407): This function is const, but it is not</span>
<span id="L1421"><span class="lineNum">    1421</span>              : // always thread-safe, notably if |name| was mutated.</span>
<span id="L1422"><span class="lineNum">    1422</span>              : //</span>
<span id="L1423"><span class="lineNum">    1423</span>              : // TODO(https://crbug.com/boringssl/355): The -2 return is very inconvenient to</span>
<span id="L1424"><span class="lineNum">    1424</span>              : // pass to a sorting function. Can we make this infallible? In the meantime,</span>
<span id="L1425"><span class="lineNum">    1425</span>              : // prefer to use this function only for equality checks rather than comparisons.</span>
<span id="L1426"><span class="lineNum">    1426</span>              : // Although even the library itself passes this to a sorting function.</span>
<span id="L1427"><span class="lineNum">    1427</span>              : OPENSSL_EXPORT int X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b);</span>
<span id="L1428"><span class="lineNum">    1428</span>              : </span>
<span id="L1429"><span class="lineNum">    1429</span>              : // X509_NAME_get0_der marshals |name| as a DER-encoded X.509 Name (RFC 5280). On</span>
<span id="L1430"><span class="lineNum">    1430</span>              : // success, it returns one and sets |*out_der| and |*out_der_len| to a buffer</span>
<span id="L1431"><span class="lineNum">    1431</span>              : // containing the result. Otherwise, it returns zero. |*out_der| is owned by</span>
<span id="L1432"><span class="lineNum">    1432</span>              : // |name| and must not be freed by the caller. It is invalidated after |name| is</span>
<span id="L1433"><span class="lineNum">    1433</span>              : // mutated or freed.</span>
<span id="L1434"><span class="lineNum">    1434</span>              : //</span>
<span id="L1435"><span class="lineNum">    1435</span>              : // Avoid this function and prefer |i2d_X509_NAME|. It is one of the reasons</span>
<span id="L1436"><span class="lineNum">    1436</span>              : // |X509_NAME| functions, including this one, are not consistently thread-safe</span>
<span id="L1437"><span class="lineNum">    1437</span>              : // or const-correct. Depending on the resolution of</span>
<span id="L1438"><span class="lineNum">    1438</span>              : // https://crbug.com/boringssl/407, this function may be removed or cause poor</span>
<span id="L1439"><span class="lineNum">    1439</span>              : // performance.</span>
<span id="L1440"><span class="lineNum">    1440</span>              : OPENSSL_EXPORT int X509_NAME_get0_der(X509_NAME *name, const uint8_t **out_der,</span>
<span id="L1441"><span class="lineNum">    1441</span>              :                                       size_t *out_der_len);</span>
<span id="L1442"><span class="lineNum">    1442</span>              : </span>
<span id="L1443"><span class="lineNum">    1443</span>              : // X509_NAME_set makes a copy of |name|. On success, it frees |*xn|, sets |*xn|</span>
<span id="L1444"><span class="lineNum">    1444</span>              : // to the copy, and returns one. Otherwise, it returns zero.</span>
<span id="L1445"><span class="lineNum">    1445</span>              : //</span>
<span id="L1446"><span class="lineNum">    1446</span>              : // TODO(https://crbug.com/boringssl/407): This function should be const and</span>
<span id="L1447"><span class="lineNum">    1447</span>              : // thread-safe but is currently neither in some cases, notably if |name| was</span>
<span id="L1448"><span class="lineNum">    1448</span>              : // mutated.</span>
<span id="L1449"><span class="lineNum">    1449</span>              : OPENSSL_EXPORT int X509_NAME_set(X509_NAME **xn, X509_NAME *name);</span>
<span id="L1450"><span class="lineNum">    1450</span>              : </span>
<span id="L1451"><span class="lineNum">    1451</span>              : // X509_NAME_entry_count returns the number of entries in |name|.</span>
<span id="L1452"><span class="lineNum">    1452</span>              : OPENSSL_EXPORT int X509_NAME_entry_count(const X509_NAME *name);</span>
<span id="L1453"><span class="lineNum">    1453</span>              : </span>
<span id="L1454"><span class="lineNum">    1454</span>              : // X509_NAME_get_index_by_NID returns the zero-based index of the first</span>
<span id="L1455"><span class="lineNum">    1455</span>              : // attribute in |name| with type |nid|, or -1 if there is none. |nid| should be</span>
<span id="L1456"><span class="lineNum">    1456</span>              : // one of the |NID_*| constants. If |lastpos| is non-negative, it begins</span>
<span id="L1457"><span class="lineNum">    1457</span>              : // searching at |lastpos+1|. To search all attributes, pass in -1, not zero.</span>
<span id="L1458"><span class="lineNum">    1458</span>              : //</span>
<span id="L1459"><span class="lineNum">    1459</span>              : // Indices from this function refer to |X509_NAME|'s flattened representation.</span>
<span id="L1460"><span class="lineNum">    1460</span>              : OPENSSL_EXPORT int X509_NAME_get_index_by_NID(const X509_NAME *name, int nid,</span>
<span id="L1461"><span class="lineNum">    1461</span>              :                                               int lastpos);</span>
<span id="L1462"><span class="lineNum">    1462</span>              : </span>
<span id="L1463"><span class="lineNum">    1463</span>              : // X509_NAME_get_index_by_OBJ behaves like |X509_NAME_get_index_by_NID| but</span>
<span id="L1464"><span class="lineNum">    1464</span>              : // looks for attributes with type |obj|.</span>
<span id="L1465"><span class="lineNum">    1465</span>              : OPENSSL_EXPORT int X509_NAME_get_index_by_OBJ(const X509_NAME *name,</span>
<span id="L1466"><span class="lineNum">    1466</span>              :                                               const ASN1_OBJECT *obj,</span>
<span id="L1467"><span class="lineNum">    1467</span>              :                                               int lastpos);</span>
<span id="L1468"><span class="lineNum">    1468</span>              : </span>
<span id="L1469"><span class="lineNum">    1469</span>              : // X509_NAME_get_entry returns the attribute in |name| at index |loc|, or NULL</span>
<span id="L1470"><span class="lineNum">    1470</span>              : // if |loc| is out of range. |loc| is interpreted using |X509_NAME|'s flattened</span>
<span id="L1471"><span class="lineNum">    1471</span>              : // representation. This function returns a non-const pointer for OpenSSL</span>
<span id="L1472"><span class="lineNum">    1472</span>              : // compatibility, but callers should not mutate the result. Doing so will break</span>
<span id="L1473"><span class="lineNum">    1473</span>              : // internal invariants in the library.</span>
<span id="L1474"><span class="lineNum">    1474</span>              : OPENSSL_EXPORT X509_NAME_ENTRY *X509_NAME_get_entry(const X509_NAME *name,</span>
<span id="L1475"><span class="lineNum">    1475</span>              :                                                     int loc);</span>
<span id="L1476"><span class="lineNum">    1476</span>              : </span>
<span id="L1477"><span class="lineNum">    1477</span>              : // X509_NAME_delete_entry removes and returns the attribute in |name| at index</span>
<span id="L1478"><span class="lineNum">    1478</span>              : // |loc|, or NULL if |loc| is out of range. |loc| is interpreted using</span>
<span id="L1479"><span class="lineNum">    1479</span>              : // |X509_NAME|'s flattened representation. If the attribute is found, the caller</span>
<span id="L1480"><span class="lineNum">    1480</span>              : // is responsible for releasing the result with |X509_NAME_ENTRY_free|.</span>
<span id="L1481"><span class="lineNum">    1481</span>              : //</span>
<span id="L1482"><span class="lineNum">    1482</span>              : // This function will internally update RDN indices (see |X509_NAME_ENTRY_set|)</span>
<span id="L1483"><span class="lineNum">    1483</span>              : // so they continue to be consecutive.</span>
<span id="L1484"><span class="lineNum">    1484</span>              : OPENSSL_EXPORT X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name,</span>
<span id="L1485"><span class="lineNum">    1485</span>              :                                                        int loc);</span>
<span id="L1486"><span class="lineNum">    1486</span>              : </span>
<span id="L1487"><span class="lineNum">    1487</span>              : // X509_NAME_add_entry adds a copy of |entry| to |name| and returns one on</span>
<span id="L1488"><span class="lineNum">    1488</span>              : // success or zero on error. If |loc| is -1, the entry is appended to |name|.</span>
<span id="L1489"><span class="lineNum">    1489</span>              : // Otherwise, it is inserted at index |loc|. If |set| is -1, the entry is added</span>
<span id="L1490"><span class="lineNum">    1490</span>              : // to the previous entry's RDN. If it is 0, the entry becomes a singleton RDN.</span>
<span id="L1491"><span class="lineNum">    1491</span>              : // If 1, it is added to next entry's RDN.</span>
<span id="L1492"><span class="lineNum">    1492</span>              : //</span>
<span id="L1493"><span class="lineNum">    1493</span>              : // This function will internally update RDN indices (see |X509_NAME_ENTRY_set|)</span>
<span id="L1494"><span class="lineNum">    1494</span>              : // so they continue to be consecutive.</span>
<span id="L1495"><span class="lineNum">    1495</span>              : OPENSSL_EXPORT int X509_NAME_add_entry(X509_NAME *name,</span>
<span id="L1496"><span class="lineNum">    1496</span>              :                                        const X509_NAME_ENTRY *entry, int loc,</span>
<span id="L1497"><span class="lineNum">    1497</span>              :                                        int set);</span>
<span id="L1498"><span class="lineNum">    1498</span>              : </span>
<span id="L1499"><span class="lineNum">    1499</span>              : // X509_NAME_add_entry_by_OBJ adds a new entry to |name| and returns one on</span>
<span id="L1500"><span class="lineNum">    1500</span>              : // success or zero on error. The entry's attribute type is |obj|. The entry's</span>
<span id="L1501"><span class="lineNum">    1501</span>              : // attribute value is determined by |type|, |bytes|, and |len|, as in</span>
<span id="L1502"><span class="lineNum">    1502</span>              : // |X509_NAME_ENTRY_set_data|. The entry's position is determined by |loc| and</span>
<span id="L1503"><span class="lineNum">    1503</span>              : // |set| as in |X509_NAME_add_entry|.</span>
<span id="L1504"><span class="lineNum">    1504</span>              : OPENSSL_EXPORT int X509_NAME_add_entry_by_OBJ(X509_NAME *name,</span>
<span id="L1505"><span class="lineNum">    1505</span>              :                                               const ASN1_OBJECT *obj, int type,</span>
<span id="L1506"><span class="lineNum">    1506</span>              :                                               const uint8_t *bytes,</span>
<span id="L1507"><span class="lineNum">    1507</span>              :                                               ossl_ssize_t len, int loc,</span>
<span id="L1508"><span class="lineNum">    1508</span>              :                                               int set);</span>
<span id="L1509"><span class="lineNum">    1509</span>              : </span>
<span id="L1510"><span class="lineNum">    1510</span>              : // X509_NAME_add_entry_by_NID behaves like |X509_NAME_add_entry_by_OBJ| but sets</span>
<span id="L1511"><span class="lineNum">    1511</span>              : // the entry's attribute type to |nid|, which should be one of the |NID_*|</span>
<span id="L1512"><span class="lineNum">    1512</span>              : // constants.</span>
<span id="L1513"><span class="lineNum">    1513</span>              : OPENSSL_EXPORT int X509_NAME_add_entry_by_NID(X509_NAME *name, int nid,</span>
<span id="L1514"><span class="lineNum">    1514</span>              :                                               int type, const uint8_t *bytes,</span>
<span id="L1515"><span class="lineNum">    1515</span>              :                                               ossl_ssize_t len, int loc,</span>
<span id="L1516"><span class="lineNum">    1516</span>              :                                               int set);</span>
<span id="L1517"><span class="lineNum">    1517</span>              : </span>
<span id="L1518"><span class="lineNum">    1518</span>              : // X509_NAME_add_entry_by_txt behaves like |X509_NAME_add_entry_by_OBJ| but sets</span>
<span id="L1519"><span class="lineNum">    1519</span>              : // the entry's attribute type to |field|, which is passed to |OBJ_txt2obj|.</span>
<span id="L1520"><span class="lineNum">    1520</span>              : OPENSSL_EXPORT int X509_NAME_add_entry_by_txt(X509_NAME *name,</span>
<span id="L1521"><span class="lineNum">    1521</span>              :                                               const char *field, int type,</span>
<span id="L1522"><span class="lineNum">    1522</span>              :                                               const uint8_t *bytes,</span>
<span id="L1523"><span class="lineNum">    1523</span>              :                                               ossl_ssize_t len, int loc,</span>
<span id="L1524"><span class="lineNum">    1524</span>              :                                               int set);</span>
<span id="L1525"><span class="lineNum">    1525</span>              : </span>
<span id="L1526"><span class="lineNum">    1526</span>              : // X509_NAME_ENTRY_new returns a new, empty |X509_NAME_ENTRY|, or NULL on error.</span>
<span id="L1527"><span class="lineNum">    1527</span>              : OPENSSL_EXPORT X509_NAME_ENTRY *X509_NAME_ENTRY_new(void);</span>
<span id="L1528"><span class="lineNum">    1528</span>              : </span>
<span id="L1529"><span class="lineNum">    1529</span>              : // X509_NAME_ENTRY_free releases memory associated with |entry|.</span>
<span id="L1530"><span class="lineNum">    1530</span>              : OPENSSL_EXPORT void X509_NAME_ENTRY_free(X509_NAME_ENTRY *entry);</span>
<span id="L1531"><span class="lineNum">    1531</span>              : </span>
<span id="L1532"><span class="lineNum">    1532</span>              : // X509_NAME_ENTRY_dup returns a newly-allocated copy of |entry|, or NULL on</span>
<span id="L1533"><span class="lineNum">    1533</span>              : // error.</span>
<span id="L1534"><span class="lineNum">    1534</span>              : OPENSSL_EXPORT X509_NAME_ENTRY *X509_NAME_ENTRY_dup(</span>
<span id="L1535"><span class="lineNum">    1535</span>              :     const X509_NAME_ENTRY *entry);</span>
<span id="L1536"><span class="lineNum">    1536</span>              : </span>
<span id="L1537"><span class="lineNum">    1537</span>              : // X509_NAME_ENTRY_get_object returns |entry|'s attribute type. This function</span>
<span id="L1538"><span class="lineNum">    1538</span>              : // returns a non-const pointer for OpenSSL compatibility, but callers should not</span>
<span id="L1539"><span class="lineNum">    1539</span>              : // mutate the result. Doing so will break internal invariants in the library.</span>
<span id="L1540"><span class="lineNum">    1540</span>              : OPENSSL_EXPORT ASN1_OBJECT *X509_NAME_ENTRY_get_object(</span>
<span id="L1541"><span class="lineNum">    1541</span>              :     const X509_NAME_ENTRY *entry);</span>
<span id="L1542"><span class="lineNum">    1542</span>              : </span>
<span id="L1543"><span class="lineNum">    1543</span>              : // X509_NAME_ENTRY_set_object sets |entry|'s attribute type to |obj|. It returns</span>
<span id="L1544"><span class="lineNum">    1544</span>              : // one on success and zero on error.</span>
<span id="L1545"><span class="lineNum">    1545</span>              : OPENSSL_EXPORT int X509_NAME_ENTRY_set_object(X509_NAME_ENTRY *entry,</span>
<span id="L1546"><span class="lineNum">    1546</span>              :                                               const ASN1_OBJECT *obj);</span>
<span id="L1547"><span class="lineNum">    1547</span>              : </span>
<span id="L1548"><span class="lineNum">    1548</span>              : // X509_NAME_ENTRY_get_data returns |entry|'s attribute value, represented as an</span>
<span id="L1549"><span class="lineNum">    1549</span>              : // |ASN1_STRING|. This value may have any ASN.1 type, so callers must check the</span>
<span id="L1550"><span class="lineNum">    1550</span>              : // type before interpreting the contents. This function returns a non-const</span>
<span id="L1551"><span class="lineNum">    1551</span>              : // pointer for OpenSSL compatibility, but callers should not mutate the result.</span>
<span id="L1552"><span class="lineNum">    1552</span>              : // Doing so will break internal invariants in the library.</span>
<span id="L1553"><span class="lineNum">    1553</span>              : //</span>
<span id="L1554"><span class="lineNum">    1554</span>              : // TODO(https://crbug.com/boringssl/412): Although the spec says any ASN.1 type</span>
<span id="L1555"><span class="lineNum">    1555</span>              : // is allowed, we currently only allow an ad-hoc set of types. Additionally, it</span>
<span id="L1556"><span class="lineNum">    1556</span>              : // is unclear if some types can even be represented by this function.</span>
<span id="L1557"><span class="lineNum">    1557</span>              : OPENSSL_EXPORT ASN1_STRING *X509_NAME_ENTRY_get_data(</span>
<span id="L1558"><span class="lineNum">    1558</span>              :     const X509_NAME_ENTRY *entry);</span>
<span id="L1559"><span class="lineNum">    1559</span>              : </span>
<span id="L1560"><span class="lineNum">    1560</span>              : // X509_NAME_ENTRY_set_data sets |entry|'s value to |len| bytes from |bytes|. It</span>
<span id="L1561"><span class="lineNum">    1561</span>              : // returns one on success and zero on error. If |len| is -1, |bytes| must be a</span>
<span id="L1562"><span class="lineNum">    1562</span>              : // NUL-terminated C string and the length is determined by |strlen|. |bytes| is</span>
<span id="L1563"><span class="lineNum">    1563</span>              : // converted to an ASN.1 type as follows:</span>
<span id="L1564"><span class="lineNum">    1564</span>              : //</span>
<span id="L1565"><span class="lineNum">    1565</span>              : // If |type| is a |MBSTRING_*| constant, the value is an ASN.1 string. The</span>
<span id="L1566"><span class="lineNum">    1566</span>              : // string is determined by decoding |bytes| in the encoding specified by |type|,</span>
<span id="L1567"><span class="lineNum">    1567</span>              : // and then re-encoding it in a form appropriate for |entry|'s attribute type.</span>
<span id="L1568"><span class="lineNum">    1568</span>              : // See |ASN1_STRING_set_by_NID| for details.</span>
<span id="L1569"><span class="lineNum">    1569</span>              : //</span>
<span id="L1570"><span class="lineNum">    1570</span>              : // Otherwise, the value is an |ASN1_STRING| with type |type| and value |bytes|.</span>
<span id="L1571"><span class="lineNum">    1571</span>              : // See |ASN1_STRING| for how to format ASN.1 types as an |ASN1_STRING|. If</span>
<span id="L1572"><span class="lineNum">    1572</span>              : // |type| is |V_ASN1_UNDEF| the previous |ASN1_STRING| type is reused.</span>
<span id="L1573"><span class="lineNum">    1573</span>              : OPENSSL_EXPORT int X509_NAME_ENTRY_set_data(X509_NAME_ENTRY *entry, int type,</span>
<span id="L1574"><span class="lineNum">    1574</span>              :                                             const uint8_t *bytes,</span>
<span id="L1575"><span class="lineNum">    1575</span>              :                                             ossl_ssize_t len);</span>
<span id="L1576"><span class="lineNum">    1576</span>              : </span>
<span id="L1577"><span class="lineNum">    1577</span>              : // X509_NAME_ENTRY_set returns the zero-based index of the RDN which contains</span>
<span id="L1578"><span class="lineNum">    1578</span>              : // |entry|. Consecutive entries with the same index are part of the same RDN.</span>
<span id="L1579"><span class="lineNum">    1579</span>              : OPENSSL_EXPORT int X509_NAME_ENTRY_set(const X509_NAME_ENTRY *entry);</span>
<span id="L1580"><span class="lineNum">    1580</span>              : </span>
<span id="L1581"><span class="lineNum">    1581</span>              : // X509_NAME_ENTRY_create_by_OBJ creates a new |X509_NAME_ENTRY| with attribute</span>
<span id="L1582"><span class="lineNum">    1582</span>              : // type |obj|. The attribute value is determined from |type|, |bytes|, and |len|</span>
<span id="L1583"><span class="lineNum">    1583</span>              : // as in |X509_NAME_ENTRY_set_data|. It returns the |X509_NAME_ENTRY| on success</span>
<span id="L1584"><span class="lineNum">    1584</span>              : // and NULL on error.</span>
<span id="L1585"><span class="lineNum">    1585</span>              : //</span>
<span id="L1586"><span class="lineNum">    1586</span>              : // If |out| is non-NULL and |*out| is NULL, it additionally sets |*out| to the</span>
<span id="L1587"><span class="lineNum">    1587</span>              : // result on success. If both |out| and |*out| are non-NULL, it updates the</span>
<span id="L1588"><span class="lineNum">    1588</span>              : // object at |*out| instead of allocating a new one.</span>
<span id="L1589"><span class="lineNum">    1589</span>              : OPENSSL_EXPORT X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_OBJ(</span>
<span id="L1590"><span class="lineNum">    1590</span>              :     X509_NAME_ENTRY **out, const ASN1_OBJECT *obj, int type,</span>
<span id="L1591"><span class="lineNum">    1591</span>              :     const uint8_t *bytes, ossl_ssize_t len);</span>
<span id="L1592"><span class="lineNum">    1592</span>              : </span>
<span id="L1593"><span class="lineNum">    1593</span>              : // X509_NAME_ENTRY_create_by_NID behaves like |X509_NAME_ENTRY_create_by_OBJ|</span>
<span id="L1594"><span class="lineNum">    1594</span>              : // except the attribute type is |nid|, which should be one of the |NID_*|</span>
<span id="L1595"><span class="lineNum">    1595</span>              : // constants.</span>
<span id="L1596"><span class="lineNum">    1596</span>              : OPENSSL_EXPORT X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_NID(</span>
<span id="L1597"><span class="lineNum">    1597</span>              :     X509_NAME_ENTRY **out, int nid, int type, const uint8_t *bytes,</span>
<span id="L1598"><span class="lineNum">    1598</span>              :     ossl_ssize_t len);</span>
<span id="L1599"><span class="lineNum">    1599</span>              : </span>
<span id="L1600"><span class="lineNum">    1600</span>              : // X509_NAME_ENTRY_create_by_txt behaves like |X509_NAME_ENTRY_create_by_OBJ|</span>
<span id="L1601"><span class="lineNum">    1601</span>              : // except the attribute type is |field|, which is passed to |OBJ_txt2obj|.</span>
<span id="L1602"><span class="lineNum">    1602</span>              : OPENSSL_EXPORT X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_txt(</span>
<span id="L1603"><span class="lineNum">    1603</span>              :     X509_NAME_ENTRY **out, const char *field, int type, const uint8_t *bytes,</span>
<span id="L1604"><span class="lineNum">    1604</span>              :     ossl_ssize_t len);</span>
<span id="L1605"><span class="lineNum">    1605</span>              : </span>
<span id="L1606"><span class="lineNum">    1606</span>              : </span>
<span id="L1607"><span class="lineNum">    1607</span>              : // Public keys.</span>
<span id="L1608"><span class="lineNum">    1608</span>              : //</span>
<span id="L1609"><span class="lineNum">    1609</span>              : // X.509 encodes public keys as SubjectPublicKeyInfo (RFC 5280), sometimes</span>
<span id="L1610"><span class="lineNum">    1610</span>              : // referred to as SPKI. These are represented in this library by |X509_PUBKEY|.</span>
<span id="L1611"><span class="lineNum">    1611</span>              : </span>
<span id="L1612"><span class="lineNum">    1612</span>              : // X509_PUBKEY_new returns a newly-allocated, empty |X509_PUBKEY| object, or</span>
<span id="L1613"><span class="lineNum">    1613</span>              : // NULL on error.</span>
<span id="L1614"><span class="lineNum">    1614</span>              : OPENSSL_EXPORT X509_PUBKEY *X509_PUBKEY_new(void);</span>
<span id="L1615"><span class="lineNum">    1615</span>              : </span>
<span id="L1616"><span class="lineNum">    1616</span>              : // X509_PUBKEY_free releases memory associated with |key|.</span>
<span id="L1617"><span class="lineNum">    1617</span>              : OPENSSL_EXPORT void X509_PUBKEY_free(X509_PUBKEY *key);</span>
<span id="L1618"><span class="lineNum">    1618</span>              : </span>
<span id="L1619"><span class="lineNum">    1619</span>              : // d2i_X509_PUBKEY parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L1620"><span class="lineNum">    1620</span>              : // SubjectPublicKeyInfo, as described in |d2i_SAMPLE|.</span>
<span id="L1621"><span class="lineNum">    1621</span>              : OPENSSL_EXPORT X509_PUBKEY *d2i_X509_PUBKEY(X509_PUBKEY **out,</span>
<span id="L1622"><span class="lineNum">    1622</span>              :                                             const uint8_t **inp, long len);</span>
<span id="L1623"><span class="lineNum">    1623</span>              : </span>
<span id="L1624"><span class="lineNum">    1624</span>              : // i2d_X509_PUBKEY marshals |key| as a DER-encoded SubjectPublicKeyInfo, as</span>
<span id="L1625"><span class="lineNum">    1625</span>              : // described in |i2d_SAMPLE|.</span>
<span id="L1626"><span class="lineNum">    1626</span>              : OPENSSL_EXPORT int i2d_X509_PUBKEY(const X509_PUBKEY *key, uint8_t **outp);</span>
<span id="L1627"><span class="lineNum">    1627</span>              : </span>
<span id="L1628"><span class="lineNum">    1628</span>              : // X509_PUBKEY_set serializes |pkey| into a newly-allocated |X509_PUBKEY|</span>
<span id="L1629"><span class="lineNum">    1629</span>              : // structure. On success, it frees |*x| if non-NULL, then sets |*x| to the new</span>
<span id="L1630"><span class="lineNum">    1630</span>              : // object, and returns one. Otherwise, it returns zero.</span>
<span id="L1631"><span class="lineNum">    1631</span>              : OPENSSL_EXPORT int X509_PUBKEY_set(X509_PUBKEY **x, EVP_PKEY *pkey);</span>
<span id="L1632"><span class="lineNum">    1632</span>              : </span>
<span id="L1633"><span class="lineNum">    1633</span>              : // X509_PUBKEY_get0 returns |key| as an |EVP_PKEY|, or NULL if |key| either</span>
<span id="L1634"><span class="lineNum">    1634</span>              : // could not be parsed or is an unrecognized algorithm. The |EVP_PKEY| is cached</span>
<span id="L1635"><span class="lineNum">    1635</span>              : // in |key|, so callers must not mutate the result.</span>
<span id="L1636"><span class="lineNum">    1636</span>              : OPENSSL_EXPORT EVP_PKEY *X509_PUBKEY_get0(const X509_PUBKEY *key);</span>
<span id="L1637"><span class="lineNum">    1637</span>              : </span>
<span id="L1638"><span class="lineNum">    1638</span>              : // X509_PUBKEY_get behaves like |X509_PUBKEY_get0| but increments the reference</span>
<span id="L1639"><span class="lineNum">    1639</span>              : // count on the |EVP_PKEY|. The caller must release the result with</span>
<span id="L1640"><span class="lineNum">    1640</span>              : // |EVP_PKEY_free| when done. The |EVP_PKEY| is cached in |key|, so callers must</span>
<span id="L1641"><span class="lineNum">    1641</span>              : // not mutate the result.</span>
<span id="L1642"><span class="lineNum">    1642</span>              : OPENSSL_EXPORT EVP_PKEY *X509_PUBKEY_get(const X509_PUBKEY *key);</span>
<span id="L1643"><span class="lineNum">    1643</span>              : </span>
<span id="L1644"><span class="lineNum">    1644</span>              : // X509_PUBKEY_set0_param sets |pub| to a key with AlgorithmIdentifier</span>
<span id="L1645"><span class="lineNum">    1645</span>              : // determined by |obj|, |param_type|, and |param_value|, and an encoded</span>
<span id="L1646"><span class="lineNum">    1646</span>              : // public key of |key|. On success, it gives |pub| ownership of all the other</span>
<span id="L1647"><span class="lineNum">    1647</span>              : // parameters and returns one. Otherwise, it returns zero. |key| must have been</span>
<span id="L1648"><span class="lineNum">    1648</span>              : // allocated by |OPENSSL_malloc|. |obj| and, if applicable, |param_value| must</span>
<span id="L1649"><span class="lineNum">    1649</span>              : // not be freed after a successful call, and must have been allocated in a</span>
<span id="L1650"><span class="lineNum">    1650</span>              : // manner compatible with |ASN1_OBJECT_free| or |ASN1_STRING_free|.</span>
<span id="L1651"><span class="lineNum">    1651</span>              : //</span>
<span id="L1652"><span class="lineNum">    1652</span>              : // |obj|, |param_type|, and |param_value| are interpreted as in</span>
<span id="L1653"><span class="lineNum">    1653</span>              : // |X509_ALGOR_set0|. See |X509_ALGOR_set0| for details.</span>
<span id="L1654"><span class="lineNum">    1654</span>              : OPENSSL_EXPORT int X509_PUBKEY_set0_param(X509_PUBKEY *pub, ASN1_OBJECT *obj,</span>
<span id="L1655"><span class="lineNum">    1655</span>              :                                           int param_type, void *param_value,</span>
<span id="L1656"><span class="lineNum">    1656</span>              :                                           uint8_t *key, int key_len);</span>
<span id="L1657"><span class="lineNum">    1657</span>              : </span>
<span id="L1658"><span class="lineNum">    1658</span>              : // X509_PUBKEY_get0_param outputs fields of |pub| and returns one. If |out_obj|</span>
<span id="L1659"><span class="lineNum">    1659</span>              : // is not NULL, it sets |*out_obj| to AlgorithmIdentifier's OID. If |out_key|</span>
<span id="L1660"><span class="lineNum">    1660</span>              : // is not NULL, it sets |*out_key| and |*out_key_len| to the encoded public key.</span>
<span id="L1661"><span class="lineNum">    1661</span>              : // If |out_alg| is not NULL, it sets |*out_alg| to the AlgorithmIdentifier.</span>
<span id="L1662"><span class="lineNum">    1662</span>              : //</span>
<span id="L1663"><span class="lineNum">    1663</span>              : // All pointers outputted by this function are internal to |pub| and must not be</span>
<span id="L1664"><span class="lineNum">    1664</span>              : // freed by the caller. Additionally, although some outputs are non-const,</span>
<span id="L1665"><span class="lineNum">    1665</span>              : // callers must not mutate the resulting objects.</span>
<span id="L1666"><span class="lineNum">    1666</span>              : //</span>
<span id="L1667"><span class="lineNum">    1667</span>              : // Note: X.509 SubjectPublicKeyInfo structures store the encoded public key as a</span>
<span id="L1668"><span class="lineNum">    1668</span>              : // BIT STRING. |*out_key| and |*out_key_len| will silently pad the key with zero</span>
<span id="L1669"><span class="lineNum">    1669</span>              : // bits if |pub| did not contain a whole number of bytes. Use</span>
<span id="L1670"><span class="lineNum">    1670</span>              : // |X509_PUBKEY_get0_public_key| to preserve this information.</span>
<span id="L1671"><span class="lineNum">    1671</span>              : OPENSSL_EXPORT int X509_PUBKEY_get0_param(ASN1_OBJECT **out_obj,</span>
<span id="L1672"><span class="lineNum">    1672</span>              :                                           const uint8_t **out_key,</span>
<span id="L1673"><span class="lineNum">    1673</span>              :                                           int *out_key_len,</span>
<span id="L1674"><span class="lineNum">    1674</span>              :                                           X509_ALGOR **out_alg,</span>
<span id="L1675"><span class="lineNum">    1675</span>              :                                           X509_PUBKEY *pub);</span>
<span id="L1676"><span class="lineNum">    1676</span>              : </span>
<span id="L1677"><span class="lineNum">    1677</span>              : // X509_PUBKEY_get0_public_key returns |pub|'s encoded public key.</span>
<span id="L1678"><span class="lineNum">    1678</span>              : OPENSSL_EXPORT const ASN1_BIT_STRING *X509_PUBKEY_get0_public_key(</span>
<span id="L1679"><span class="lineNum">    1679</span>              :     const X509_PUBKEY *pub);</span>
<span id="L1680"><span class="lineNum">    1680</span>              : </span>
<span id="L1681"><span class="lineNum">    1681</span>              : </span>
<span id="L1682"><span class="lineNum">    1682</span>              : // Extensions.</span>
<span id="L1683"><span class="lineNum">    1683</span>              : //</span>
<span id="L1684"><span class="lineNum">    1684</span>              : // X.509 certificates and CRLs may contain a list of extensions (RFC 5280).</span>
<span id="L1685"><span class="lineNum">    1685</span>              : // Extensions have a type, specified by an object identifier (|ASN1_OBJECT|) and</span>
<span id="L1686"><span class="lineNum">    1686</span>              : // a byte string value, which should a DER-encoded structure whose type is</span>
<span id="L1687"><span class="lineNum">    1687</span>              : // determined by the extension type. This library represents extensions with the</span>
<span id="L1688"><span class="lineNum">    1688</span>              : // |X509_EXTENSION| type.</span>
<span id="L1689"><span class="lineNum">    1689</span>              : </span>
<span id="L1690"><span class="lineNum">    1690</span>              : // X509_EXTENSION is an |ASN1_ITEM| whose ASN.1 type is X.509 Extension (RFC</span>
<span id="L1691"><span class="lineNum">    1691</span>              : // 5280) and C type is |X509_EXTENSION*|.</span>
<span id="L1692"><span class="lineNum">    1692</span>              : DECLARE_ASN1_ITEM(X509_EXTENSION)</span>
<span id="L1693"><span class="lineNum">    1693</span>              : </span>
<span id="L1694"><span class="lineNum">    1694</span>              : // X509_EXTENSION_new returns a newly-allocated, empty |X509_EXTENSION| object</span>
<span id="L1695"><span class="lineNum">    1695</span>              : // or NULL on error.</span>
<span id="L1696"><span class="lineNum">    1696</span>              : OPENSSL_EXPORT X509_EXTENSION *X509_EXTENSION_new(void);</span>
<span id="L1697"><span class="lineNum">    1697</span>              : </span>
<span id="L1698"><span class="lineNum">    1698</span>              : // X509_EXTENSION_free releases memory associated with |ex|.</span>
<span id="L1699"><span class="lineNum">    1699</span>              : OPENSSL_EXPORT void X509_EXTENSION_free(X509_EXTENSION *ex);</span>
<span id="L1700"><span class="lineNum">    1700</span>              : </span>
<span id="L1701"><span class="lineNum">    1701</span>              : // d2i_X509_EXTENSION parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L1702"><span class="lineNum">    1702</span>              : // X.509 Extension (RFC 5280), as described in |d2i_SAMPLE|.</span>
<span id="L1703"><span class="lineNum">    1703</span>              : OPENSSL_EXPORT X509_EXTENSION *d2i_X509_EXTENSION(X509_EXTENSION **out,</span>
<span id="L1704"><span class="lineNum">    1704</span>              :                                                   const uint8_t **inp,</span>
<span id="L1705"><span class="lineNum">    1705</span>              :                                                   long len);</span>
<span id="L1706"><span class="lineNum">    1706</span>              : </span>
<span id="L1707"><span class="lineNum">    1707</span>              : // i2d_X509_EXTENSION marshals |ex| as a DER-encoded X.509 Extension (RFC</span>
<span id="L1708"><span class="lineNum">    1708</span>              : // 5280), as described in |i2d_SAMPLE|.</span>
<span id="L1709"><span class="lineNum">    1709</span>              : OPENSSL_EXPORT int i2d_X509_EXTENSION(const X509_EXTENSION *ex, uint8_t **outp);</span>
<span id="L1710"><span class="lineNum">    1710</span>              : </span>
<span id="L1711"><span class="lineNum">    1711</span>              : // X509_EXTENSION_dup returns a newly-allocated copy of |ex|, or NULL on error.</span>
<span id="L1712"><span class="lineNum">    1712</span>              : // This function works by serializing the structure, so if |ex| is incomplete,</span>
<span id="L1713"><span class="lineNum">    1713</span>              : // it may fail.</span>
<span id="L1714"><span class="lineNum">    1714</span>              : OPENSSL_EXPORT X509_EXTENSION *X509_EXTENSION_dup(const X509_EXTENSION *ex);</span>
<span id="L1715"><span class="lineNum">    1715</span>              : </span>
<span id="L1716"><span class="lineNum">    1716</span>              : // X509_EXTENSION_create_by_NID creates a new |X509_EXTENSION| with type |nid|,</span>
<span id="L1717"><span class="lineNum">    1717</span>              : // value |data|, and critical bit |crit|. It returns an |X509_EXTENSION| on</span>
<span id="L1718"><span class="lineNum">    1718</span>              : // success, and NULL on error. |nid| should be a |NID_*| constant.</span>
<span id="L1719"><span class="lineNum">    1719</span>              : //</span>
<span id="L1720"><span class="lineNum">    1720</span>              : // If |ex| and |*ex| are both non-NULL, |*ex| is used to hold the result,</span>
<span id="L1721"><span class="lineNum">    1721</span>              : // otherwise a new object is allocated. If |ex| is non-NULL and |*ex| is NULL,</span>
<span id="L1722"><span class="lineNum">    1722</span>              : // the function sets |*ex| to point to the newly allocated result, in addition</span>
<span id="L1723"><span class="lineNum">    1723</span>              : // to returning the result.</span>
<span id="L1724"><span class="lineNum">    1724</span>              : OPENSSL_EXPORT X509_EXTENSION *X509_EXTENSION_create_by_NID(</span>
<span id="L1725"><span class="lineNum">    1725</span>              :     X509_EXTENSION **ex, int nid, int crit, const ASN1_OCTET_STRING *data);</span>
<span id="L1726"><span class="lineNum">    1726</span>              : </span>
<span id="L1727"><span class="lineNum">    1727</span>              : // X509_EXTENSION_create_by_OBJ behaves like |X509_EXTENSION_create_by_NID|, but</span>
<span id="L1728"><span class="lineNum">    1728</span>              : // the extension type is determined by an |ASN1_OBJECT|.</span>
<span id="L1729"><span class="lineNum">    1729</span>              : OPENSSL_EXPORT X509_EXTENSION *X509_EXTENSION_create_by_OBJ(</span>
<span id="L1730"><span class="lineNum">    1730</span>              :     X509_EXTENSION **ex, const ASN1_OBJECT *obj, int crit,</span>
<span id="L1731"><span class="lineNum">    1731</span>              :     const ASN1_OCTET_STRING *data);</span>
<span id="L1732"><span class="lineNum">    1732</span>              : </span>
<span id="L1733"><span class="lineNum">    1733</span>              : // X509_EXTENSION_get_object returns |ex|'s extension type. This function</span>
<span id="L1734"><span class="lineNum">    1734</span>              : // returns a non-const pointer for OpenSSL compatibility, but callers should not</span>
<span id="L1735"><span class="lineNum">    1735</span>              : // mutate the result.</span>
<span id="L1736"><span class="lineNum">    1736</span>              : OPENSSL_EXPORT ASN1_OBJECT *X509_EXTENSION_get_object(const X509_EXTENSION *ex);</span>
<span id="L1737"><span class="lineNum">    1737</span>              : </span>
<span id="L1738"><span class="lineNum">    1738</span>              : // X509_EXTENSION_get_data returns |ne|'s extension value. This function returns</span>
<span id="L1739"><span class="lineNum">    1739</span>              : // a non-const pointer for OpenSSL compatibility, but callers should not mutate</span>
<span id="L1740"><span class="lineNum">    1740</span>              : // the result.</span>
<span id="L1741"><span class="lineNum">    1741</span>              : OPENSSL_EXPORT ASN1_OCTET_STRING *X509_EXTENSION_get_data(</span>
<span id="L1742"><span class="lineNum">    1742</span>              :     const X509_EXTENSION *ne);</span>
<span id="L1743"><span class="lineNum">    1743</span>              : </span>
<span id="L1744"><span class="lineNum">    1744</span>              : // X509_EXTENSION_get_critical returns one if |ex| is critical and zero</span>
<span id="L1745"><span class="lineNum">    1745</span>              : // otherwise.</span>
<span id="L1746"><span class="lineNum">    1746</span>              : OPENSSL_EXPORT int X509_EXTENSION_get_critical(const X509_EXTENSION *ex);</span>
<span id="L1747"><span class="lineNum">    1747</span>              : </span>
<span id="L1748"><span class="lineNum">    1748</span>              : // X509_EXTENSION_set_object sets |ex|'s extension type to |obj|. It returns one</span>
<span id="L1749"><span class="lineNum">    1749</span>              : // on success and zero on error.</span>
<span id="L1750"><span class="lineNum">    1750</span>              : OPENSSL_EXPORT int X509_EXTENSION_set_object(X509_EXTENSION *ex,</span>
<span id="L1751"><span class="lineNum">    1751</span>              :                                              const ASN1_OBJECT *obj);</span>
<span id="L1752"><span class="lineNum">    1752</span>              : </span>
<span id="L1753"><span class="lineNum">    1753</span>              : // X509_EXTENSION_set_critical sets |ex| to critical if |crit| is non-zero and</span>
<span id="L1754"><span class="lineNum">    1754</span>              : // to non-critical if |crit| is zero.</span>
<span id="L1755"><span class="lineNum">    1755</span>              : OPENSSL_EXPORT int X509_EXTENSION_set_critical(X509_EXTENSION *ex, int crit);</span>
<span id="L1756"><span class="lineNum">    1756</span>              : </span>
<span id="L1757"><span class="lineNum">    1757</span>              : // X509_EXTENSION_set_data set's |ex|'s extension value to a copy of |data|. It</span>
<span id="L1758"><span class="lineNum">    1758</span>              : // returns one on success and zero on error.</span>
<span id="L1759"><span class="lineNum">    1759</span>              : OPENSSL_EXPORT int X509_EXTENSION_set_data(X509_EXTENSION *ex,</span>
<span id="L1760"><span class="lineNum">    1760</span>              :                                            const ASN1_OCTET_STRING *data);</span>
<span id="L1761"><span class="lineNum">    1761</span>              : </span>
<span id="L1762"><span class="lineNum">    1762</span>              : </span>
<span id="L1763"><span class="lineNum">    1763</span>              : // Extension lists.</span>
<span id="L1764"><span class="lineNum">    1764</span>              : //</span>
<span id="L1765"><span class="lineNum">    1765</span>              : // The following functions manipulate lists of extensions. Most of them have</span>
<span id="L1766"><span class="lineNum">    1766</span>              : // corresponding functions on the containing |X509|, |X509_CRL|, or</span>
<span id="L1767"><span class="lineNum">    1767</span>              : // |X509_REVOKED|.</span>
<span id="L1768"><span class="lineNum">    1768</span>              : </span>
<span id="L1769"><span class="lineNum">    1769</span>              : DEFINE_STACK_OF(X509_EXTENSION)</span>
<span id="L1770"><span class="lineNum">    1770</span>              : typedef STACK_OF(X509_EXTENSION) X509_EXTENSIONS;</span>
<span id="L1771"><span class="lineNum">    1771</span>              : </span>
<span id="L1772"><span class="lineNum">    1772</span>              : // d2i_X509_EXTENSIONS parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L1773"><span class="lineNum">    1773</span>              : // SEQUENCE OF Extension (RFC 5280), as described in |d2i_SAMPLE|.</span>
<span id="L1774"><span class="lineNum">    1774</span>              : OPENSSL_EXPORT X509_EXTENSIONS *d2i_X509_EXTENSIONS(X509_EXTENSIONS **out,</span>
<span id="L1775"><span class="lineNum">    1775</span>              :                                                     const uint8_t **inp,</span>
<span id="L1776"><span class="lineNum">    1776</span>              :                                                     long len);</span>
<span id="L1777"><span class="lineNum">    1777</span>              : </span>
<span id="L1778"><span class="lineNum">    1778</span>              : // i2d_X509_EXTENSIONS marshals |alg| as a DER-encoded SEQUENCE OF Extension</span>
<span id="L1779"><span class="lineNum">    1779</span>              : // (RFC 5280), as described in |i2d_SAMPLE|.</span>
<span id="L1780"><span class="lineNum">    1780</span>              : OPENSSL_EXPORT int i2d_X509_EXTENSIONS(const X509_EXTENSIONS *alg,</span>
<span id="L1781"><span class="lineNum">    1781</span>              :                                        uint8_t **outp);</span>
<span id="L1782"><span class="lineNum">    1782</span>              : </span>
<span id="L1783"><span class="lineNum">    1783</span>              : // X509v3_get_ext_count returns the number of extensions in |x|.</span>
<span id="L1784"><span class="lineNum">    1784</span>              : OPENSSL_EXPORT int X509v3_get_ext_count(const STACK_OF(X509_EXTENSION) *x);</span>
<span id="L1785"><span class="lineNum">    1785</span>              : </span>
<span id="L1786"><span class="lineNum">    1786</span>              : // X509v3_get_ext_by_NID returns the index of the first extension in |x| with</span>
<span id="L1787"><span class="lineNum">    1787</span>              : // type |nid|, or a negative number if not found. If found, callers can use</span>
<span id="L1788"><span class="lineNum">    1788</span>              : // |X509v3_get_ext| to look up the extension by index.</span>
<span id="L1789"><span class="lineNum">    1789</span>              : //</span>
<span id="L1790"><span class="lineNum">    1790</span>              : // If |lastpos| is non-negative, it begins searching at |lastpos| + 1. Callers</span>
<span id="L1791"><span class="lineNum">    1791</span>              : // can thus loop over all matching extensions by first passing -1 and then</span>
<span id="L1792"><span class="lineNum">    1792</span>              : // passing the previously-returned value until no match is returned.</span>
<span id="L1793"><span class="lineNum">    1793</span>              : OPENSSL_EXPORT int X509v3_get_ext_by_NID(const STACK_OF(X509_EXTENSION) *x,</span>
<span id="L1794"><span class="lineNum">    1794</span>              :                                          int nid, int lastpos);</span>
<span id="L1795"><span class="lineNum">    1795</span>              : </span>
<span id="L1796"><span class="lineNum">    1796</span>              : // X509v3_get_ext_by_OBJ behaves like |X509v3_get_ext_by_NID| but looks for</span>
<span id="L1797"><span class="lineNum">    1797</span>              : // extensions matching |obj|.</span>
<span id="L1798"><span class="lineNum">    1798</span>              : OPENSSL_EXPORT int X509v3_get_ext_by_OBJ(const STACK_OF(X509_EXTENSION) *x,</span>
<span id="L1799"><span class="lineNum">    1799</span>              :                                          const ASN1_OBJECT *obj, int lastpos);</span>
<span id="L1800"><span class="lineNum">    1800</span>              : </span>
<span id="L1801"><span class="lineNum">    1801</span>              : // X509v3_get_ext_by_critical returns the index of the first extension in |x|</span>
<span id="L1802"><span class="lineNum">    1802</span>              : // whose critical bit matches |crit|, or a negative number if no such extension</span>
<span id="L1803"><span class="lineNum">    1803</span>              : // was found.</span>
<span id="L1804"><span class="lineNum">    1804</span>              : //</span>
<span id="L1805"><span class="lineNum">    1805</span>              : // If |lastpos| is non-negative, it begins searching at |lastpos| + 1. Callers</span>
<span id="L1806"><span class="lineNum">    1806</span>              : // can thus loop over all matching extensions by first passing -1 and then</span>
<span id="L1807"><span class="lineNum">    1807</span>              : // passing the previously-returned value until no match is returned.</span>
<span id="L1808"><span class="lineNum">    1808</span>              : OPENSSL_EXPORT int X509v3_get_ext_by_critical(const STACK_OF(X509_EXTENSION) *x,</span>
<span id="L1809"><span class="lineNum">    1809</span>              :                                               int crit, int lastpos);</span>
<span id="L1810"><span class="lineNum">    1810</span>              : </span>
<span id="L1811"><span class="lineNum">    1811</span>              : // X509v3_get_ext returns the extension in |x| at index |loc|, or NULL if |loc|</span>
<span id="L1812"><span class="lineNum">    1812</span>              : // is out of bounds. This function returns a non-const pointer for OpenSSL</span>
<span id="L1813"><span class="lineNum">    1813</span>              : // compatibility, but callers should not mutate the result.</span>
<span id="L1814"><span class="lineNum">    1814</span>              : OPENSSL_EXPORT X509_EXTENSION *X509v3_get_ext(const STACK_OF(X509_EXTENSION) *x,</span>
<span id="L1815"><span class="lineNum">    1815</span>              :                                               int loc);</span>
<span id="L1816"><span class="lineNum">    1816</span>              : </span>
<span id="L1817"><span class="lineNum">    1817</span>              : // X509v3_delete_ext removes the extension in |x| at index |loc| and returns the</span>
<span id="L1818"><span class="lineNum">    1818</span>              : // removed extension, or NULL if |loc| was out of bounds. If an extension was</span>
<span id="L1819"><span class="lineNum">    1819</span>              : // returned, the caller must release it with |X509_EXTENSION_free|.</span>
<span id="L1820"><span class="lineNum">    1820</span>              : OPENSSL_EXPORT X509_EXTENSION *X509v3_delete_ext(STACK_OF(X509_EXTENSION) *x,</span>
<span id="L1821"><span class="lineNum">    1821</span>              :                                                  int loc);</span>
<span id="L1822"><span class="lineNum">    1822</span>              : </span>
<span id="L1823"><span class="lineNum">    1823</span>              : // X509v3_add_ext adds a copy of |ex| to the extension list in |*x|. If |*x| is</span>
<span id="L1824"><span class="lineNum">    1824</span>              : // NULL, it allocates a new |STACK_OF(X509_EXTENSION)| to hold the copy and sets</span>
<span id="L1825"><span class="lineNum">    1825</span>              : // |*x| to the new list. It returns |*x| on success and NULL on error. The</span>
<span id="L1826"><span class="lineNum">    1826</span>              : // caller retains ownership of |ex| and can release it independently of |*x|.</span>
<span id="L1827"><span class="lineNum">    1827</span>              : //</span>
<span id="L1828"><span class="lineNum">    1828</span>              : // The new extension is inserted at index |loc|, shifting extensions to the</span>
<span id="L1829"><span class="lineNum">    1829</span>              : // right. If |loc| is -1 or out of bounds, the new extension is appended to the</span>
<span id="L1830"><span class="lineNum">    1830</span>              : // list.</span>
<span id="L1831"><span class="lineNum">    1831</span>              : OPENSSL_EXPORT STACK_OF(X509_EXTENSION) *X509v3_add_ext(</span>
<span id="L1832"><span class="lineNum">    1832</span>              :     STACK_OF(X509_EXTENSION) **x, const X509_EXTENSION *ex, int loc);</span>
<span id="L1833"><span class="lineNum">    1833</span>              : </span>
<span id="L1834"><span class="lineNum">    1834</span>              : </span>
<span id="L1835"><span class="lineNum">    1835</span>              : // Built-in extensions.</span>
<span id="L1836"><span class="lineNum">    1836</span>              : //</span>
<span id="L1837"><span class="lineNum">    1837</span>              : // Several functions in the library encode and decode extension values into a</span>
<span id="L1838"><span class="lineNum">    1838</span>              : // C structure to that extension. The following extensions are supported:</span>
<span id="L1839"><span class="lineNum">    1839</span>              : //</span>
<span id="L1840"><span class="lineNum">    1840</span>              : // - |NID_authority_key_identifier| with type |AUTHORITY_KEYID|</span>
<span id="L1841"><span class="lineNum">    1841</span>              : // - |NID_basic_constraints| with type |BASIC_CONSTRAINTS|</span>
<span id="L1842"><span class="lineNum">    1842</span>              : // - |NID_certificate_issuer| with type |GENERAL_NAMES|</span>
<span id="L1843"><span class="lineNum">    1843</span>              : // - |NID_certificate_policies| with type |CERTIFICATEPOLICIES|</span>
<span id="L1844"><span class="lineNum">    1844</span>              : // - |NID_crl_distribution_points| with type |CRL_DIST_POINTS|</span>
<span id="L1845"><span class="lineNum">    1845</span>              : // - |NID_crl_number| with type |ASN1_INTEGER|</span>
<span id="L1846"><span class="lineNum">    1846</span>              : // - |NID_crl_reason| with type |ASN1_ENUMERATED|</span>
<span id="L1847"><span class="lineNum">    1847</span>              : // - |NID_delta_crl| with type |ASN1_INTEGER|</span>
<span id="L1848"><span class="lineNum">    1848</span>              : // - |NID_ext_key_usage| with type |EXTENDED_KEY_USAGE|</span>
<span id="L1849"><span class="lineNum">    1849</span>              : // - |NID_freshest_crl| with type |ISSUING_DIST_POINT|</span>
<span id="L1850"><span class="lineNum">    1850</span>              : // - |NID_id_pkix_OCSP_noCheck| with type |ASN1_NULL|</span>
<span id="L1851"><span class="lineNum">    1851</span>              : // - |NID_info_access| with type |AUTHORITY_INFO_ACCESS|</span>
<span id="L1852"><span class="lineNum">    1852</span>              : // - |NID_inhibit_any_policy| with type |ASN1_INTEGER|</span>
<span id="L1853"><span class="lineNum">    1853</span>              : // - |NID_invalidity_date| with type |ASN1_GENERALIZEDTIME|</span>
<span id="L1854"><span class="lineNum">    1854</span>              : // - |NID_issuer_alt_name| with type |GENERAL_NAMES|</span>
<span id="L1855"><span class="lineNum">    1855</span>              : // - |NID_issuing_distribution_point| with type |ISSUING_DIST_POINT|</span>
<span id="L1856"><span class="lineNum">    1856</span>              : // - |NID_key_usage| with type |ASN1_BIT_STRING|</span>
<span id="L1857"><span class="lineNum">    1857</span>              : // - |NID_name_constraints| with type |NAME_CONSTRAINTS|</span>
<span id="L1858"><span class="lineNum">    1858</span>              : // - |NID_netscape_base_url| with type |ASN1_IA5STRING|</span>
<span id="L1859"><span class="lineNum">    1859</span>              : // - |NID_netscape_ca_policy_url| with type |ASN1_IA5STRING|</span>
<span id="L1860"><span class="lineNum">    1860</span>              : // - |NID_netscape_ca_revocation_url| with type |ASN1_IA5STRING|</span>
<span id="L1861"><span class="lineNum">    1861</span>              : // - |NID_netscape_cert_type| with type |ASN1_BIT_STRING|</span>
<span id="L1862"><span class="lineNum">    1862</span>              : // - |NID_netscape_comment| with type |ASN1_IA5STRING|</span>
<span id="L1863"><span class="lineNum">    1863</span>              : // - |NID_netscape_renewal_url| with type |ASN1_IA5STRING|</span>
<span id="L1864"><span class="lineNum">    1864</span>              : // - |NID_netscape_revocation_url| with type |ASN1_IA5STRING|</span>
<span id="L1865"><span class="lineNum">    1865</span>              : // - |NID_netscape_ssl_server_name| with type |ASN1_IA5STRING|</span>
<span id="L1866"><span class="lineNum">    1866</span>              : // - |NID_policy_constraints| with type |POLICY_CONSTRAINTS|</span>
<span id="L1867"><span class="lineNum">    1867</span>              : // - |NID_policy_mappings| with type |POLICY_MAPPINGS|</span>
<span id="L1868"><span class="lineNum">    1868</span>              : // - |NID_sinfo_access| with type |AUTHORITY_INFO_ACCESS|</span>
<span id="L1869"><span class="lineNum">    1869</span>              : // - |NID_subject_alt_name| with type |GENERAL_NAMES|</span>
<span id="L1870"><span class="lineNum">    1870</span>              : // - |NID_subject_key_identifier| with type |ASN1_OCTET_STRING|</span>
<span id="L1871"><span class="lineNum">    1871</span>              : //</span>
<span id="L1872"><span class="lineNum">    1872</span>              : // If an extension does not appear in this list, e.g. for a custom extension,</span>
<span id="L1873"><span class="lineNum">    1873</span>              : // callers can instead use functions such as |X509_get_ext_by_OBJ|,</span>
<span id="L1874"><span class="lineNum">    1874</span>              : // |X509_EXTENSION_get_data|, and |X509_EXTENSION_create_by_OBJ| to inspect or</span>
<span id="L1875"><span class="lineNum">    1875</span>              : // create extensions directly. Although the |X509V3_EXT_METHOD| mechanism allows</span>
<span id="L1876"><span class="lineNum">    1876</span>              : // registering custom extensions, doing so is deprecated and may result in</span>
<span id="L1877"><span class="lineNum">    1877</span>              : // threading or memory errors.</span>
<span id="L1878"><span class="lineNum">    1878</span>              : </span>
<span id="L1879"><span class="lineNum">    1879</span>              : // X509V3_EXT_d2i decodes |ext| and returns a pointer to a newly-allocated</span>
<span id="L1880"><span class="lineNum">    1880</span>              : // structure, with type dependent on the type of the extension. It returns NULL</span>
<span id="L1881"><span class="lineNum">    1881</span>              : // if |ext| is an unsupported extension or if there was a syntax error in the</span>
<span id="L1882"><span class="lineNum">    1882</span>              : // extension. The caller should cast the return value to the expected type and</span>
<span id="L1883"><span class="lineNum">    1883</span>              : // free the structure when done.</span>
<span id="L1884"><span class="lineNum">    1884</span>              : //</span>
<span id="L1885"><span class="lineNum">    1885</span>              : // WARNING: Casting the return value to the wrong type is a potentially</span>
<span id="L1886"><span class="lineNum">    1886</span>              : // exploitable memory error, so callers must not use this function before</span>
<span id="L1887"><span class="lineNum">    1887</span>              : // checking |ext| is of a known type. See the list at the top of this section</span>
<span id="L1888"><span class="lineNum">    1888</span>              : // for the correct types.</span>
<span id="L1889"><span class="lineNum">    1889</span>              : OPENSSL_EXPORT void *X509V3_EXT_d2i(const X509_EXTENSION *ext);</span>
<span id="L1890"><span class="lineNum">    1890</span>              : </span>
<span id="L1891"><span class="lineNum">    1891</span>              : // X509V3_get_d2i finds and decodes the extension in |extensions| of type |nid|.</span>
<span id="L1892"><span class="lineNum">    1892</span>              : // If found, it decodes it and returns a newly-allocated structure, with type</span>
<span id="L1893"><span class="lineNum">    1893</span>              : // dependent on |nid|. If the extension is not found or on error, it returns</span>
<span id="L1894"><span class="lineNum">    1894</span>              : // NULL. The caller may distinguish these cases using the |out_critical| value.</span>
<span id="L1895"><span class="lineNum">    1895</span>              : //</span>
<span id="L1896"><span class="lineNum">    1896</span>              : // If |out_critical| is not NULL, this function sets |*out_critical| to one if</span>
<span id="L1897"><span class="lineNum">    1897</span>              : // the extension is found and critical, zero if it is found and not critical, -1</span>
<span id="L1898"><span class="lineNum">    1898</span>              : // if it is not found, and -2 if there is an invalid duplicate extension. Note</span>
<span id="L1899"><span class="lineNum">    1899</span>              : // this function may set |*out_critical| to one or zero and still return NULL if</span>
<span id="L1900"><span class="lineNum">    1900</span>              : // the extension is found but has a syntax error.</span>
<span id="L1901"><span class="lineNum">    1901</span>              : //</span>
<span id="L1902"><span class="lineNum">    1902</span>              : // If |out_idx| is not NULL, this function looks for the first occurrence of the</span>
<span id="L1903"><span class="lineNum">    1903</span>              : // extension after |*out_idx|. It then sets |*out_idx| to the index of the</span>
<span id="L1904"><span class="lineNum">    1904</span>              : // extension, or -1 if not found. If |out_idx| is non-NULL, duplicate extensions</span>
<span id="L1905"><span class="lineNum">    1905</span>              : // are not treated as an error. Callers, however, should not rely on this</span>
<span id="L1906"><span class="lineNum">    1906</span>              : // behavior as it may be removed in the future. Duplicate extensions are</span>
<span id="L1907"><span class="lineNum">    1907</span>              : // forbidden in RFC 5280.</span>
<span id="L1908"><span class="lineNum">    1908</span>              : //</span>
<span id="L1909"><span class="lineNum">    1909</span>              : // WARNING: This function is difficult to use correctly. Callers should pass a</span>
<span id="L1910"><span class="lineNum">    1910</span>              : // non-NULL |out_critical| and check both the return value and |*out_critical|</span>
<span id="L1911"><span class="lineNum">    1911</span>              : // to handle errors. If the return value is NULL and |*out_critical| is not -1,</span>
<span id="L1912"><span class="lineNum">    1912</span>              : // there was an error. Otherwise, the function succeeded and but may return NULL</span>
<span id="L1913"><span class="lineNum">    1913</span>              : // for a missing extension. Callers should pass NULL to |out_idx| so that</span>
<span id="L1914"><span class="lineNum">    1914</span>              : // duplicate extensions are handled correctly.</span>
<span id="L1915"><span class="lineNum">    1915</span>              : //</span>
<span id="L1916"><span class="lineNum">    1916</span>              : // Additionally, casting the return value to the wrong type is a potentially</span>
<span id="L1917"><span class="lineNum">    1917</span>              : // exploitable memory error, so callers must ensure the cast and |nid| match.</span>
<span id="L1918"><span class="lineNum">    1918</span>              : // See the list at the top of this section for the correct types.</span>
<span id="L1919"><span class="lineNum">    1919</span>              : OPENSSL_EXPORT void *X509V3_get_d2i(const STACK_OF(X509_EXTENSION) *extensions,</span>
<span id="L1920"><span class="lineNum">    1920</span>              :                                     int nid, int *out_critical, int *out_idx);</span>
<span id="L1921"><span class="lineNum">    1921</span>              : </span>
<span id="L1922"><span class="lineNum">    1922</span>              : // X509V3_EXT_free casts |ext_data| into the type that corresponds to |nid| and</span>
<span id="L1923"><span class="lineNum">    1923</span>              : // releases memory associated with it. It returns one on success and zero if</span>
<span id="L1924"><span class="lineNum">    1924</span>              : // |nid| is not a known extension.</span>
<span id="L1925"><span class="lineNum">    1925</span>              : //</span>
<span id="L1926"><span class="lineNum">    1926</span>              : // WARNING: Casting |ext_data| to the wrong type is a potentially exploitable</span>
<span id="L1927"><span class="lineNum">    1927</span>              : // memory error, so callers must ensure |ext_data|'s type matches |nid|. See the</span>
<span id="L1928"><span class="lineNum">    1928</span>              : // list at the top of this section for the correct types.</span>
<span id="L1929"><span class="lineNum">    1929</span>              : //</span>
<span id="L1930"><span class="lineNum">    1930</span>              : // TODO(davidben): OpenSSL upstream no longer exposes this function. Remove it?</span>
<span id="L1931"><span class="lineNum">    1931</span>              : OPENSSL_EXPORT int X509V3_EXT_free(int nid, void *ext_data);</span>
<span id="L1932"><span class="lineNum">    1932</span>              : </span>
<span id="L1933"><span class="lineNum">    1933</span>              : // X509V3_EXT_i2d casts |ext_struc| into the type that corresponds to</span>
<span id="L1934"><span class="lineNum">    1934</span>              : // |ext_nid|, serializes it, and returns a newly-allocated |X509_EXTENSION|</span>
<span id="L1935"><span class="lineNum">    1935</span>              : // object containing the serialization, or NULL on error. The |X509_EXTENSION|</span>
<span id="L1936"><span class="lineNum">    1936</span>              : // has OID |ext_nid| and is critical if |crit| is one.</span>
<span id="L1937"><span class="lineNum">    1937</span>              : //</span>
<span id="L1938"><span class="lineNum">    1938</span>              : // WARNING: Casting |ext_struc| to the wrong type is a potentially exploitable</span>
<span id="L1939"><span class="lineNum">    1939</span>              : // memory error, so callers must ensure |ext_struct|'s type matches |ext_nid|.</span>
<span id="L1940"><span class="lineNum">    1940</span>              : // See the list at the top of this section for the correct types.</span>
<span id="L1941"><span class="lineNum">    1941</span>              : OPENSSL_EXPORT X509_EXTENSION *X509V3_EXT_i2d(int ext_nid, int crit,</span>
<span id="L1942"><span class="lineNum">    1942</span>              :                                               void *ext_struc);</span>
<span id="L1943"><span class="lineNum">    1943</span>              : </span>
<span id="L1944"><span class="lineNum">    1944</span>              : // The following constants control the behavior of |X509V3_add1_i2d| and related</span>
<span id="L1945"><span class="lineNum">    1945</span>              : // functions.</span>
<span id="L1946"><span class="lineNum">    1946</span>              : </span>
<span id="L1947"><span class="lineNum">    1947</span>              : // X509V3_ADD_OP_MASK can be ANDed with the flags to determine how duplicate</span>
<span id="L1948"><span class="lineNum">    1948</span>              : // extensions are processed.</span>
<span id="L1949"><span class="lineNum">    1949</span>              : #define X509V3_ADD_OP_MASK 0xfL</span>
<span id="L1950"><span class="lineNum">    1950</span>              : </span>
<span id="L1951"><span class="lineNum">    1951</span>              : // X509V3_ADD_DEFAULT causes the function to fail if the extension was already</span>
<span id="L1952"><span class="lineNum">    1952</span>              : // present.</span>
<span id="L1953"><span class="lineNum">    1953</span>              : #define X509V3_ADD_DEFAULT 0L</span>
<span id="L1954"><span class="lineNum">    1954</span>              : </span>
<span id="L1955"><span class="lineNum">    1955</span>              : // X509V3_ADD_APPEND causes the function to unconditionally appended the new</span>
<span id="L1956"><span class="lineNum">    1956</span>              : // extension to to the extensions list, even if there is a duplicate.</span>
<span id="L1957"><span class="lineNum">    1957</span>              : #define X509V3_ADD_APPEND 1L</span>
<span id="L1958"><span class="lineNum">    1958</span>              : </span>
<span id="L1959"><span class="lineNum">    1959</span>              : // X509V3_ADD_REPLACE causes the function to replace the existing extension, or</span>
<span id="L1960"><span class="lineNum">    1960</span>              : // append if it is not present.</span>
<span id="L1961"><span class="lineNum">    1961</span>              : #define X509V3_ADD_REPLACE 2L</span>
<span id="L1962"><span class="lineNum">    1962</span>              : </span>
<span id="L1963"><span class="lineNum">    1963</span>              : // X509V3_ADD_REPLACE_EXISTING causes the function to replace the existing</span>
<span id="L1964"><span class="lineNum">    1964</span>              : // extension and fail if it is not present.</span>
<span id="L1965"><span class="lineNum">    1965</span>              : #define X509V3_ADD_REPLACE_EXISTING 3L</span>
<span id="L1966"><span class="lineNum">    1966</span>              : </span>
<span id="L1967"><span class="lineNum">    1967</span>              : // X509V3_ADD_KEEP_EXISTING causes the function to succeed without replacing the</span>
<span id="L1968"><span class="lineNum">    1968</span>              : // extension if already present.</span>
<span id="L1969"><span class="lineNum">    1969</span>              : #define X509V3_ADD_KEEP_EXISTING 4L</span>
<span id="L1970"><span class="lineNum">    1970</span>              : </span>
<span id="L1971"><span class="lineNum">    1971</span>              : // X509V3_ADD_DELETE causes the function to remove the matching extension. No</span>
<span id="L1972"><span class="lineNum">    1972</span>              : // new extension is added. If there is no matching extension, the function</span>
<span id="L1973"><span class="lineNum">    1973</span>              : // fails. The |value| parameter is ignored in this mode.</span>
<span id="L1974"><span class="lineNum">    1974</span>              : #define X509V3_ADD_DELETE 5L</span>
<span id="L1975"><span class="lineNum">    1975</span>              : </span>
<span id="L1976"><span class="lineNum">    1976</span>              : // X509V3_ADD_SILENT may be ORed into one of the values above to indicate the</span>
<span id="L1977"><span class="lineNum">    1977</span>              : // function should not add to the error queue on duplicate or missing extension.</span>
<span id="L1978"><span class="lineNum">    1978</span>              : // The function will continue to return zero in those cases, and it will</span>
<span id="L1979"><span class="lineNum">    1979</span>              : // continue to return -1 and add to the error queue on other errors.</span>
<span id="L1980"><span class="lineNum">    1980</span>              : #define X509V3_ADD_SILENT 0x10</span>
<span id="L1981"><span class="lineNum">    1981</span>              : </span>
<span id="L1982"><span class="lineNum">    1982</span>              : // X509V3_add1_i2d casts |value| to the type that corresponds to |nid|,</span>
<span id="L1983"><span class="lineNum">    1983</span>              : // serializes it, and appends it to the extension list in |*x|. If |*x| is NULL,</span>
<span id="L1984"><span class="lineNum">    1984</span>              : // it will set |*x| to a newly-allocated |STACK_OF(X509_EXTENSION)| as needed.</span>
<span id="L1985"><span class="lineNum">    1985</span>              : // The |crit| parameter determines whether the new extension is critical.</span>
<span id="L1986"><span class="lineNum">    1986</span>              : // |flags| may be some combination of the |X509V3_ADD_*| constants to control</span>
<span id="L1987"><span class="lineNum">    1987</span>              : // the function's behavior on duplicate extension.</span>
<span id="L1988"><span class="lineNum">    1988</span>              : //</span>
<span id="L1989"><span class="lineNum">    1989</span>              : // This function returns one on success, zero if the operation failed due to a</span>
<span id="L1990"><span class="lineNum">    1990</span>              : // missing or duplicate extension, and -1 on other errors.</span>
<span id="L1991"><span class="lineNum">    1991</span>              : //</span>
<span id="L1992"><span class="lineNum">    1992</span>              : // WARNING: Casting |value| to the wrong type is a potentially exploitable</span>
<span id="L1993"><span class="lineNum">    1993</span>              : // memory error, so callers must ensure |value|'s type matches |nid|. See the</span>
<span id="L1994"><span class="lineNum">    1994</span>              : // list at the top of this section for the correct types.</span>
<span id="L1995"><span class="lineNum">    1995</span>              : OPENSSL_EXPORT int X509V3_add1_i2d(STACK_OF(X509_EXTENSION) **x, int nid,</span>
<span id="L1996"><span class="lineNum">    1996</span>              :                                    void *value, int crit, unsigned long flags);</span>
<span id="L1997"><span class="lineNum">    1997</span>              : </span>
<span id="L1998"><span class="lineNum">    1998</span>              : </span>
<span id="L1999"><span class="lineNum">    1999</span>              : // Basic constraints.</span>
<span id="L2000"><span class="lineNum">    2000</span>              : //</span>
<span id="L2001"><span class="lineNum">    2001</span>              : // The basic constraints extension (RFC 5280, section 4.2.1.9) determines</span>
<span id="L2002"><span class="lineNum">    2002</span>              : // whether a certificate is a CA certificate and, if so, optionally constrains</span>
<span id="L2003"><span class="lineNum">    2003</span>              : // the maximum depth of the certificate chain.</span>
<span id="L2004"><span class="lineNum">    2004</span>              : </span>
<span id="L2005"><span class="lineNum">    2005</span>              : // A BASIC_CONSTRAINTS_st, aka |BASIC_CONSTRAINTS| represents an</span>
<span id="L2006"><span class="lineNum">    2006</span>              : // BasicConstraints structure (RFC 5280).</span>
<span id="L2007"><span class="lineNum">    2007</span>              : struct BASIC_CONSTRAINTS_st {</span>
<span id="L2008"><span class="lineNum">    2008</span>              :   ASN1_BOOLEAN ca;</span>
<span id="L2009"><span class="lineNum">    2009</span>              :   ASN1_INTEGER *pathlen;</span>
<span id="L2010"><span class="lineNum">    2010</span>              : } /* BASIC_CONSTRAINTS */;</span>
<span id="L2011"><span class="lineNum">    2011</span>              : </span>
<span id="L2012"><span class="lineNum">    2012</span>              : // BASIC_CONSTRAINTS is an |ASN1_ITEM| whose ASN.1 type is BasicConstraints (RFC</span>
<span id="L2013"><span class="lineNum">    2013</span>              : // 5280) and C type is |BASIC_CONSTRAINTS*|.</span>
<span id="L2014"><span class="lineNum">    2014</span>              : DECLARE_ASN1_ITEM(BASIC_CONSTRAINTS)</span>
<span id="L2015"><span class="lineNum">    2015</span>              : </span>
<span id="L2016"><span class="lineNum">    2016</span>              : // BASIC_CONSTRAINTS_new returns a newly-allocated, empty |BASIC_CONSTRAINTS|</span>
<span id="L2017"><span class="lineNum">    2017</span>              : // object, or NULL on error.</span>
<span id="L2018"><span class="lineNum">    2018</span>              : OPENSSL_EXPORT BASIC_CONSTRAINTS *BASIC_CONSTRAINTS_new(void);</span>
<span id="L2019"><span class="lineNum">    2019</span>              : </span>
<span id="L2020"><span class="lineNum">    2020</span>              : // BASIC_CONSTRAINTS_free releases memory associated with |bcons|.</span>
<span id="L2021"><span class="lineNum">    2021</span>              : OPENSSL_EXPORT void BASIC_CONSTRAINTS_free(BASIC_CONSTRAINTS *bcons);</span>
<span id="L2022"><span class="lineNum">    2022</span>              : </span>
<span id="L2023"><span class="lineNum">    2023</span>              : // d2i_BASIC_CONSTRAINTS parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L2024"><span class="lineNum">    2024</span>              : // BasicConstraints (RFC 5280), as described in |d2i_SAMPLE|.</span>
<span id="L2025"><span class="lineNum">    2025</span>              : OPENSSL_EXPORT BASIC_CONSTRAINTS *d2i_BASIC_CONSTRAINTS(BASIC_CONSTRAINTS **out,</span>
<span id="L2026"><span class="lineNum">    2026</span>              :                                                         const uint8_t **inp,</span>
<span id="L2027"><span class="lineNum">    2027</span>              :                                                         long len);</span>
<span id="L2028"><span class="lineNum">    2028</span>              : </span>
<span id="L2029"><span class="lineNum">    2029</span>              : // i2d_BASIC_CONSTRAINTS marshals |bcons| as a DER-encoded BasicConstraints (RFC</span>
<span id="L2030"><span class="lineNum">    2030</span>              : // 5280), as described in |i2d_SAMPLE|.</span>
<span id="L2031"><span class="lineNum">    2031</span>              : OPENSSL_EXPORT int i2d_BASIC_CONSTRAINTS(const BASIC_CONSTRAINTS *bcons,</span>
<span id="L2032"><span class="lineNum">    2032</span>              :                                          uint8_t **outp);</span>
<span id="L2033"><span class="lineNum">    2033</span>              : </span>
<span id="L2034"><span class="lineNum">    2034</span>              : </span>
<span id="L2035"><span class="lineNum">    2035</span>              : // Extended key usage.</span>
<span id="L2036"><span class="lineNum">    2036</span>              : //</span>
<span id="L2037"><span class="lineNum">    2037</span>              : // The extended key usage extension (RFC 5280, section 4.2.1.12) indicates the</span>
<span id="L2038"><span class="lineNum">    2038</span>              : // purposes of the certificate's public key. Such constraints are important to</span>
<span id="L2039"><span class="lineNum">    2039</span>              : // avoid cross-protocol attacks.</span>
<span id="L2040"><span class="lineNum">    2040</span>              : </span>
<span id="L2041"><span class="lineNum">    2041</span>              : typedef STACK_OF(ASN1_OBJECT) EXTENDED_KEY_USAGE;</span>
<span id="L2042"><span class="lineNum">    2042</span>              : </span>
<span id="L2043"><span class="lineNum">    2043</span>              : // EXTENDED_KEY_USAGE is an |ASN1_ITEM| whose ASN.1 type is ExtKeyUsageSyntax</span>
<span id="L2044"><span class="lineNum">    2044</span>              : // (RFC 5280) and C type is |STACK_OF(ASN1_OBJECT)*|, or |EXTENDED_KEY_USAGE*|.</span>
<span id="L2045"><span class="lineNum">    2045</span>              : DECLARE_ASN1_ITEM(EXTENDED_KEY_USAGE)</span>
<span id="L2046"><span class="lineNum">    2046</span>              : </span>
<span id="L2047"><span class="lineNum">    2047</span>              : // EXTENDED_KEY_USAGE_new returns a newly-allocated, empty |EXTENDED_KEY_USAGE|</span>
<span id="L2048"><span class="lineNum">    2048</span>              : // object, or NULL on error.</span>
<span id="L2049"><span class="lineNum">    2049</span>              : OPENSSL_EXPORT EXTENDED_KEY_USAGE *EXTENDED_KEY_USAGE_new(void);</span>
<span id="L2050"><span class="lineNum">    2050</span>              : </span>
<span id="L2051"><span class="lineNum">    2051</span>              : // EXTENDED_KEY_USAGE_free releases memory associated with |eku|.</span>
<span id="L2052"><span class="lineNum">    2052</span>              : OPENSSL_EXPORT void EXTENDED_KEY_USAGE_free(EXTENDED_KEY_USAGE *eku);</span>
<span id="L2053"><span class="lineNum">    2053</span>              : </span>
<span id="L2054"><span class="lineNum">    2054</span>              : // d2i_EXTENDED_KEY_USAGE parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L2055"><span class="lineNum">    2055</span>              : // ExtKeyUsageSyntax (RFC 5280), as described in |d2i_SAMPLE|.</span>
<span id="L2056"><span class="lineNum">    2056</span>              : OPENSSL_EXPORT EXTENDED_KEY_USAGE *d2i_EXTENDED_KEY_USAGE(</span>
<span id="L2057"><span class="lineNum">    2057</span>              :     EXTENDED_KEY_USAGE **out, const uint8_t **inp, long len);</span>
<span id="L2058"><span class="lineNum">    2058</span>              : </span>
<span id="L2059"><span class="lineNum">    2059</span>              : // i2d_EXTENDED_KEY_USAGE marshals |eku| as a DER-encoded ExtKeyUsageSyntax (RFC</span>
<span id="L2060"><span class="lineNum">    2060</span>              : // 5280), as described in |i2d_SAMPLE|.</span>
<span id="L2061"><span class="lineNum">    2061</span>              : OPENSSL_EXPORT int i2d_EXTENDED_KEY_USAGE(const EXTENDED_KEY_USAGE *eku,</span>
<span id="L2062"><span class="lineNum">    2062</span>              :                                           uint8_t **outp);</span>
<span id="L2063"><span class="lineNum">    2063</span>              : </span>
<span id="L2064"><span class="lineNum">    2064</span>              : </span>
<span id="L2065"><span class="lineNum">    2065</span>              : // General names.</span>
<span id="L2066"><span class="lineNum">    2066</span>              : //</span>
<span id="L2067"><span class="lineNum">    2067</span>              : // A |GENERAL_NAME| represents an X.509 GeneralName structure, defined in RFC</span>
<span id="L2068"><span class="lineNum">    2068</span>              : // 5280, Section 4.2.1.6. General names are distinct from names (|X509_NAME|). A</span>
<span id="L2069"><span class="lineNum">    2069</span>              : // general name is a CHOICE type which may contain one of several name types,</span>
<span id="L2070"><span class="lineNum">    2070</span>              : // most commonly a DNS name or an IP address. General names most commonly appear</span>
<span id="L2071"><span class="lineNum">    2071</span>              : // in the subject alternative name (SAN) extension, though they are also used in</span>
<span id="L2072"><span class="lineNum">    2072</span>              : // other extensions.</span>
<span id="L2073"><span class="lineNum">    2073</span>              : //</span>
<span id="L2074"><span class="lineNum">    2074</span>              : // Many extensions contain a SEQUENCE OF GeneralName, or GeneralNames, so</span>
<span id="L2075"><span class="lineNum">    2075</span>              : // |STACK_OF(GENERAL_NAME)| is defined and aliased to |GENERAL_NAMES|.</span>
<span id="L2076"><span class="lineNum">    2076</span>              : </span>
<span id="L2077"><span class="lineNum">    2077</span>              : typedef struct otherName_st {</span>
<span id="L2078"><span class="lineNum">    2078</span>              :   ASN1_OBJECT *type_id;</span>
<span id="L2079"><span class="lineNum">    2079</span>              :   ASN1_TYPE *value;</span>
<span id="L2080"><span class="lineNum">    2080</span>              : } OTHERNAME;</span>
<span id="L2081"><span class="lineNum">    2081</span>              : </span>
<span id="L2082"><span class="lineNum">    2082</span>              : typedef struct EDIPartyName_st {</span>
<span id="L2083"><span class="lineNum">    2083</span>              :   ASN1_STRING *nameAssigner;</span>
<span id="L2084"><span class="lineNum">    2084</span>              :   ASN1_STRING *partyName;</span>
<span id="L2085"><span class="lineNum">    2085</span>              : } EDIPARTYNAME;</span>
<span id="L2086"><span class="lineNum">    2086</span>              : </span>
<span id="L2087"><span class="lineNum">    2087</span>              : // GEN_* are constants for the |type| field of |GENERAL_NAME|, defined below.</span>
<span id="L2088"><span class="lineNum">    2088</span>              : #define GEN_OTHERNAME 0</span>
<span id="L2089"><span class="lineNum">    2089</span>              : #define GEN_EMAIL 1</span>
<span id="L2090"><span class="lineNum">    2090</span>              : #define GEN_DNS 2</span>
<span id="L2091"><span class="lineNum">    2091</span>              : #define GEN_X400 3</span>
<span id="L2092"><span class="lineNum">    2092</span>              : #define GEN_DIRNAME 4</span>
<span id="L2093"><span class="lineNum">    2093</span>              : #define GEN_EDIPARTY 5</span>
<span id="L2094"><span class="lineNum">    2094</span>              : #define GEN_URI 6</span>
<span id="L2095"><span class="lineNum">    2095</span>              : #define GEN_IPADD 7</span>
<span id="L2096"><span class="lineNum">    2096</span>              : #define GEN_RID 8</span>
<span id="L2097"><span class="lineNum">    2097</span>              : </span>
<span id="L2098"><span class="lineNum">    2098</span>              : // A GENERAL_NAME_st, aka |GENERAL_NAME|, represents an X.509 GeneralName. The</span>
<span id="L2099"><span class="lineNum">    2099</span>              : // |type| field determines which member of |d| is active. A |GENERAL_NAME| may</span>
<span id="L2100"><span class="lineNum">    2100</span>              : // also be empty, in which case |type| is -1 and |d| is NULL. Empty</span>
<span id="L2101"><span class="lineNum">    2101</span>              : // |GENERAL_NAME|s are invalid and will never be returned from the parser, but</span>
<span id="L2102"><span class="lineNum">    2102</span>              : // may be created temporarily, e.g. by |GENERAL_NAME_new|.</span>
<span id="L2103"><span class="lineNum">    2103</span>              : //</span>
<span id="L2104"><span class="lineNum">    2104</span>              : // WARNING: |type| and |d| must be kept consistent. An inconsistency will result</span>
<span id="L2105"><span class="lineNum">    2105</span>              : // in a potentially exploitable memory error.</span>
<span id="L2106"><span class="lineNum">    2106</span>              : struct GENERAL_NAME_st {</span>
<span id="L2107"><span class="lineNum">    2107</span>              :   int type;</span>
<span id="L2108"><span class="lineNum">    2108</span>              :   union {</span>
<span id="L2109"><span class="lineNum">    2109</span>              :     char *ptr;</span>
<span id="L2110"><span class="lineNum">    2110</span>              :     OTHERNAME *otherName;</span>
<span id="L2111"><span class="lineNum">    2111</span>              :     ASN1_IA5STRING *rfc822Name;</span>
<span id="L2112"><span class="lineNum">    2112</span>              :     ASN1_IA5STRING *dNSName;</span>
<span id="L2113"><span class="lineNum">    2113</span>              :     ASN1_STRING *x400Address;</span>
<span id="L2114"><span class="lineNum">    2114</span>              :     X509_NAME *directoryName;</span>
<span id="L2115"><span class="lineNum">    2115</span>              :     EDIPARTYNAME *ediPartyName;</span>
<span id="L2116"><span class="lineNum">    2116</span>              :     ASN1_IA5STRING *uniformResourceIdentifier;</span>
<span id="L2117"><span class="lineNum">    2117</span>              :     ASN1_OCTET_STRING *iPAddress;</span>
<span id="L2118"><span class="lineNum">    2118</span>              :     ASN1_OBJECT *registeredID;</span>
<span id="L2119"><span class="lineNum">    2119</span>              : </span>
<span id="L2120"><span class="lineNum">    2120</span>              :     // Old names</span>
<span id="L2121"><span class="lineNum">    2121</span>              :     ASN1_OCTET_STRING *ip;  // iPAddress</span>
<span id="L2122"><span class="lineNum">    2122</span>              :     X509_NAME *dirn;        // dirn</span>
<span id="L2123"><span class="lineNum">    2123</span>              :     ASN1_IA5STRING *ia5;    // rfc822Name, dNSName, uniformResourceIdentifier</span>
<span id="L2124"><span class="lineNum">    2124</span>              :     ASN1_OBJECT *rid;       // registeredID</span>
<span id="L2125"><span class="lineNum">    2125</span>              :   } d;</span>
<span id="L2126"><span class="lineNum">    2126</span>              : } /* GENERAL_NAME */;</span>
<span id="L2127"><span class="lineNum">    2127</span>              : </span>
<span id="L2128"><span class="lineNum">    2128</span>              : // GENERAL_NAME_new returns a new, empty |GENERAL_NAME|, or NULL on error.</span>
<span id="L2129"><span class="lineNum">    2129</span>              : OPENSSL_EXPORT GENERAL_NAME *GENERAL_NAME_new(void);</span>
<span id="L2130"><span class="lineNum">    2130</span>              : </span>
<span id="L2131"><span class="lineNum">    2131</span>              : // GENERAL_NAME_free releases memory associated with |gen|.</span>
<span id="L2132"><span class="lineNum">    2132</span>              : OPENSSL_EXPORT void GENERAL_NAME_free(GENERAL_NAME *gen);</span>
<span id="L2133"><span class="lineNum">    2133</span>              : </span>
<span id="L2134"><span class="lineNum">    2134</span>              : // d2i_GENERAL_NAME parses up to |len| bytes from |*inp| as a DER-encoded X.509</span>
<span id="L2135"><span class="lineNum">    2135</span>              : // GeneralName (RFC 5280), as described in |d2i_SAMPLE|.</span>
<span id="L2136"><span class="lineNum">    2136</span>              : OPENSSL_EXPORT GENERAL_NAME *d2i_GENERAL_NAME(GENERAL_NAME **out,</span>
<span id="L2137"><span class="lineNum">    2137</span>              :                                               const uint8_t **inp, long len);</span>
<span id="L2138"><span class="lineNum">    2138</span>              : </span>
<span id="L2139"><span class="lineNum">    2139</span>              : // i2d_GENERAL_NAME marshals |in| as a DER-encoded X.509 GeneralName (RFC 5280),</span>
<span id="L2140"><span class="lineNum">    2140</span>              : // as described in |i2d_SAMPLE|.</span>
<span id="L2141"><span class="lineNum">    2141</span>              : //</span>
<span id="L2142"><span class="lineNum">    2142</span>              : // TODO(https://crbug.com/boringssl/407): This function should be const and</span>
<span id="L2143"><span class="lineNum">    2143</span>              : // thread-safe but is currently neither in some cases, notably if |in| is an</span>
<span id="L2144"><span class="lineNum">    2144</span>              : // directoryName and the |X509_NAME| has been modified.</span>
<span id="L2145"><span class="lineNum">    2145</span>              : OPENSSL_EXPORT int i2d_GENERAL_NAME(GENERAL_NAME *in, uint8_t **outp);</span>
<span id="L2146"><span class="lineNum">    2146</span>              : </span>
<span id="L2147"><span class="lineNum">    2147</span>              : // GENERAL_NAME_dup returns a newly-allocated copy of |gen|, or NULL on error.</span>
<span id="L2148"><span class="lineNum">    2148</span>              : // This function works by serializing the structure, so it will fail if |gen| is</span>
<span id="L2149"><span class="lineNum">    2149</span>              : // empty.</span>
<span id="L2150"><span class="lineNum">    2150</span>              : //</span>
<span id="L2151"><span class="lineNum">    2151</span>              : // TODO(https://crbug.com/boringssl/407): This function should be const and</span>
<span id="L2152"><span class="lineNum">    2152</span>              : // thread-safe but is currently neither in some cases, notably if |gen| is an</span>
<span id="L2153"><span class="lineNum">    2153</span>              : // directoryName and the |X509_NAME| has been modified.</span>
<span id="L2154"><span class="lineNum">    2154</span>              : OPENSSL_EXPORT GENERAL_NAME *GENERAL_NAME_dup(GENERAL_NAME *gen);</span>
<span id="L2155"><span class="lineNum">    2155</span>              : </span>
<span id="L2156"><span class="lineNum">    2156</span>              : // GENERAL_NAMES_new returns a new, empty |GENERAL_NAMES|, or NULL on error.</span>
<span id="L2157"><span class="lineNum">    2157</span>              : OPENSSL_EXPORT GENERAL_NAMES *GENERAL_NAMES_new(void);</span>
<span id="L2158"><span class="lineNum">    2158</span>              : </span>
<span id="L2159"><span class="lineNum">    2159</span>              : // GENERAL_NAMES_free releases memory associated with |gens|.</span>
<span id="L2160"><span class="lineNum">    2160</span>              : OPENSSL_EXPORT void GENERAL_NAMES_free(GENERAL_NAMES *gens);</span>
<span id="L2161"><span class="lineNum">    2161</span>              : </span>
<span id="L2162"><span class="lineNum">    2162</span>              : // d2i_GENERAL_NAMES parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L2163"><span class="lineNum">    2163</span>              : // SEQUENCE OF GeneralName, as described in |d2i_SAMPLE|.</span>
<span id="L2164"><span class="lineNum">    2164</span>              : OPENSSL_EXPORT GENERAL_NAMES *d2i_GENERAL_NAMES(GENERAL_NAMES **out,</span>
<span id="L2165"><span class="lineNum">    2165</span>              :                                                 const uint8_t **inp, long len);</span>
<span id="L2166"><span class="lineNum">    2166</span>              : </span>
<span id="L2167"><span class="lineNum">    2167</span>              : // i2d_GENERAL_NAMES marshals |in| as a DER-encoded SEQUENCE OF GeneralName, as</span>
<span id="L2168"><span class="lineNum">    2168</span>              : // described in |i2d_SAMPLE|.</span>
<span id="L2169"><span class="lineNum">    2169</span>              : //</span>
<span id="L2170"><span class="lineNum">    2170</span>              : // TODO(https://crbug.com/boringssl/407): This function should be const and</span>
<span id="L2171"><span class="lineNum">    2171</span>              : // thread-safe but is currently neither in some cases, notably if some element</span>
<span id="L2172"><span class="lineNum">    2172</span>              : // of |in| is an directoryName and the |X509_NAME| has been modified.</span>
<span id="L2173"><span class="lineNum">    2173</span>              : OPENSSL_EXPORT int i2d_GENERAL_NAMES(GENERAL_NAMES *in, uint8_t **outp);</span>
<span id="L2174"><span class="lineNum">    2174</span>              : </span>
<span id="L2175"><span class="lineNum">    2175</span>              : // OTHERNAME_new returns a new, empty |OTHERNAME|, or NULL on error.</span>
<span id="L2176"><span class="lineNum">    2176</span>              : OPENSSL_EXPORT OTHERNAME *OTHERNAME_new(void);</span>
<span id="L2177"><span class="lineNum">    2177</span>              : </span>
<span id="L2178"><span class="lineNum">    2178</span>              : // OTHERNAME_free releases memory associated with |name|.</span>
<span id="L2179"><span class="lineNum">    2179</span>              : OPENSSL_EXPORT void OTHERNAME_free(OTHERNAME *name);</span>
<span id="L2180"><span class="lineNum">    2180</span>              : </span>
<span id="L2181"><span class="lineNum">    2181</span>              : // EDIPARTYNAME_new returns a new, empty |EDIPARTYNAME|, or NULL on error.</span>
<span id="L2182"><span class="lineNum">    2182</span>              : // EDIPartyName is rarely used in practice, so callers are unlikely to need this</span>
<span id="L2183"><span class="lineNum">    2183</span>              : // function.</span>
<span id="L2184"><span class="lineNum">    2184</span>              : OPENSSL_EXPORT EDIPARTYNAME *EDIPARTYNAME_new(void);</span>
<span id="L2185"><span class="lineNum">    2185</span>              : </span>
<span id="L2186"><span class="lineNum">    2186</span>              : // EDIPARTYNAME_free releases memory associated with |name|. EDIPartyName is</span>
<span id="L2187"><span class="lineNum">    2187</span>              : // rarely used in practice, so callers are unlikely to need this function.</span>
<span id="L2188"><span class="lineNum">    2188</span>              : OPENSSL_EXPORT void EDIPARTYNAME_free(EDIPARTYNAME *name);</span>
<span id="L2189"><span class="lineNum">    2189</span>              : </span>
<span id="L2190"><span class="lineNum">    2190</span>              : // GENERAL_NAME_set0_value set |gen|'s type and value to |type| and |value|.</span>
<span id="L2191"><span class="lineNum">    2191</span>              : // |type| must be a |GEN_*| constant and |value| must be an object of the</span>
<span id="L2192"><span class="lineNum">    2192</span>              : // corresponding type. |gen| takes ownership of |value|, so |value| must have</span>
<span id="L2193"><span class="lineNum">    2193</span>              : // been an allocated object.</span>
<span id="L2194"><span class="lineNum">    2194</span>              : //</span>
<span id="L2195"><span class="lineNum">    2195</span>              : // WARNING: |gen| must be empty (typically as returned from |GENERAL_NAME_new|)</span>
<span id="L2196"><span class="lineNum">    2196</span>              : // before calling this function. If |gen| already contained a value, the</span>
<span id="L2197"><span class="lineNum">    2197</span>              : // previous contents will be leaked.</span>
<span id="L2198"><span class="lineNum">    2198</span>              : OPENSSL_EXPORT void GENERAL_NAME_set0_value(GENERAL_NAME *gen, int type,</span>
<span id="L2199"><span class="lineNum">    2199</span>              :                                             void *value);</span>
<span id="L2200"><span class="lineNum">    2200</span>              : </span>
<span id="L2201"><span class="lineNum">    2201</span>              : // GENERAL_NAME_get0_value returns the in-memory representation of |gen|'s</span>
<span id="L2202"><span class="lineNum">    2202</span>              : // contents and, |out_type| is not NULL, sets |*out_type| to the type of |gen|,</span>
<span id="L2203"><span class="lineNum">    2203</span>              : // which will be a |GEN_*| constant. If |gen| is incomplete, the return value</span>
<span id="L2204"><span class="lineNum">    2204</span>              : // will be NULL and the type will be -1.</span>
<span id="L2205"><span class="lineNum">    2205</span>              : //</span>
<span id="L2206"><span class="lineNum">    2206</span>              : // WARNING: Casting the result of this function to the wrong type is a</span>
<span id="L2207"><span class="lineNum">    2207</span>              : // potentially exploitable memory error. Callers must check |gen|'s type, either</span>
<span id="L2208"><span class="lineNum">    2208</span>              : // via |*out_type| or checking |gen-&gt;type| directly, before inspecting the</span>
<span id="L2209"><span class="lineNum">    2209</span>              : // result.</span>
<span id="L2210"><span class="lineNum">    2210</span>              : //</span>
<span id="L2211"><span class="lineNum">    2211</span>              : // WARNING: This function is not const-correct. The return value should be</span>
<span id="L2212"><span class="lineNum">    2212</span>              : // const. Callers shoudl not mutate the returned object.</span>
<span id="L2213"><span class="lineNum">    2213</span>              : OPENSSL_EXPORT void *GENERAL_NAME_get0_value(const GENERAL_NAME *gen,</span>
<span id="L2214"><span class="lineNum">    2214</span>              :                                              int *out_type);</span>
<span id="L2215"><span class="lineNum">    2215</span>              : </span>
<span id="L2216"><span class="lineNum">    2216</span>              : // GENERAL_NAME_set0_othername sets |gen| to be an OtherName with type |oid| and</span>
<span id="L2217"><span class="lineNum">    2217</span>              : // value |value|. On success, it returns one and takes ownership of |oid| and</span>
<span id="L2218"><span class="lineNum">    2218</span>              : // |value|, which must be created in a way compatible with |ASN1_OBJECT_free|</span>
<span id="L2219"><span class="lineNum">    2219</span>              : // and |ASN1_TYPE_free|, respectively. On allocation failure, it returns zero.</span>
<span id="L2220"><span class="lineNum">    2220</span>              : // In the failure case, the caller retains ownership of |oid| and |value| and</span>
<span id="L2221"><span class="lineNum">    2221</span>              : // must release them when done.</span>
<span id="L2222"><span class="lineNum">    2222</span>              : //</span>
<span id="L2223"><span class="lineNum">    2223</span>              : // WARNING: |gen| must be empty (typically as returned from |GENERAL_NAME_new|)</span>
<span id="L2224"><span class="lineNum">    2224</span>              : // before calling this function. If |gen| already contained a value, the</span>
<span id="L2225"><span class="lineNum">    2225</span>              : // previously contents will be leaked.</span>
<span id="L2226"><span class="lineNum">    2226</span>              : OPENSSL_EXPORT int GENERAL_NAME_set0_othername(GENERAL_NAME *gen,</span>
<span id="L2227"><span class="lineNum">    2227</span>              :                                                ASN1_OBJECT *oid,</span>
<span id="L2228"><span class="lineNum">    2228</span>              :                                                ASN1_TYPE *value);</span>
<span id="L2229"><span class="lineNum">    2229</span>              : </span>
<span id="L2230"><span class="lineNum">    2230</span>              : // GENERAL_NAME_get0_otherName, if |gen| is an OtherName, sets |*out_oid| and</span>
<span id="L2231"><span class="lineNum">    2231</span>              : // |*out_value| to the OtherName's type-id and value, respectively, and returns</span>
<span id="L2232"><span class="lineNum">    2232</span>              : // one. If |gen| is not an OtherName, it returns zero and leaves |*out_oid| and</span>
<span id="L2233"><span class="lineNum">    2233</span>              : // |*out_value| unmodified. Either of |out_oid| or |out_value| may be NULL to</span>
<span id="L2234"><span class="lineNum">    2234</span>              : // ignore the value.</span>
<span id="L2235"><span class="lineNum">    2235</span>              : //</span>
<span id="L2236"><span class="lineNum">    2236</span>              : // WARNING: This function is not const-correct. |out_oid| and |out_value| are</span>
<span id="L2237"><span class="lineNum">    2237</span>              : // not const, but callers should not mutate the resulting objects.</span>
<span id="L2238"><span class="lineNum">    2238</span>              : OPENSSL_EXPORT int GENERAL_NAME_get0_otherName(const GENERAL_NAME *gen,</span>
<span id="L2239"><span class="lineNum">    2239</span>              :                                                ASN1_OBJECT **out_oid,</span>
<span id="L2240"><span class="lineNum">    2240</span>              :                                                ASN1_TYPE **out_value);</span>
<span id="L2241"><span class="lineNum">    2241</span>              : </span>
<span id="L2242"><span class="lineNum">    2242</span>              : </span>
<span id="L2243"><span class="lineNum">    2243</span>              : // Authority key identifier.</span>
<span id="L2244"><span class="lineNum">    2244</span>              : //</span>
<span id="L2245"><span class="lineNum">    2245</span>              : // The authority key identifier extension (RFC 5280, section 4.2.1.1) allows a</span>
<span id="L2246"><span class="lineNum">    2246</span>              : // certificate to more precisely identify its issuer. This is helpful when</span>
<span id="L2247"><span class="lineNum">    2247</span>              : // multiple certificates share a name. Only the keyIdentifier (|keyid| in</span>
<span id="L2248"><span class="lineNum">    2248</span>              : // |AUTHORITY_KEYID|) field is used in practice.</span>
<span id="L2249"><span class="lineNum">    2249</span>              : </span>
<span id="L2250"><span class="lineNum">    2250</span>              : // A AUTHORITY_KEYID_st, aka |AUTHORITY_KEYID|, represents an</span>
<span id="L2251"><span class="lineNum">    2251</span>              : // AuthorityKeyIdentifier structure (RFC 5280).</span>
<span id="L2252"><span class="lineNum">    2252</span>              : struct AUTHORITY_KEYID_st {</span>
<span id="L2253"><span class="lineNum">    2253</span>              :   ASN1_OCTET_STRING *keyid;</span>
<span id="L2254"><span class="lineNum">    2254</span>              :   GENERAL_NAMES *issuer;</span>
<span id="L2255"><span class="lineNum">    2255</span>              :   ASN1_INTEGER *serial;</span>
<span id="L2256"><span class="lineNum">    2256</span>              : } /* AUTHORITY_KEYID */;</span>
<span id="L2257"><span class="lineNum">    2257</span>              : </span>
<span id="L2258"><span class="lineNum">    2258</span>              : // AUTHORITY_KEYID is an |ASN1_ITEM| whose ASN.1 type is AuthorityKeyIdentifier</span>
<span id="L2259"><span class="lineNum">    2259</span>              : // (RFC 5280) and C type is |AUTHORITY_KEYID*|.</span>
<span id="L2260"><span class="lineNum">    2260</span>              : DECLARE_ASN1_ITEM(AUTHORITY_KEYID)</span>
<span id="L2261"><span class="lineNum">    2261</span>              : </span>
<span id="L2262"><span class="lineNum">    2262</span>              : // AUTHORITY_KEYID_new returns a newly-allocated, empty |AUTHORITY_KEYID|</span>
<span id="L2263"><span class="lineNum">    2263</span>              : // object, or NULL on error.</span>
<span id="L2264"><span class="lineNum">    2264</span>              : OPENSSL_EXPORT AUTHORITY_KEYID *AUTHORITY_KEYID_new(void);</span>
<span id="L2265"><span class="lineNum">    2265</span>              : </span>
<span id="L2266"><span class="lineNum">    2266</span>              : // AUTHORITY_KEYID_free releases memory associated with |akid|.</span>
<span id="L2267"><span class="lineNum">    2267</span>              : OPENSSL_EXPORT void AUTHORITY_KEYID_free(AUTHORITY_KEYID *akid);</span>
<span id="L2268"><span class="lineNum">    2268</span>              : </span>
<span id="L2269"><span class="lineNum">    2269</span>              : // d2i_AUTHORITY_KEYID parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L2270"><span class="lineNum">    2270</span>              : // AuthorityKeyIdentifier (RFC 5280), as described in |d2i_SAMPLE|.</span>
<span id="L2271"><span class="lineNum">    2271</span>              : OPENSSL_EXPORT AUTHORITY_KEYID *d2i_AUTHORITY_KEYID(AUTHORITY_KEYID **out,</span>
<span id="L2272"><span class="lineNum">    2272</span>              :                                                     const uint8_t **inp,</span>
<span id="L2273"><span class="lineNum">    2273</span>              :                                                     long len);</span>
<span id="L2274"><span class="lineNum">    2274</span>              : </span>
<span id="L2275"><span class="lineNum">    2275</span>              : // i2d_AUTHORITY_KEYID marshals |akid| as a DER-encoded AuthorityKeyIdentifier</span>
<span id="L2276"><span class="lineNum">    2276</span>              : // (RFC 5280), as described in |i2d_SAMPLE|.</span>
<span id="L2277"><span class="lineNum">    2277</span>              : //</span>
<span id="L2278"><span class="lineNum">    2278</span>              : // TODO(https://crbug.com/boringssl/407): |akid| is not const because it</span>
<span id="L2279"><span class="lineNum">    2279</span>              : // contains an |X509_NAME|.</span>
<span id="L2280"><span class="lineNum">    2280</span>              : OPENSSL_EXPORT int i2d_AUTHORITY_KEYID(AUTHORITY_KEYID *akid, uint8_t **outp);</span>
<span id="L2281"><span class="lineNum">    2281</span>              : </span>
<span id="L2282"><span class="lineNum">    2282</span>              : </span>
<span id="L2283"><span class="lineNum">    2283</span>              : // Name constraints.</span>
<span id="L2284"><span class="lineNum">    2284</span>              : //</span>
<span id="L2285"><span class="lineNum">    2285</span>              : // The name constraints extension (RFC 5280, section 4.2.1.10) constrains which</span>
<span id="L2286"><span class="lineNum">    2286</span>              : // names may be asserted by certificates issued by some CA. For example, a</span>
<span id="L2287"><span class="lineNum">    2287</span>              : // general CA may issue an intermediate certificate to the owner of example.com,</span>
<span id="L2288"><span class="lineNum">    2288</span>              : // but constrained to &quot;.example.com&quot;.</span>
<span id="L2289"><span class="lineNum">    2289</span>              : </span>
<span id="L2290"><span class="lineNum">    2290</span>              : // A GENERAL_SUBTREE represents a GeneralSubtree structure (RFC 5280).</span>
<span id="L2291"><span class="lineNum">    2291</span>              : typedef struct GENERAL_SUBTREE_st {</span>
<span id="L2292"><span class="lineNum">    2292</span>              :   GENERAL_NAME *base;</span>
<span id="L2293"><span class="lineNum">    2293</span>              :   ASN1_INTEGER *minimum;</span>
<span id="L2294"><span class="lineNum">    2294</span>              :   ASN1_INTEGER *maximum;</span>
<span id="L2295"><span class="lineNum">    2295</span>              : } GENERAL_SUBTREE;</span>
<span id="L2296"><span class="lineNum">    2296</span>              : </span>
<span id="L2297"><span class="lineNum">    2297</span>              : DEFINE_STACK_OF(GENERAL_SUBTREE)</span>
<span id="L2298"><span class="lineNum">    2298</span>              : </span>
<span id="L2299"><span class="lineNum">    2299</span>              : // GENERAL_SUBTREE_new returns a newly-allocated, empty |GENERAL_SUBTREE|</span>
<span id="L2300"><span class="lineNum">    2300</span>              : // object, or NULL on error.</span>
<span id="L2301"><span class="lineNum">    2301</span>              : OPENSSL_EXPORT GENERAL_SUBTREE *GENERAL_SUBTREE_new(void);</span>
<span id="L2302"><span class="lineNum">    2302</span>              : </span>
<span id="L2303"><span class="lineNum">    2303</span>              : // GENERAL_SUBTREE_free releases memory associated with |subtree|.</span>
<span id="L2304"><span class="lineNum">    2304</span>              : OPENSSL_EXPORT void GENERAL_SUBTREE_free(GENERAL_SUBTREE *subtree);</span>
<span id="L2305"><span class="lineNum">    2305</span>              : </span>
<span id="L2306"><span class="lineNum">    2306</span>              : // A NAME_CONSTRAINTS_st, aka |NAME_CONSTRAINTS|, represents a NameConstraints</span>
<span id="L2307"><span class="lineNum">    2307</span>              : // structure (RFC 5280).</span>
<span id="L2308"><span class="lineNum">    2308</span>              : struct NAME_CONSTRAINTS_st {</span>
<span id="L2309"><span class="lineNum">    2309</span>              :   STACK_OF(GENERAL_SUBTREE) *permittedSubtrees;</span>
<span id="L2310"><span class="lineNum">    2310</span>              :   STACK_OF(GENERAL_SUBTREE) *excludedSubtrees;</span>
<span id="L2311"><span class="lineNum">    2311</span>              : } /* NAME_CONSTRAINTS */;</span>
<span id="L2312"><span class="lineNum">    2312</span>              : </span>
<span id="L2313"><span class="lineNum">    2313</span>              : // NAME_CONSTRAINTS is an |ASN1_ITEM| whose ASN.1 type is NameConstraints (RFC</span>
<span id="L2314"><span class="lineNum">    2314</span>              : // 5280) and C type is |NAME_CONSTRAINTS*|.</span>
<span id="L2315"><span class="lineNum">    2315</span>              : DECLARE_ASN1_ITEM(NAME_CONSTRAINTS)</span>
<span id="L2316"><span class="lineNum">    2316</span>              : </span>
<span id="L2317"><span class="lineNum">    2317</span>              : // NAME_CONSTRAINTS_new returns a newly-allocated, empty |NAME_CONSTRAINTS|</span>
<span id="L2318"><span class="lineNum">    2318</span>              : // object, or NULL on error.</span>
<span id="L2319"><span class="lineNum">    2319</span>              : OPENSSL_EXPORT NAME_CONSTRAINTS *NAME_CONSTRAINTS_new(void);</span>
<span id="L2320"><span class="lineNum">    2320</span>              : </span>
<span id="L2321"><span class="lineNum">    2321</span>              : // NAME_CONSTRAINTS_free releases memory associated with |ncons|.</span>
<span id="L2322"><span class="lineNum">    2322</span>              : OPENSSL_EXPORT void NAME_CONSTRAINTS_free(NAME_CONSTRAINTS *ncons);</span>
<span id="L2323"><span class="lineNum">    2323</span>              : </span>
<span id="L2324"><span class="lineNum">    2324</span>              : </span>
<span id="L2325"><span class="lineNum">    2325</span>              : // Authority information access.</span>
<span id="L2326"><span class="lineNum">    2326</span>              : //</span>
<span id="L2327"><span class="lineNum">    2327</span>              : // The authority information access extension (RFC 5280, 4.2.2.1) describes</span>
<span id="L2328"><span class="lineNum">    2328</span>              : // where to obtain information about the issuer of a certificate. It is most</span>
<span id="L2329"><span class="lineNum">    2329</span>              : // commonly used with accessMethod values of id-ad-caIssuers and id-ad-ocsp, to</span>
<span id="L2330"><span class="lineNum">    2330</span>              : // indicate where to fetch the issuer certificate (if not provided in-band) and</span>
<span id="L2331"><span class="lineNum">    2331</span>              : // the issuer's OCSP responder, respectively.</span>
<span id="L2332"><span class="lineNum">    2332</span>              : </span>
<span id="L2333"><span class="lineNum">    2333</span>              : // An ACCESS_DESCRIPTION represents an AccessDescription structure (RFC 5280).</span>
<span id="L2334"><span class="lineNum">    2334</span>              : typedef struct ACCESS_DESCRIPTION_st {</span>
<span id="L2335"><span class="lineNum">    2335</span>              :   ASN1_OBJECT *method;</span>
<span id="L2336"><span class="lineNum">    2336</span>              :   GENERAL_NAME *location;</span>
<span id="L2337"><span class="lineNum">    2337</span>              : } ACCESS_DESCRIPTION;</span>
<span id="L2338"><span class="lineNum">    2338</span>              : </span>
<span id="L2339"><span class="lineNum">    2339</span>              : DEFINE_STACK_OF(ACCESS_DESCRIPTION)</span>
<span id="L2340"><span class="lineNum">    2340</span>              : </span>
<span id="L2341"><span class="lineNum">    2341</span>              : // ACCESS_DESCRIPTION_new returns a newly-allocated, empty |ACCESS_DESCRIPTION|</span>
<span id="L2342"><span class="lineNum">    2342</span>              : // object, or NULL on error.</span>
<span id="L2343"><span class="lineNum">    2343</span>              : OPENSSL_EXPORT ACCESS_DESCRIPTION *ACCESS_DESCRIPTION_new(void);</span>
<span id="L2344"><span class="lineNum">    2344</span>              : </span>
<span id="L2345"><span class="lineNum">    2345</span>              : // ACCESS_DESCRIPTION_free releases memory associated with |desc|.</span>
<span id="L2346"><span class="lineNum">    2346</span>              : OPENSSL_EXPORT void ACCESS_DESCRIPTION_free(ACCESS_DESCRIPTION *desc);</span>
<span id="L2347"><span class="lineNum">    2347</span>              : </span>
<span id="L2348"><span class="lineNum">    2348</span>              : typedef STACK_OF(ACCESS_DESCRIPTION) AUTHORITY_INFO_ACCESS;</span>
<span id="L2349"><span class="lineNum">    2349</span>              : </span>
<span id="L2350"><span class="lineNum">    2350</span>              : // AUTHORITY_INFO_ACCESS is an |ASN1_ITEM| whose ASN.1 type is</span>
<span id="L2351"><span class="lineNum">    2351</span>              : // AuthorityInfoAccessSyntax (RFC 5280) and C type is</span>
<span id="L2352"><span class="lineNum">    2352</span>              : // |STACK_OF(ACCESS_DESCRIPTION)*|, or |AUTHORITY_INFO_ACCESS*|.</span>
<span id="L2353"><span class="lineNum">    2353</span>              : DECLARE_ASN1_ITEM(AUTHORITY_INFO_ACCESS)</span>
<span id="L2354"><span class="lineNum">    2354</span>              : </span>
<span id="L2355"><span class="lineNum">    2355</span>              : // AUTHORITY_INFO_ACCESS_new returns a newly-allocated, empty</span>
<span id="L2356"><span class="lineNum">    2356</span>              : // |AUTHORITY_INFO_ACCESS| object, or NULL on error.</span>
<span id="L2357"><span class="lineNum">    2357</span>              : OPENSSL_EXPORT AUTHORITY_INFO_ACCESS *AUTHORITY_INFO_ACCESS_new(void);</span>
<span id="L2358"><span class="lineNum">    2358</span>              : </span>
<span id="L2359"><span class="lineNum">    2359</span>              : // AUTHORITY_INFO_ACCESS_free releases memory associated with |aia|.</span>
<span id="L2360"><span class="lineNum">    2360</span>              : OPENSSL_EXPORT void AUTHORITY_INFO_ACCESS_free(AUTHORITY_INFO_ACCESS *aia);</span>
<span id="L2361"><span class="lineNum">    2361</span>              : </span>
<span id="L2362"><span class="lineNum">    2362</span>              : // d2i_AUTHORITY_INFO_ACCESS parses up to |len| bytes from |*inp| as a</span>
<span id="L2363"><span class="lineNum">    2363</span>              : // DER-encoded AuthorityInfoAccessSyntax (RFC 5280), as described in</span>
<span id="L2364"><span class="lineNum">    2364</span>              : // |d2i_SAMPLE|.</span>
<span id="L2365"><span class="lineNum">    2365</span>              : OPENSSL_EXPORT AUTHORITY_INFO_ACCESS *d2i_AUTHORITY_INFO_ACCESS(</span>
<span id="L2366"><span class="lineNum">    2366</span>              :     AUTHORITY_INFO_ACCESS **out, const uint8_t **inp, long len);</span>
<span id="L2367"><span class="lineNum">    2367</span>              : </span>
<span id="L2368"><span class="lineNum">    2368</span>              : // i2d_AUTHORITY_INFO_ACCESS marshals |aia| as a DER-encoded</span>
<span id="L2369"><span class="lineNum">    2369</span>              : // AuthorityInfoAccessSyntax (RFC 5280), as described in |i2d_SAMPLE|.</span>
<span id="L2370"><span class="lineNum">    2370</span>              : //</span>
<span id="L2371"><span class="lineNum">    2371</span>              : // TODO(https://crbug.com/boringssl/407): |aia| is not const because it</span>
<span id="L2372"><span class="lineNum">    2372</span>              : // contains an |X509_NAME|.</span>
<span id="L2373"><span class="lineNum">    2373</span>              : OPENSSL_EXPORT int i2d_AUTHORITY_INFO_ACCESS(AUTHORITY_INFO_ACCESS *aia,</span>
<span id="L2374"><span class="lineNum">    2374</span>              :                                              uint8_t **outp);</span>
<span id="L2375"><span class="lineNum">    2375</span>              : </span>
<span id="L2376"><span class="lineNum">    2376</span>              : </span>
<span id="L2377"><span class="lineNum">    2377</span>              : // CRL distribution points.</span>
<span id="L2378"><span class="lineNum">    2378</span>              : //</span>
<span id="L2379"><span class="lineNum">    2379</span>              : // The CRL distribution points extension (RFC 5280, 4.2.1.13) indicates where to</span>
<span id="L2380"><span class="lineNum">    2380</span>              : // fetch a certificate issuer's CRL. The corresponding issuing distribution</span>
<span id="L2381"><span class="lineNum">    2381</span>              : // point CRL extension (RFC 5280, section 5.2.5) matches against this extension.</span>
<span id="L2382"><span class="lineNum">    2382</span>              : </span>
<span id="L2383"><span class="lineNum">    2383</span>              : // A DIST_POINT_NAME represents a DistributionPointName structure (RFC 5280).</span>
<span id="L2384"><span class="lineNum">    2384</span>              : // The |name| field contains the CHOICE value and is determined by |type|. If</span>
<span id="L2385"><span class="lineNum">    2385</span>              : // |type| is zero, |name| must be a |fullname|. If |type| is one, |name| must be</span>
<span id="L2386"><span class="lineNum">    2386</span>              : // a |relativename|.</span>
<span id="L2387"><span class="lineNum">    2387</span>              : //</span>
<span id="L2388"><span class="lineNum">    2388</span>              : // WARNING: |type| and |name| must be kept consistent. An inconsistency will</span>
<span id="L2389"><span class="lineNum">    2389</span>              : // result in a potentially exploitable memory error.</span>
<span id="L2390"><span class="lineNum">    2390</span>              : typedef struct DIST_POINT_NAME_st {</span>
<span id="L2391"><span class="lineNum">    2391</span>              :   int type;</span>
<span id="L2392"><span class="lineNum">    2392</span>              :   union {</span>
<span id="L2393"><span class="lineNum">    2393</span>              :     GENERAL_NAMES *fullname;</span>
<span id="L2394"><span class="lineNum">    2394</span>              :     STACK_OF(X509_NAME_ENTRY) *relativename;</span>
<span id="L2395"><span class="lineNum">    2395</span>              :   } name;</span>
<span id="L2396"><span class="lineNum">    2396</span>              :   // If relativename then this contains the full distribution point name</span>
<span id="L2397"><span class="lineNum">    2397</span>              :   X509_NAME *dpname;</span>
<span id="L2398"><span class="lineNum">    2398</span>              : } DIST_POINT_NAME;</span>
<span id="L2399"><span class="lineNum">    2399</span>              : </span>
<span id="L2400"><span class="lineNum">    2400</span>              : // DIST_POINT_NAME_new returns a newly-allocated, empty |DIST_POINT_NAME|</span>
<span id="L2401"><span class="lineNum">    2401</span>              : // object, or NULL on error.</span>
<span id="L2402"><span class="lineNum">    2402</span>              : OPENSSL_EXPORT DIST_POINT_NAME *DIST_POINT_NAME_new(void);</span>
<span id="L2403"><span class="lineNum">    2403</span>              : </span>
<span id="L2404"><span class="lineNum">    2404</span>              : // DIST_POINT_NAME_free releases memory associated with |name|.</span>
<span id="L2405"><span class="lineNum">    2405</span>              : OPENSSL_EXPORT void DIST_POINT_NAME_free(DIST_POINT_NAME *name);</span>
<span id="L2406"><span class="lineNum">    2406</span>              : </span>
<span id="L2407"><span class="lineNum">    2407</span>              : // A DIST_POINT_st, aka |DIST_POINT|, represents a DistributionPoint structure</span>
<span id="L2408"><span class="lineNum">    2408</span>              : // (RFC 5280).</span>
<span id="L2409"><span class="lineNum">    2409</span>              : struct DIST_POINT_st {</span>
<span id="L2410"><span class="lineNum">    2410</span>              :   DIST_POINT_NAME *distpoint;</span>
<span id="L2411"><span class="lineNum">    2411</span>              :   ASN1_BIT_STRING *reasons;</span>
<span id="L2412"><span class="lineNum">    2412</span>              :   GENERAL_NAMES *CRLissuer;</span>
<span id="L2413"><span class="lineNum">    2413</span>              : } /* DIST_POINT */;</span>
<span id="L2414"><span class="lineNum">    2414</span>              : </span>
<span id="L2415"><span class="lineNum">    2415</span>              : DEFINE_STACK_OF(DIST_POINT)</span>
<span id="L2416"><span class="lineNum">    2416</span>              : </span>
<span id="L2417"><span class="lineNum">    2417</span>              : // DIST_POINT_new returns a newly-allocated, empty |DIST_POINT| object, or NULL</span>
<span id="L2418"><span class="lineNum">    2418</span>              : // on error.</span>
<span id="L2419"><span class="lineNum">    2419</span>              : OPENSSL_EXPORT DIST_POINT *DIST_POINT_new(void);</span>
<span id="L2420"><span class="lineNum">    2420</span>              : </span>
<span id="L2421"><span class="lineNum">    2421</span>              : // DIST_POINT_free releases memory associated with |dp|.</span>
<span id="L2422"><span class="lineNum">    2422</span>              : OPENSSL_EXPORT void DIST_POINT_free(DIST_POINT *dp);</span>
<span id="L2423"><span class="lineNum">    2423</span>              : </span>
<span id="L2424"><span class="lineNum">    2424</span>              : typedef STACK_OF(DIST_POINT) CRL_DIST_POINTS;</span>
<span id="L2425"><span class="lineNum">    2425</span>              : </span>
<span id="L2426"><span class="lineNum">    2426</span>              : // CRL_DIST_POINTS is an |ASN1_ITEM| whose ASN.1 type is CRLDistributionPoints</span>
<span id="L2427"><span class="lineNum">    2427</span>              : // (RFC 5280) and C type is |CRL_DIST_POINTS*|.</span>
<span id="L2428"><span class="lineNum">    2428</span>              : DECLARE_ASN1_ITEM(CRL_DIST_POINTS)</span>
<span id="L2429"><span class="lineNum">    2429</span>              : </span>
<span id="L2430"><span class="lineNum">    2430</span>              : // CRL_DIST_POINTS_new returns a newly-allocated, empty |CRL_DIST_POINTS|</span>
<span id="L2431"><span class="lineNum">    2431</span>              : // object, or NULL on error.</span>
<span id="L2432"><span class="lineNum">    2432</span>              : OPENSSL_EXPORT CRL_DIST_POINTS *CRL_DIST_POINTS_new(void);</span>
<span id="L2433"><span class="lineNum">    2433</span>              : </span>
<span id="L2434"><span class="lineNum">    2434</span>              : // CRL_DIST_POINTS_free releases memory associated with |crldp|.</span>
<span id="L2435"><span class="lineNum">    2435</span>              : OPENSSL_EXPORT void CRL_DIST_POINTS_free(CRL_DIST_POINTS *crldp);</span>
<span id="L2436"><span class="lineNum">    2436</span>              : </span>
<span id="L2437"><span class="lineNum">    2437</span>              : // d2i_CRL_DIST_POINTS parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L2438"><span class="lineNum">    2438</span>              : // CRLDistributionPoints (RFC 5280), as described in |d2i_SAMPLE|.</span>
<span id="L2439"><span class="lineNum">    2439</span>              : OPENSSL_EXPORT CRL_DIST_POINTS *d2i_CRL_DIST_POINTS(CRL_DIST_POINTS **out,</span>
<span id="L2440"><span class="lineNum">    2440</span>              :                                                     const uint8_t **inp,</span>
<span id="L2441"><span class="lineNum">    2441</span>              :                                                     long len);</span>
<span id="L2442"><span class="lineNum">    2442</span>              : </span>
<span id="L2443"><span class="lineNum">    2443</span>              : // i2d_CRL_DIST_POINTS marshals |crldp| as a DER-encoded CRLDistributionPoints</span>
<span id="L2444"><span class="lineNum">    2444</span>              : // (RFC 5280), as described in |i2d_SAMPLE|.</span>
<span id="L2445"><span class="lineNum">    2445</span>              : //</span>
<span id="L2446"><span class="lineNum">    2446</span>              : // TODO(https://crbug.com/boringssl/407): |crldp| is not const because it</span>
<span id="L2447"><span class="lineNum">    2447</span>              : // contains an |X509_NAME|.</span>
<span id="L2448"><span class="lineNum">    2448</span>              : OPENSSL_EXPORT int i2d_CRL_DIST_POINTS(CRL_DIST_POINTS *crldp, uint8_t **outp);</span>
<span id="L2449"><span class="lineNum">    2449</span>              : </span>
<span id="L2450"><span class="lineNum">    2450</span>              : // A ISSUING_DIST_POINT_st, aka |ISSUING_DIST_POINT|, represents a</span>
<span id="L2451"><span class="lineNum">    2451</span>              : // IssuingDistributionPoint structure (RFC 5280).</span>
<span id="L2452"><span class="lineNum">    2452</span>              : struct ISSUING_DIST_POINT_st {</span>
<span id="L2453"><span class="lineNum">    2453</span>              :   DIST_POINT_NAME *distpoint;</span>
<span id="L2454"><span class="lineNum">    2454</span>              :   ASN1_BOOLEAN onlyuser;</span>
<span id="L2455"><span class="lineNum">    2455</span>              :   ASN1_BOOLEAN onlyCA;</span>
<span id="L2456"><span class="lineNum">    2456</span>              :   ASN1_BIT_STRING *onlysomereasons;</span>
<span id="L2457"><span class="lineNum">    2457</span>              :   ASN1_BOOLEAN indirectCRL;</span>
<span id="L2458"><span class="lineNum">    2458</span>              :   ASN1_BOOLEAN onlyattr;</span>
<span id="L2459"><span class="lineNum">    2459</span>              : } /* ISSUING_DIST_POINT */;</span>
<span id="L2460"><span class="lineNum">    2460</span>              : </span>
<span id="L2461"><span class="lineNum">    2461</span>              : // ISSUING_DIST_POINT is an |ASN1_ITEM| whose ASN.1 type is</span>
<span id="L2462"><span class="lineNum">    2462</span>              : // IssuingDistributionPoint (RFC 5280) and C type is |ISSUING_DIST_POINT*|.</span>
<span id="L2463"><span class="lineNum">    2463</span>              : DECLARE_ASN1_ITEM(ISSUING_DIST_POINT)</span>
<span id="L2464"><span class="lineNum">    2464</span>              : </span>
<span id="L2465"><span class="lineNum">    2465</span>              : // ISSUING_DIST_POINT_new returns a newly-allocated, empty |ISSUING_DIST_POINT|</span>
<span id="L2466"><span class="lineNum">    2466</span>              : // object, or NULL on error.</span>
<span id="L2467"><span class="lineNum">    2467</span>              : OPENSSL_EXPORT ISSUING_DIST_POINT *ISSUING_DIST_POINT_new(void);</span>
<span id="L2468"><span class="lineNum">    2468</span>              : </span>
<span id="L2469"><span class="lineNum">    2469</span>              : // ISSUING_DIST_POINT_free releases memory associated with |idp|.</span>
<span id="L2470"><span class="lineNum">    2470</span>              : OPENSSL_EXPORT void ISSUING_DIST_POINT_free(ISSUING_DIST_POINT *idp);</span>
<span id="L2471"><span class="lineNum">    2471</span>              : </span>
<span id="L2472"><span class="lineNum">    2472</span>              : // d2i_ISSUING_DIST_POINT parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L2473"><span class="lineNum">    2473</span>              : // IssuingDistributionPoint (RFC 5280), as described in |d2i_SAMPLE|.</span>
<span id="L2474"><span class="lineNum">    2474</span>              : OPENSSL_EXPORT ISSUING_DIST_POINT *d2i_ISSUING_DIST_POINT(</span>
<span id="L2475"><span class="lineNum">    2475</span>              :     ISSUING_DIST_POINT **out, const uint8_t **inp, long len);</span>
<span id="L2476"><span class="lineNum">    2476</span>              : </span>
<span id="L2477"><span class="lineNum">    2477</span>              : // i2d_ISSUING_DIST_POINT marshals |idp| as a DER-encoded</span>
<span id="L2478"><span class="lineNum">    2478</span>              : // IssuingDistributionPoint (RFC 5280), as described in |i2d_SAMPLE|.</span>
<span id="L2479"><span class="lineNum">    2479</span>              : //</span>
<span id="L2480"><span class="lineNum">    2480</span>              : // TODO(https://crbug.com/boringssl/407): |idp| is not const because it</span>
<span id="L2481"><span class="lineNum">    2481</span>              : // contains an |X509_NAME|.</span>
<span id="L2482"><span class="lineNum">    2482</span>              : OPENSSL_EXPORT int i2d_ISSUING_DIST_POINT(ISSUING_DIST_POINT *idp,</span>
<span id="L2483"><span class="lineNum">    2483</span>              :                                           uint8_t **outp);</span>
<span id="L2484"><span class="lineNum">    2484</span>              : </span>
<span id="L2485"><span class="lineNum">    2485</span>              : </span>
<span id="L2486"><span class="lineNum">    2486</span>              : // Certificate policies.</span>
<span id="L2487"><span class="lineNum">    2487</span>              : //</span>
<span id="L2488"><span class="lineNum">    2488</span>              : // The certificate policies extension (RFC 5280, section 4.2.1.4), along with a</span>
<span id="L2489"><span class="lineNum">    2489</span>              : // suite of related extensions determines the &quot;policies&quot; that apply to a</span>
<span id="L2490"><span class="lineNum">    2490</span>              : // certificate path. Evaluating these policies is extremely complex and has led</span>
<span id="L2491"><span class="lineNum">    2491</span>              : // to denial-of-service vulnerabilities in several X.509 implementations. See</span>
<span id="L2492"><span class="lineNum">    2492</span>              : // draft-ietf-lamps-x509-policy-graph.</span>
<span id="L2493"><span class="lineNum">    2493</span>              : //</span>
<span id="L2494"><span class="lineNum">    2494</span>              : // Do not use this mechanism.</span>
<span id="L2495"><span class="lineNum">    2495</span>              : </span>
<span id="L2496"><span class="lineNum">    2496</span>              : // A NOTICEREF represents a NoticeReference structure (RFC 5280).</span>
<span id="L2497"><span class="lineNum">    2497</span>              : typedef struct NOTICEREF_st {</span>
<span id="L2498"><span class="lineNum">    2498</span>              :   ASN1_STRING *organization;</span>
<span id="L2499"><span class="lineNum">    2499</span>              :   STACK_OF(ASN1_INTEGER) *noticenos;</span>
<span id="L2500"><span class="lineNum">    2500</span>              : } NOTICEREF;</span>
<span id="L2501"><span class="lineNum">    2501</span>              : </span>
<span id="L2502"><span class="lineNum">    2502</span>              : // NOTICEREF_new returns a newly-allocated, empty |NOTICEREF| object, or NULL</span>
<span id="L2503"><span class="lineNum">    2503</span>              : // on error.</span>
<span id="L2504"><span class="lineNum">    2504</span>              : OPENSSL_EXPORT NOTICEREF *NOTICEREF_new(void);</span>
<span id="L2505"><span class="lineNum">    2505</span>              : </span>
<span id="L2506"><span class="lineNum">    2506</span>              : // NOTICEREF_free releases memory associated with |ref|.</span>
<span id="L2507"><span class="lineNum">    2507</span>              : OPENSSL_EXPORT void NOTICEREF_free(NOTICEREF *ref);</span>
<span id="L2508"><span class="lineNum">    2508</span>              : </span>
<span id="L2509"><span class="lineNum">    2509</span>              : // A USERNOTICE represents a UserNotice structure (RFC 5280).</span>
<span id="L2510"><span class="lineNum">    2510</span>              : typedef struct USERNOTICE_st {</span>
<span id="L2511"><span class="lineNum">    2511</span>              :   NOTICEREF *noticeref;</span>
<span id="L2512"><span class="lineNum">    2512</span>              :   ASN1_STRING *exptext;</span>
<span id="L2513"><span class="lineNum">    2513</span>              : } USERNOTICE;</span>
<span id="L2514"><span class="lineNum">    2514</span>              : </span>
<span id="L2515"><span class="lineNum">    2515</span>              : // USERNOTICE_new returns a newly-allocated, empty |USERNOTICE| object, or NULL</span>
<span id="L2516"><span class="lineNum">    2516</span>              : // on error.</span>
<span id="L2517"><span class="lineNum">    2517</span>              : OPENSSL_EXPORT USERNOTICE *USERNOTICE_new(void);</span>
<span id="L2518"><span class="lineNum">    2518</span>              : </span>
<span id="L2519"><span class="lineNum">    2519</span>              : // USERNOTICE_free releases memory associated with |notice|.</span>
<span id="L2520"><span class="lineNum">    2520</span>              : OPENSSL_EXPORT void USERNOTICE_free(USERNOTICE *notice);</span>
<span id="L2521"><span class="lineNum">    2521</span>              : </span>
<span id="L2522"><span class="lineNum">    2522</span>              : // A POLICYQUALINFO represents a PolicyQualifierInfo structure (RFC 5280). |d|</span>
<span id="L2523"><span class="lineNum">    2523</span>              : // contains the qualifier field of the PolicyQualifierInfo. Its type is</span>
<span id="L2524"><span class="lineNum">    2524</span>              : // determined by |pqualid|. If |pqualid| is |NID_id_qt_cps|, |d| must be</span>
<span id="L2525"><span class="lineNum">    2525</span>              : // |cpsuri|. If |pqualid| is |NID_id_qt_unotice|, |d| must be |usernotice|.</span>
<span id="L2526"><span class="lineNum">    2526</span>              : // Otherwise, |d| must be |other|.</span>
<span id="L2527"><span class="lineNum">    2527</span>              : //</span>
<span id="L2528"><span class="lineNum">    2528</span>              : // WARNING: |pqualid| and |d| must be kept consistent. An inconsistency will</span>
<span id="L2529"><span class="lineNum">    2529</span>              : // result in a potentially exploitable memory error.</span>
<span id="L2530"><span class="lineNum">    2530</span>              : typedef struct POLICYQUALINFO_st {</span>
<span id="L2531"><span class="lineNum">    2531</span>              :   ASN1_OBJECT *pqualid;</span>
<span id="L2532"><span class="lineNum">    2532</span>              :   union {</span>
<span id="L2533"><span class="lineNum">    2533</span>              :     ASN1_IA5STRING *cpsuri;</span>
<span id="L2534"><span class="lineNum">    2534</span>              :     USERNOTICE *usernotice;</span>
<span id="L2535"><span class="lineNum">    2535</span>              :     ASN1_TYPE *other;</span>
<span id="L2536"><span class="lineNum">    2536</span>              :   } d;</span>
<span id="L2537"><span class="lineNum">    2537</span>              : } POLICYQUALINFO;</span>
<span id="L2538"><span class="lineNum">    2538</span>              : </span>
<span id="L2539"><span class="lineNum">    2539</span>              : DEFINE_STACK_OF(POLICYQUALINFO)</span>
<span id="L2540"><span class="lineNum">    2540</span>              : </span>
<span id="L2541"><span class="lineNum">    2541</span>              : // POLICYQUALINFO_new returns a newly-allocated, empty |POLICYQUALINFO| object,</span>
<span id="L2542"><span class="lineNum">    2542</span>              : // or NULL on error.</span>
<span id="L2543"><span class="lineNum">    2543</span>              : OPENSSL_EXPORT POLICYQUALINFO *POLICYQUALINFO_new(void);</span>
<span id="L2544"><span class="lineNum">    2544</span>              : </span>
<span id="L2545"><span class="lineNum">    2545</span>              : // POLICYQUALINFO_free releases memory associated with |info|.</span>
<span id="L2546"><span class="lineNum">    2546</span>              : OPENSSL_EXPORT void POLICYQUALINFO_free(POLICYQUALINFO *info);</span>
<span id="L2547"><span class="lineNum">    2547</span>              : </span>
<span id="L2548"><span class="lineNum">    2548</span>              : // A POLICYINFO represents a PolicyInformation structure (RFC 5280).</span>
<span id="L2549"><span class="lineNum">    2549</span>              : typedef struct POLICYINFO_st {</span>
<span id="L2550"><span class="lineNum">    2550</span>              :   ASN1_OBJECT *policyid;</span>
<span id="L2551"><span class="lineNum">    2551</span>              :   STACK_OF(POLICYQUALINFO) *qualifiers;</span>
<span id="L2552"><span class="lineNum">    2552</span>              : } POLICYINFO;</span>
<span id="L2553"><span class="lineNum">    2553</span>              : </span>
<span id="L2554"><span class="lineNum">    2554</span>              : DEFINE_STACK_OF(POLICYINFO)</span>
<span id="L2555"><span class="lineNum">    2555</span>              : </span>
<span id="L2556"><span class="lineNum">    2556</span>              : // POLICYINFO_new returns a newly-allocated, empty |POLICYINFO| object, or NULL</span>
<span id="L2557"><span class="lineNum">    2557</span>              : // on error.</span>
<span id="L2558"><span class="lineNum">    2558</span>              : OPENSSL_EXPORT POLICYINFO *POLICYINFO_new(void);</span>
<span id="L2559"><span class="lineNum">    2559</span>              : </span>
<span id="L2560"><span class="lineNum">    2560</span>              : // POLICYINFO_free releases memory associated with |info|.</span>
<span id="L2561"><span class="lineNum">    2561</span>              : OPENSSL_EXPORT void POLICYINFO_free(POLICYINFO *info);</span>
<span id="L2562"><span class="lineNum">    2562</span>              : </span>
<span id="L2563"><span class="lineNum">    2563</span>              : typedef STACK_OF(POLICYINFO) CERTIFICATEPOLICIES;</span>
<span id="L2564"><span class="lineNum">    2564</span>              : </span>
<span id="L2565"><span class="lineNum">    2565</span>              : // CERTIFICATEPOLICIES is an |ASN1_ITEM| whose ASN.1 type is CertificatePolicies</span>
<span id="L2566"><span class="lineNum">    2566</span>              : // (RFC 5280) and C type is |STACK_OF(POLICYINFO)*|, or |CERTIFICATEPOLICIES*|.</span>
<span id="L2567"><span class="lineNum">    2567</span>              : DECLARE_ASN1_ITEM(CERTIFICATEPOLICIES)</span>
<span id="L2568"><span class="lineNum">    2568</span>              : </span>
<span id="L2569"><span class="lineNum">    2569</span>              : // CERTIFICATEPOLICIES_new returns a newly-allocated, empty</span>
<span id="L2570"><span class="lineNum">    2570</span>              : // |CERTIFICATEPOLICIES| object, or NULL on error.</span>
<span id="L2571"><span class="lineNum">    2571</span>              : OPENSSL_EXPORT CERTIFICATEPOLICIES *CERTIFICATEPOLICIES_new(void);</span>
<span id="L2572"><span class="lineNum">    2572</span>              : </span>
<span id="L2573"><span class="lineNum">    2573</span>              : // CERTIFICATEPOLICIES_free releases memory associated with |policies|.</span>
<span id="L2574"><span class="lineNum">    2574</span>              : OPENSSL_EXPORT void CERTIFICATEPOLICIES_free(CERTIFICATEPOLICIES *policies);</span>
<span id="L2575"><span class="lineNum">    2575</span>              : </span>
<span id="L2576"><span class="lineNum">    2576</span>              : // d2i_CERTIFICATEPOLICIES parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L2577"><span class="lineNum">    2577</span>              : // CertificatePolicies (RFC 5280), as described in |d2i_SAMPLE|.</span>
<span id="L2578"><span class="lineNum">    2578</span>              : OPENSSL_EXPORT CERTIFICATEPOLICIES *d2i_CERTIFICATEPOLICIES(</span>
<span id="L2579"><span class="lineNum">    2579</span>              :     CERTIFICATEPOLICIES **out, const uint8_t **inp, long len);</span>
<span id="L2580"><span class="lineNum">    2580</span>              : </span>
<span id="L2581"><span class="lineNum">    2581</span>              : // i2d_CERTIFICATEPOLICIES marshals |policies| as a DER-encoded</span>
<span id="L2582"><span class="lineNum">    2582</span>              : // CertificatePolicies (RFC 5280), as described in |i2d_SAMPLE|.</span>
<span id="L2583"><span class="lineNum">    2583</span>              : OPENSSL_EXPORT int i2d_CERTIFICATEPOLICIES(const CERTIFICATEPOLICIES *policies,</span>
<span id="L2584"><span class="lineNum">    2584</span>              :                                            uint8_t **outp);</span>
<span id="L2585"><span class="lineNum">    2585</span>              : </span>
<span id="L2586"><span class="lineNum">    2586</span>              : // A POLICY_MAPPING represents an individual element of a PolicyMappings</span>
<span id="L2587"><span class="lineNum">    2587</span>              : // structure (RFC 5280).</span>
<span id="L2588"><span class="lineNum">    2588</span>              : typedef struct POLICY_MAPPING_st {</span>
<span id="L2589"><span class="lineNum">    2589</span>              :   ASN1_OBJECT *issuerDomainPolicy;</span>
<span id="L2590"><span class="lineNum">    2590</span>              :   ASN1_OBJECT *subjectDomainPolicy;</span>
<span id="L2591"><span class="lineNum">    2591</span>              : } POLICY_MAPPING;</span>
<span id="L2592"><span class="lineNum">    2592</span>              : </span>
<span id="L2593"><span class="lineNum">    2593</span>              : DEFINE_STACK_OF(POLICY_MAPPING)</span>
<span id="L2594"><span class="lineNum">    2594</span>              : </span>
<span id="L2595"><span class="lineNum">    2595</span>              : // POLICY_MAPPING_new returns a newly-allocated, empty |POLICY_MAPPING| object,</span>
<span id="L2596"><span class="lineNum">    2596</span>              : // or NULL on error.</span>
<span id="L2597"><span class="lineNum">    2597</span>              : OPENSSL_EXPORT POLICY_MAPPING *POLICY_MAPPING_new(void);</span>
<span id="L2598"><span class="lineNum">    2598</span>              : </span>
<span id="L2599"><span class="lineNum">    2599</span>              : // POLICY_MAPPING_free releases memory associated with |mapping|.</span>
<span id="L2600"><span class="lineNum">    2600</span>              : OPENSSL_EXPORT void POLICY_MAPPING_free(POLICY_MAPPING *mapping);</span>
<span id="L2601"><span class="lineNum">    2601</span>              : </span>
<span id="L2602"><span class="lineNum">    2602</span>              : typedef STACK_OF(POLICY_MAPPING) POLICY_MAPPINGS;</span>
<span id="L2603"><span class="lineNum">    2603</span>              : </span>
<span id="L2604"><span class="lineNum">    2604</span>              : // POLICY_MAPPINGS is an |ASN1_ITEM| whose ASN.1 type is PolicyMappings (RFC</span>
<span id="L2605"><span class="lineNum">    2605</span>              : // 5280) and C type is |STACK_OF(POLICY_MAPPING)*|, or |POLICY_MAPPINGS*|.</span>
<span id="L2606"><span class="lineNum">    2606</span>              : DECLARE_ASN1_ITEM(POLICY_MAPPINGS)</span>
<span id="L2607"><span class="lineNum">    2607</span>              : </span>
<span id="L2608"><span class="lineNum">    2608</span>              : // A POLICY_CONSTRAINTS represents a PolicyConstraints structure (RFC 5280).</span>
<span id="L2609"><span class="lineNum">    2609</span>              : typedef struct POLICY_CONSTRAINTS_st {</span>
<span id="L2610"><span class="lineNum">    2610</span>              :   ASN1_INTEGER *requireExplicitPolicy;</span>
<span id="L2611"><span class="lineNum">    2611</span>              :   ASN1_INTEGER *inhibitPolicyMapping;</span>
<span id="L2612"><span class="lineNum">    2612</span>              : } POLICY_CONSTRAINTS;</span>
<span id="L2613"><span class="lineNum">    2613</span>              : </span>
<span id="L2614"><span class="lineNum">    2614</span>              : // POLICY_CONSTRAINTS is an |ASN1_ITEM| whose ASN.1 type is PolicyConstraints</span>
<span id="L2615"><span class="lineNum">    2615</span>              : // (RFC 5280) and C type is |POLICY_CONSTRAINTS*|.</span>
<span id="L2616"><span class="lineNum">    2616</span>              : DECLARE_ASN1_ITEM(POLICY_CONSTRAINTS)</span>
<span id="L2617"><span class="lineNum">    2617</span>              : </span>
<span id="L2618"><span class="lineNum">    2618</span>              : // POLICY_CONSTRAINTS_new returns a newly-allocated, empty |POLICY_CONSTRAINTS|</span>
<span id="L2619"><span class="lineNum">    2619</span>              : // object, or NULL on error.</span>
<span id="L2620"><span class="lineNum">    2620</span>              : OPENSSL_EXPORT POLICY_CONSTRAINTS *POLICY_CONSTRAINTS_new(void);</span>
<span id="L2621"><span class="lineNum">    2621</span>              : </span>
<span id="L2622"><span class="lineNum">    2622</span>              : // POLICY_CONSTRAINTS_free releases memory associated with |pcons|.</span>
<span id="L2623"><span class="lineNum">    2623</span>              : OPENSSL_EXPORT void POLICY_CONSTRAINTS_free(POLICY_CONSTRAINTS *pcons);</span>
<span id="L2624"><span class="lineNum">    2624</span>              : </span>
<span id="L2625"><span class="lineNum">    2625</span>              : </span>
<span id="L2626"><span class="lineNum">    2626</span>              : // Algorithm identifiers.</span>
<span id="L2627"><span class="lineNum">    2627</span>              : //</span>
<span id="L2628"><span class="lineNum">    2628</span>              : // An |X509_ALGOR| represents an AlgorithmIdentifier structure, used in X.509</span>
<span id="L2629"><span class="lineNum">    2629</span>              : // to represent signature algorithms and public key algorithms.</span>
<span id="L2630"><span class="lineNum">    2630</span>              : </span>
<span id="L2631"><span class="lineNum">    2631</span>              : DEFINE_STACK_OF(X509_ALGOR)</span>
<span id="L2632"><span class="lineNum">    2632</span>              : </span>
<span id="L2633"><span class="lineNum">    2633</span>              : // X509_ALGOR is an |ASN1_ITEM| whose ASN.1 type is AlgorithmIdentifier and C</span>
<span id="L2634"><span class="lineNum">    2634</span>              : // type is |X509_ALGOR*|.</span>
<span id="L2635"><span class="lineNum">    2635</span>              : DECLARE_ASN1_ITEM(X509_ALGOR)</span>
<span id="L2636"><span class="lineNum">    2636</span>              : </span>
<span id="L2637"><span class="lineNum">    2637</span>              : // X509_ALGOR_new returns a newly-allocated, empty |X509_ALGOR| object, or NULL</span>
<span id="L2638"><span class="lineNum">    2638</span>              : // on error.</span>
<span id="L2639"><span class="lineNum">    2639</span>              : OPENSSL_EXPORT X509_ALGOR *X509_ALGOR_new(void);</span>
<span id="L2640"><span class="lineNum">    2640</span>              : </span>
<span id="L2641"><span class="lineNum">    2641</span>              : // X509_ALGOR_dup returns a newly-allocated copy of |alg|, or NULL on error.</span>
<span id="L2642"><span class="lineNum">    2642</span>              : // This function works by serializing the structure, so if |alg| is incomplete,</span>
<span id="L2643"><span class="lineNum">    2643</span>              : // it may fail.</span>
<span id="L2644"><span class="lineNum">    2644</span>              : OPENSSL_EXPORT X509_ALGOR *X509_ALGOR_dup(const X509_ALGOR *alg);</span>
<span id="L2645"><span class="lineNum">    2645</span>              : </span>
<span id="L2646"><span class="lineNum">    2646</span>              : // X509_ALGOR_free releases memory associated with |alg|.</span>
<span id="L2647"><span class="lineNum">    2647</span>              : OPENSSL_EXPORT void X509_ALGOR_free(X509_ALGOR *alg);</span>
<span id="L2648"><span class="lineNum">    2648</span>              : </span>
<span id="L2649"><span class="lineNum">    2649</span>              : // d2i_X509_ALGOR parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L2650"><span class="lineNum">    2650</span>              : // AlgorithmIdentifier, as described in |d2i_SAMPLE|.</span>
<span id="L2651"><span class="lineNum">    2651</span>              : OPENSSL_EXPORT X509_ALGOR *d2i_X509_ALGOR(X509_ALGOR **out, const uint8_t **inp,</span>
<span id="L2652"><span class="lineNum">    2652</span>              :                                           long len);</span>
<span id="L2653"><span class="lineNum">    2653</span>              : </span>
<span id="L2654"><span class="lineNum">    2654</span>              : // i2d_X509_ALGOR marshals |alg| as a DER-encoded AlgorithmIdentifier, as</span>
<span id="L2655"><span class="lineNum">    2655</span>              : // described in |i2d_SAMPLE|.</span>
<span id="L2656"><span class="lineNum">    2656</span>              : OPENSSL_EXPORT int i2d_X509_ALGOR(const X509_ALGOR *alg, uint8_t **outp);</span>
<span id="L2657"><span class="lineNum">    2657</span>              : </span>
<span id="L2658"><span class="lineNum">    2658</span>              : // X509_ALGOR_set0 sets |alg| to an AlgorithmIdentifier with algorithm |obj| and</span>
<span id="L2659"><span class="lineNum">    2659</span>              : // parameter determined by |param_type| and |param_value|. It returns one on</span>
<span id="L2660"><span class="lineNum">    2660</span>              : // success and zero on error. This function takes ownership of |obj| and</span>
<span id="L2661"><span class="lineNum">    2661</span>              : // |param_value| on success.</span>
<span id="L2662"><span class="lineNum">    2662</span>              : //</span>
<span id="L2663"><span class="lineNum">    2663</span>              : // If |param_type| is |V_ASN1_UNDEF|, the parameter is omitted. If |param_type|</span>
<span id="L2664"><span class="lineNum">    2664</span>              : // is zero, the parameter is left unchanged. Otherwise, |param_type| and</span>
<span id="L2665"><span class="lineNum">    2665</span>              : // |param_value| are interpreted as in |ASN1_TYPE_set|.</span>
<span id="L2666"><span class="lineNum">    2666</span>              : //</span>
<span id="L2667"><span class="lineNum">    2667</span>              : // Note omitting the parameter (|V_ASN1_UNDEF|) and encoding an explicit NULL</span>
<span id="L2668"><span class="lineNum">    2668</span>              : // value (|V_ASN1_NULL|) are different. Some algorithms require one and some the</span>
<span id="L2669"><span class="lineNum">    2669</span>              : // other. Consult the relevant specification before calling this function. The</span>
<span id="L2670"><span class="lineNum">    2670</span>              : // correct parameter for an RSASSA-PKCS1-v1_5 signature is |V_ASN1_NULL|. The</span>
<span id="L2671"><span class="lineNum">    2671</span>              : // correct one for an ECDSA or Ed25519 signature is |V_ASN1_UNDEF|.</span>
<span id="L2672"><span class="lineNum">    2672</span>              : OPENSSL_EXPORT int X509_ALGOR_set0(X509_ALGOR *alg, ASN1_OBJECT *obj,</span>
<span id="L2673"><span class="lineNum">    2673</span>              :                                    int param_type, void *param_value);</span>
<span id="L2674"><span class="lineNum">    2674</span>              : </span>
<span id="L2675"><span class="lineNum">    2675</span>              : // X509_ALGOR_get0 sets |*out_obj| to the |alg|'s algorithm. If |alg|'s</span>
<span id="L2676"><span class="lineNum">    2676</span>              : // parameter is omitted, it sets |*out_param_type| and |*out_param_value| to</span>
<span id="L2677"><span class="lineNum">    2677</span>              : // |V_ASN1_UNDEF| and NULL. Otherwise, it sets |*out_param_type| and</span>
<span id="L2678"><span class="lineNum">    2678</span>              : // |*out_param_value| to the parameter, using the same representation as</span>
<span id="L2679"><span class="lineNum">    2679</span>              : // |ASN1_TYPE_set0|. See |ASN1_TYPE_set0| and |ASN1_TYPE| for details.</span>
<span id="L2680"><span class="lineNum">    2680</span>              : //</span>
<span id="L2681"><span class="lineNum">    2681</span>              : // Callers that require the parameter in serialized form should, after checking</span>
<span id="L2682"><span class="lineNum">    2682</span>              : // for |V_ASN1_UNDEF|, use |ASN1_TYPE_set1| and |d2i_ASN1_TYPE|, rather than</span>
<span id="L2683"><span class="lineNum">    2683</span>              : // inspecting |*out_param_value|.</span>
<span id="L2684"><span class="lineNum">    2684</span>              : //</span>
<span id="L2685"><span class="lineNum">    2685</span>              : // Each of |out_obj|, |out_param_type|, and |out_param_value| may be NULL to</span>
<span id="L2686"><span class="lineNum">    2686</span>              : // ignore the output. If |out_param_type| is NULL, |out_param_value| is ignored.</span>
<span id="L2687"><span class="lineNum">    2687</span>              : //</span>
<span id="L2688"><span class="lineNum">    2688</span>              : // WARNING: If |*out_param_type| is set to |V_ASN1_UNDEF|, OpenSSL and older</span>
<span id="L2689"><span class="lineNum">    2689</span>              : // revisions of BoringSSL leave |*out_param_value| unset rather than setting it</span>
<span id="L2690"><span class="lineNum">    2690</span>              : // to NULL. Callers that support both OpenSSL and BoringSSL should not assume</span>
<span id="L2691"><span class="lineNum">    2691</span>              : // |*out_param_value| is uniformly initialized.</span>
<span id="L2692"><span class="lineNum">    2692</span>              : OPENSSL_EXPORT void X509_ALGOR_get0(const ASN1_OBJECT **out_obj,</span>
<span id="L2693"><span class="lineNum">    2693</span>              :                                     int *out_param_type,</span>
<span id="L2694"><span class="lineNum">    2694</span>              :                                     const void **out_param_value,</span>
<span id="L2695"><span class="lineNum">    2695</span>              :                                     const X509_ALGOR *alg);</span>
<span id="L2696"><span class="lineNum">    2696</span>              : </span>
<span id="L2697"><span class="lineNum">    2697</span>              : // X509_ALGOR_set_md sets |alg| to the hash function |md|. Note this</span>
<span id="L2698"><span class="lineNum">    2698</span>              : // AlgorithmIdentifier represents the hash function itself, not a signature</span>
<span id="L2699"><span class="lineNum">    2699</span>              : // algorithm that uses |md|. It returns one on success and zero on error.</span>
<span id="L2700"><span class="lineNum">    2700</span>              : //</span>
<span id="L2701"><span class="lineNum">    2701</span>              : // Due to historical specification mistakes (see Section 2.1 of RFC 4055), the</span>
<span id="L2702"><span class="lineNum">    2702</span>              : // parameters field is sometimes omitted and sometimes a NULL value. When used</span>
<span id="L2703"><span class="lineNum">    2703</span>              : // in RSASSA-PSS and RSAES-OAEP, it should be a NULL value. In other contexts,</span>
<span id="L2704"><span class="lineNum">    2704</span>              : // the parameters should be omitted. This function assumes the caller is</span>
<span id="L2705"><span class="lineNum">    2705</span>              : // constructing a RSASSA-PSS or RSAES-OAEP AlgorithmIdentifier and includes a</span>
<span id="L2706"><span class="lineNum">    2706</span>              : // NULL parameter. This differs from OpenSSL's behavior.</span>
<span id="L2707"><span class="lineNum">    2707</span>              : //</span>
<span id="L2708"><span class="lineNum">    2708</span>              : // TODO(davidben): Rename this function, or perhaps just add a bespoke API for</span>
<span id="L2709"><span class="lineNum">    2709</span>              : // constructing PSS and move on.</span>
<span id="L2710"><span class="lineNum">    2710</span>              : OPENSSL_EXPORT int X509_ALGOR_set_md(X509_ALGOR *alg, const EVP_MD *md);</span>
<span id="L2711"><span class="lineNum">    2711</span>              : </span>
<span id="L2712"><span class="lineNum">    2712</span>              : // X509_ALGOR_cmp returns zero if |a| and |b| are equal, and some non-zero value</span>
<span id="L2713"><span class="lineNum">    2713</span>              : // otherwise. Note this function can only be used for equality checks, not an</span>
<span id="L2714"><span class="lineNum">    2714</span>              : // ordering.</span>
<span id="L2715"><span class="lineNum">    2715</span>              : OPENSSL_EXPORT int X509_ALGOR_cmp(const X509_ALGOR *a, const X509_ALGOR *b);</span>
<span id="L2716"><span class="lineNum">    2716</span>              : </span>
<span id="L2717"><span class="lineNum">    2717</span>              : </span>
<span id="L2718"><span class="lineNum">    2718</span>              : // Attributes.</span>
<span id="L2719"><span class="lineNum">    2719</span>              : //</span>
<span id="L2720"><span class="lineNum">    2720</span>              : // Unlike certificates and CRLs, CSRs use a separate Attribute structure (RFC</span>
<span id="L2721"><span class="lineNum">    2721</span>              : // 2985, RFC 2986) for extensibility. This is represented by the library as</span>
<span id="L2722"><span class="lineNum">    2722</span>              : // |X509_ATTRIBUTE|.</span>
<span id="L2723"><span class="lineNum">    2723</span>              : </span>
<span id="L2724"><span class="lineNum">    2724</span>              : DEFINE_STACK_OF(X509_ATTRIBUTE)</span>
<span id="L2725"><span class="lineNum">    2725</span>              : </span>
<span id="L2726"><span class="lineNum">    2726</span>              : // X509_ATTRIBUTE_new returns a newly-allocated, empty |X509_ATTRIBUTE| object,</span>
<span id="L2727"><span class="lineNum">    2727</span>              : // or NULL on error. |X509_ATTRIBUTE_set1_*| may be used to finish initializing</span>
<span id="L2728"><span class="lineNum">    2728</span>              : // it.</span>
<span id="L2729"><span class="lineNum">    2729</span>              : OPENSSL_EXPORT X509_ATTRIBUTE *X509_ATTRIBUTE_new(void);</span>
<span id="L2730"><span class="lineNum">    2730</span>              : </span>
<span id="L2731"><span class="lineNum">    2731</span>              : // X509_ATTRIBUTE_dup returns a newly-allocated copy of |attr|, or NULL on</span>
<span id="L2732"><span class="lineNum">    2732</span>              : // error. This function works by serializing the structure, so if |attr| is</span>
<span id="L2733"><span class="lineNum">    2733</span>              : // incomplete, it may fail.</span>
<span id="L2734"><span class="lineNum">    2734</span>              : OPENSSL_EXPORT X509_ATTRIBUTE *X509_ATTRIBUTE_dup(const X509_ATTRIBUTE *attr);</span>
<span id="L2735"><span class="lineNum">    2735</span>              : </span>
<span id="L2736"><span class="lineNum">    2736</span>              : // X509_ATTRIBUTE_free releases memory associated with |attr|.</span>
<span id="L2737"><span class="lineNum">    2737</span>              : OPENSSL_EXPORT void X509_ATTRIBUTE_free(X509_ATTRIBUTE *attr);</span>
<span id="L2738"><span class="lineNum">    2738</span>              : </span>
<span id="L2739"><span class="lineNum">    2739</span>              : // d2i_X509_ATTRIBUTE parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L2740"><span class="lineNum">    2740</span>              : // Attribute (RFC 2986), as described in |d2i_SAMPLE|.</span>
<span id="L2741"><span class="lineNum">    2741</span>              : OPENSSL_EXPORT X509_ATTRIBUTE *d2i_X509_ATTRIBUTE(X509_ATTRIBUTE **out,</span>
<span id="L2742"><span class="lineNum">    2742</span>              :                                                   const uint8_t **inp,</span>
<span id="L2743"><span class="lineNum">    2743</span>              :                                                   long len);</span>
<span id="L2744"><span class="lineNum">    2744</span>              : </span>
<span id="L2745"><span class="lineNum">    2745</span>              : // i2d_X509_ATTRIBUTE marshals |alg| as a DER-encoded Attribute (RFC 2986), as</span>
<span id="L2746"><span class="lineNum">    2746</span>              : // described in |i2d_SAMPLE|.</span>
<span id="L2747"><span class="lineNum">    2747</span>              : OPENSSL_EXPORT int i2d_X509_ATTRIBUTE(const X509_ATTRIBUTE *alg,</span>
<span id="L2748"><span class="lineNum">    2748</span>              :                                       uint8_t **outp);</span>
<span id="L2749"><span class="lineNum">    2749</span>              : </span>
<span id="L2750"><span class="lineNum">    2750</span>              : // X509_ATTRIBUTE_create returns a newly-allocated |X509_ATTRIBUTE|, or NULL on</span>
<span id="L2751"><span class="lineNum">    2751</span>              : // error. The attribute has type |nid| and contains a single value determined by</span>
<span id="L2752"><span class="lineNum">    2752</span>              : // |attrtype| and |value|, which are interpreted as in |ASN1_TYPE_set|. Note</span>
<span id="L2753"><span class="lineNum">    2753</span>              : // this function takes ownership of |value|.</span>
<span id="L2754"><span class="lineNum">    2754</span>              : OPENSSL_EXPORT X509_ATTRIBUTE *X509_ATTRIBUTE_create(int nid, int attrtype,</span>
<span id="L2755"><span class="lineNum">    2755</span>              :                                                      void *value);</span>
<span id="L2756"><span class="lineNum">    2756</span>              : </span>
<span id="L2757"><span class="lineNum">    2757</span>              : // X509_ATTRIBUTE_create_by_NID returns a newly-allocated |X509_ATTRIBUTE| of</span>
<span id="L2758"><span class="lineNum">    2758</span>              : // type |nid|, or NULL on error. The value is determined as in</span>
<span id="L2759"><span class="lineNum">    2759</span>              : // |X509_ATTRIBUTE_set1_data|.</span>
<span id="L2760"><span class="lineNum">    2760</span>              : //</span>
<span id="L2761"><span class="lineNum">    2761</span>              : // If |attr| is non-NULL, the resulting |X509_ATTRIBUTE| is also written to</span>
<span id="L2762"><span class="lineNum">    2762</span>              : // |*attr|. If |*attr| was non-NULL when the function was called, |*attr| is</span>
<span id="L2763"><span class="lineNum">    2763</span>              : // reused instead of creating a new object.</span>
<span id="L2764"><span class="lineNum">    2764</span>              : //</span>
<span id="L2765"><span class="lineNum">    2765</span>              : // WARNING: The interpretation of |attrtype|, |data|, and |len| is complex and</span>
<span id="L2766"><span class="lineNum">    2766</span>              : // error-prone. See |X509_ATTRIBUTE_set1_data| for details.</span>
<span id="L2767"><span class="lineNum">    2767</span>              : //</span>
<span id="L2768"><span class="lineNum">    2768</span>              : // WARNING: The object reuse form is deprecated and may be removed in the</span>
<span id="L2769"><span class="lineNum">    2769</span>              : // future. It also currently incorrectly appends to the reused object's value</span>
<span id="L2770"><span class="lineNum">    2770</span>              : // set rather than overwriting it.</span>
<span id="L2771"><span class="lineNum">    2771</span>              : OPENSSL_EXPORT X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_NID(</span>
<span id="L2772"><span class="lineNum">    2772</span>              :     X509_ATTRIBUTE **attr, int nid, int attrtype, const void *data, int len);</span>
<span id="L2773"><span class="lineNum">    2773</span>              : </span>
<span id="L2774"><span class="lineNum">    2774</span>              : // X509_ATTRIBUTE_create_by_OBJ behaves like |X509_ATTRIBUTE_create_by_NID|</span>
<span id="L2775"><span class="lineNum">    2775</span>              : // except the attribute's type is determined by |obj|.</span>
<span id="L2776"><span class="lineNum">    2776</span>              : OPENSSL_EXPORT X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_OBJ(</span>
<span id="L2777"><span class="lineNum">    2777</span>              :     X509_ATTRIBUTE **attr, const ASN1_OBJECT *obj, int attrtype,</span>
<span id="L2778"><span class="lineNum">    2778</span>              :     const void *data, int len);</span>
<span id="L2779"><span class="lineNum">    2779</span>              : </span>
<span id="L2780"><span class="lineNum">    2780</span>              : // X509_ATTRIBUTE_create_by_txt behaves like |X509_ATTRIBUTE_create_by_NID|</span>
<span id="L2781"><span class="lineNum">    2781</span>              : // except the attribute's type is determined by calling |OBJ_txt2obj| with</span>
<span id="L2782"><span class="lineNum">    2782</span>              : // |attrname|.</span>
<span id="L2783"><span class="lineNum">    2783</span>              : OPENSSL_EXPORT X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_txt(</span>
<span id="L2784"><span class="lineNum">    2784</span>              :     X509_ATTRIBUTE **attr, const char *attrname, int type,</span>
<span id="L2785"><span class="lineNum">    2785</span>              :     const unsigned char *bytes, int len);</span>
<span id="L2786"><span class="lineNum">    2786</span>              : </span>
<span id="L2787"><span class="lineNum">    2787</span>              : // X509_ATTRIBUTE_set1_object sets |attr|'s type to |obj|. It returns one on</span>
<span id="L2788"><span class="lineNum">    2788</span>              : // success and zero on error.</span>
<span id="L2789"><span class="lineNum">    2789</span>              : OPENSSL_EXPORT int X509_ATTRIBUTE_set1_object(X509_ATTRIBUTE *attr,</span>
<span id="L2790"><span class="lineNum">    2790</span>              :                                               const ASN1_OBJECT *obj);</span>
<span id="L2791"><span class="lineNum">    2791</span>              : </span>
<span id="L2792"><span class="lineNum">    2792</span>              : // X509_ATTRIBUTE_set1_data appends a value to |attr|'s value set and returns</span>
<span id="L2793"><span class="lineNum">    2793</span>              : // one on success or zero on error. The value is determined as follows:</span>
<span id="L2794"><span class="lineNum">    2794</span>              : //</span>
<span id="L2795"><span class="lineNum">    2795</span>              : // If |attrtype| is zero, this function returns one and does nothing. This form</span>
<span id="L2796"><span class="lineNum">    2796</span>              : // may be used when calling |X509_ATTRIBUTE_create_by_*| to create an attribute</span>
<span id="L2797"><span class="lineNum">    2797</span>              : // with an empty value set. Such attributes are invalid, but OpenSSL supports</span>
<span id="L2798"><span class="lineNum">    2798</span>              : // creating them.</span>
<span id="L2799"><span class="lineNum">    2799</span>              : //</span>
<span id="L2800"><span class="lineNum">    2800</span>              : // Otherwise, if |attrtype| is a |MBSTRING_*| constant, the value is an ASN.1</span>
<span id="L2801"><span class="lineNum">    2801</span>              : // string. The string is determined by decoding |len| bytes from |data| in the</span>
<span id="L2802"><span class="lineNum">    2802</span>              : // encoding specified by |attrtype|, and then re-encoding it in a form</span>
<span id="L2803"><span class="lineNum">    2803</span>              : // appropriate for |attr|'s type. If |len| is -1, |strlen(data)| is used</span>
<span id="L2804"><span class="lineNum">    2804</span>              : // instead. See |ASN1_STRING_set_by_NID| for details.</span>
<span id="L2805"><span class="lineNum">    2805</span>              : //</span>
<span id="L2806"><span class="lineNum">    2806</span>              : // Otherwise, if |len| is not -1, the value is an ASN.1 string. |attrtype| is an</span>
<span id="L2807"><span class="lineNum">    2807</span>              : // |ASN1_STRING| type value and the |len| bytes from |data| are copied as the</span>
<span id="L2808"><span class="lineNum">    2808</span>              : // type-specific representation of |ASN1_STRING|. See |ASN1_STRING| for details.</span>
<span id="L2809"><span class="lineNum">    2809</span>              : //</span>
<span id="L2810"><span class="lineNum">    2810</span>              : // Otherwise, if |len| is -1, the value is constructed by passing |attrtype| and</span>
<span id="L2811"><span class="lineNum">    2811</span>              : // |data| to |ASN1_TYPE_set1|. That is, |attrtype| is an |ASN1_TYPE| type value,</span>
<span id="L2812"><span class="lineNum">    2812</span>              : // and |data| is cast to the corresponding pointer type.</span>
<span id="L2813"><span class="lineNum">    2813</span>              : //</span>
<span id="L2814"><span class="lineNum">    2814</span>              : // WARNING: Despite the name, this function appends to |attr|'s value set,</span>
<span id="L2815"><span class="lineNum">    2815</span>              : // rather than overwriting it. To overwrite the value set, create a new</span>
<span id="L2816"><span class="lineNum">    2816</span>              : // |X509_ATTRIBUTE| with |X509_ATTRIBUTE_new|.</span>
<span id="L2817"><span class="lineNum">    2817</span>              : //</span>
<span id="L2818"><span class="lineNum">    2818</span>              : // WARNING: If using the |MBSTRING_*| form, pass a length rather than relying on</span>
<span id="L2819"><span class="lineNum">    2819</span>              : // |strlen|. In particular, |strlen| will not behave correctly if the input is</span>
<span id="L2820"><span class="lineNum">    2820</span>              : // |MBSTRING_BMP| or |MBSTRING_UNIV|.</span>
<span id="L2821"><span class="lineNum">    2821</span>              : //</span>
<span id="L2822"><span class="lineNum">    2822</span>              : // WARNING: This function currently misinterprets |V_ASN1_OTHER| as an</span>
<span id="L2823"><span class="lineNum">    2823</span>              : // |MBSTRING_*| constant. This matches OpenSSL but means it is impossible to</span>
<span id="L2824"><span class="lineNum">    2824</span>              : // construct a value with a non-universal tag.</span>
<span id="L2825"><span class="lineNum">    2825</span>              : OPENSSL_EXPORT int X509_ATTRIBUTE_set1_data(X509_ATTRIBUTE *attr, int attrtype,</span>
<span id="L2826"><span class="lineNum">    2826</span>              :                                             const void *data, int len);</span>
<span id="L2827"><span class="lineNum">    2827</span>              : </span>
<span id="L2828"><span class="lineNum">    2828</span>              : // X509_ATTRIBUTE_get0_data returns the |idx|th value of |attr| in a</span>
<span id="L2829"><span class="lineNum">    2829</span>              : // type-specific representation to |attrtype|, or NULL if out of bounds or the</span>
<span id="L2830"><span class="lineNum">    2830</span>              : // type does not match. |attrtype| is one of the type values in |ASN1_TYPE|. On</span>
<span id="L2831"><span class="lineNum">    2831</span>              : // match, the return value uses the same representation as |ASN1_TYPE_set0|. See</span>
<span id="L2832"><span class="lineNum">    2832</span>              : // |ASN1_TYPE| for details.</span>
<span id="L2833"><span class="lineNum">    2833</span>              : OPENSSL_EXPORT void *X509_ATTRIBUTE_get0_data(X509_ATTRIBUTE *attr, int idx,</span>
<span id="L2834"><span class="lineNum">    2834</span>              :                                               int attrtype, void *unused);</span>
<span id="L2835"><span class="lineNum">    2835</span>              : </span>
<span id="L2836"><span class="lineNum">    2836</span>              : // X509_ATTRIBUTE_count returns the number of values in |attr|.</span>
<span id="L2837"><span class="lineNum">    2837</span>              : OPENSSL_EXPORT int X509_ATTRIBUTE_count(const X509_ATTRIBUTE *attr);</span>
<span id="L2838"><span class="lineNum">    2838</span>              : </span>
<span id="L2839"><span class="lineNum">    2839</span>              : // X509_ATTRIBUTE_get0_object returns the type of |attr|.</span>
<span id="L2840"><span class="lineNum">    2840</span>              : OPENSSL_EXPORT ASN1_OBJECT *X509_ATTRIBUTE_get0_object(X509_ATTRIBUTE *attr);</span>
<span id="L2841"><span class="lineNum">    2841</span>              : </span>
<span id="L2842"><span class="lineNum">    2842</span>              : // X509_ATTRIBUTE_get0_type returns the |idx|th value in |attr|, or NULL if out</span>
<span id="L2843"><span class="lineNum">    2843</span>              : // of bounds. Note this function returns one of |attr|'s values, not the type.</span>
<span id="L2844"><span class="lineNum">    2844</span>              : OPENSSL_EXPORT ASN1_TYPE *X509_ATTRIBUTE_get0_type(X509_ATTRIBUTE *attr,</span>
<span id="L2845"><span class="lineNum">    2845</span>              :                                                    int idx);</span>
<span id="L2846"><span class="lineNum">    2846</span>              : </span>
<span id="L2847"><span class="lineNum">    2847</span>              : </span>
<span id="L2848"><span class="lineNum">    2848</span>              : // Certificate stores.</span>
<span id="L2849"><span class="lineNum">    2849</span>              : //</span>
<span id="L2850"><span class="lineNum">    2850</span>              : // An |X509_STORE| contains trusted certificates, CRLs, and verification</span>
<span id="L2851"><span class="lineNum">    2851</span>              : // parameters that are shared between multiple certificate verifications.</span>
<span id="L2852"><span class="lineNum">    2852</span>              : //</span>
<span id="L2853"><span class="lineNum">    2853</span>              : // Certificates in an |X509_STORE| are referred to as &quot;trusted certificates&quot;,</span>
<span id="L2854"><span class="lineNum">    2854</span>              : // but an individual certificate verification may not necessarily treat every</span>
<span id="L2855"><span class="lineNum">    2855</span>              : // trusted certificate as a trust anchor. See |X509_VERIFY_PARAM_set_trust| for</span>
<span id="L2856"><span class="lineNum">    2856</span>              : // details.</span>
<span id="L2857"><span class="lineNum">    2857</span>              : //</span>
<span id="L2858"><span class="lineNum">    2858</span>              : // WARNING: Although a trusted certificate which fails the</span>
<span id="L2859"><span class="lineNum">    2859</span>              : // |X509_VERIFY_PARAM_set_trust| check is functionally an untrusted</span>
<span id="L2860"><span class="lineNum">    2860</span>              : // intermediate certificate, callers should not rely on this to configure</span>
<span id="L2861"><span class="lineNum">    2861</span>              : // untrusted intermediates in an |X509_STORE|. The trust check is complex, so</span>
<span id="L2862"><span class="lineNum">    2862</span>              : // this risks inadvertently treating it as a trust anchor. Instead, configure</span>
<span id="L2863"><span class="lineNum">    2863</span>              : // untrusted intermediates with the |chain| parameter of |X509_STORE_CTX_init|.</span>
<span id="L2864"><span class="lineNum">    2864</span>              : //</span>
<span id="L2865"><span class="lineNum">    2865</span>              : // Certificates in |X509_STORE| may be specified in several ways:</span>
<span id="L2866"><span class="lineNum">    2866</span>              : // - Added by |X509_STORE_add_cert|.</span>
<span id="L2867"><span class="lineNum">    2867</span>              : // - Returned by an |X509_LOOKUP| added by |X509_STORE_add_lookup|.</span>
<span id="L2868"><span class="lineNum">    2868</span>              : //</span>
<span id="L2869"><span class="lineNum">    2869</span>              : // |X509_STORE|s are reference-counted and may be shared by certificate</span>
<span id="L2870"><span class="lineNum">    2870</span>              : // verifications running concurrently on multiple threads. However, an</span>
<span id="L2871"><span class="lineNum">    2871</span>              : // |X509_STORE|'s verification parameters may not be modified concurrently with</span>
<span id="L2872"><span class="lineNum">    2872</span>              : // certificate verification or other operations. Unless otherwise documented,</span>
<span id="L2873"><span class="lineNum">    2873</span>              : // functions which take const pointer may be used concurrently, while</span>
<span id="L2874"><span class="lineNum">    2874</span>              : // functions which take a non-const pointer may not. Callers that wish to modify</span>
<span id="L2875"><span class="lineNum">    2875</span>              : // verification parameters in a shared |X509_STORE| should instead modify</span>
<span id="L2876"><span class="lineNum">    2876</span>              : // |X509_STORE_CTX|s individually.</span>
<span id="L2877"><span class="lineNum">    2877</span>              : //</span>
<span id="L2878"><span class="lineNum">    2878</span>              : // Objects in an |X509_STORE| are represented as an |X509_OBJECT|. Some</span>
<span id="L2879"><span class="lineNum">    2879</span>              : // functions in this library return values with this type.</span>
<span id="L2880"><span class="lineNum">    2880</span>              : </span>
<span id="L2881"><span class="lineNum">    2881</span>              : // X509_STORE_new returns a newly-allocated |X509_STORE|, or NULL on error.</span>
<span id="L2882"><span class="lineNum">    2882</span>              : OPENSSL_EXPORT X509_STORE *X509_STORE_new(void);</span>
<span id="L2883"><span class="lineNum">    2883</span>              : </span>
<span id="L2884"><span class="lineNum">    2884</span>              : // X509_STORE_up_ref adds one to the reference count of |store| and returns one.</span>
<span id="L2885"><span class="lineNum">    2885</span>              : // Although |store| is not const, this function's use of |store| is thread-safe.</span>
<span id="L2886"><span class="lineNum">    2886</span>              : OPENSSL_EXPORT int X509_STORE_up_ref(X509_STORE *store);</span>
<span id="L2887"><span class="lineNum">    2887</span>              : </span>
<span id="L2888"><span class="lineNum">    2888</span>              : // X509_STORE_free releases memory associated with |store|.</span>
<span id="L2889"><span class="lineNum">    2889</span>              : OPENSSL_EXPORT void X509_STORE_free(X509_STORE *store);</span>
<span id="L2890"><span class="lineNum">    2890</span>              : </span>
<span id="L2891"><span class="lineNum">    2891</span>              : // X509_STORE_add_cert adds |x509| to |store| as a trusted certificate. It</span>
<span id="L2892"><span class="lineNum">    2892</span>              : // returns one on success and zero on error. This function internally increments</span>
<span id="L2893"><span class="lineNum">    2893</span>              : // |x509|'s reference count, so the caller retains ownership of |x509|.</span>
<span id="L2894"><span class="lineNum">    2894</span>              : //</span>
<span id="L2895"><span class="lineNum">    2895</span>              : // Certificates configured by this function are still subject to the checks</span>
<span id="L2896"><span class="lineNum">    2896</span>              : // described in |X509_VERIFY_PARAM_set_trust|.</span>
<span id="L2897"><span class="lineNum">    2897</span>              : //</span>
<span id="L2898"><span class="lineNum">    2898</span>              : // Although |store| is not const, this function's use of |store| is thread-safe.</span>
<span id="L2899"><span class="lineNum">    2899</span>              : // However, if this function is called concurrently with |X509_verify_cert|, it</span>
<span id="L2900"><span class="lineNum">    2900</span>              : // is a race condition whether |x509| is available for issuer lookups.</span>
<span id="L2901"><span class="lineNum">    2901</span>              : // Moreover, the result may differ for each issuer lookup performed by a single</span>
<span id="L2902"><span class="lineNum">    2902</span>              : // |X509_verify_cert| call.</span>
<span id="L2903"><span class="lineNum">    2903</span>              : OPENSSL_EXPORT int X509_STORE_add_cert(X509_STORE *store, X509 *x509);</span>
<span id="L2904"><span class="lineNum">    2904</span>              : </span>
<span id="L2905"><span class="lineNum">    2905</span>              : // X509_STORE_add_crl adds |crl| to |store|. It returns one on success and zero</span>
<span id="L2906"><span class="lineNum">    2906</span>              : // on error. This function internally increments |crl|'s reference count, so the</span>
<span id="L2907"><span class="lineNum">    2907</span>              : // caller retains ownership of |crl|. CRLs added in this way are candidates for</span>
<span id="L2908"><span class="lineNum">    2908</span>              : // CRL lookup when |X509_V_FLAG_CRL_CHECK| is set.</span>
<span id="L2909"><span class="lineNum">    2909</span>              : //</span>
<span id="L2910"><span class="lineNum">    2910</span>              : // Although |store| is not const, this function's use of |store| is thread-safe.</span>
<span id="L2911"><span class="lineNum">    2911</span>              : // However, if this function is called concurrently with |X509_verify_cert|, it</span>
<span id="L2912"><span class="lineNum">    2912</span>              : // is a race condition whether |crl| is available for CRL checks. Moreover, the</span>
<span id="L2913"><span class="lineNum">    2913</span>              : // result may differ for each CRL check performed by a single</span>
<span id="L2914"><span class="lineNum">    2914</span>              : // |X509_verify_cert| call.</span>
<span id="L2915"><span class="lineNum">    2915</span>              : //</span>
<span id="L2916"><span class="lineNum">    2916</span>              : // Note there are no supported APIs to remove CRLs from |store| once inserted.</span>
<span id="L2917"><span class="lineNum">    2917</span>              : // To vary the set of CRLs over time, callers should either create a new</span>
<span id="L2918"><span class="lineNum">    2918</span>              : // |X509_STORE| or configure CRLs on a per-verification basis with</span>
<span id="L2919"><span class="lineNum">    2919</span>              : // |X509_STORE_CTX_set0_crls|.</span>
<span id="L2920"><span class="lineNum">    2920</span>              : OPENSSL_EXPORT int X509_STORE_add_crl(X509_STORE *store, X509_CRL *crl);</span>
<span id="L2921"><span class="lineNum">    2921</span>              : </span>
<span id="L2922"><span class="lineNum">    2922</span>              : // X509_STORE_get0_param returns |store|'s verification parameters. This object</span>
<span id="L2923"><span class="lineNum">    2923</span>              : // is mutable and may be modified by the caller. For an individual certificate</span>
<span id="L2924"><span class="lineNum">    2924</span>              : // verification operation, |X509_STORE_CTX_init| initializes the</span>
<span id="L2925"><span class="lineNum">    2925</span>              : // |X509_STORE_CTX|'s parameters with these parameters.</span>
<span id="L2926"><span class="lineNum">    2926</span>              : //</span>
<span id="L2927"><span class="lineNum">    2927</span>              : // WARNING: |X509_STORE_CTX_init| applies some default parameters (as in</span>
<span id="L2928"><span class="lineNum">    2928</span>              : // |X509_VERIFY_PARAM_inherit|) after copying |store|'s parameters. This means</span>
<span id="L2929"><span class="lineNum">    2929</span>              : // it is impossible to leave some parameters unset at |store|. They must be</span>
<span id="L2930"><span class="lineNum">    2930</span>              : // explicitly unset after creating the |X509_STORE_CTX|.</span>
<span id="L2931"><span class="lineNum">    2931</span>              : //</span>
<span id="L2932"><span class="lineNum">    2932</span>              : // As of writing these late defaults are a depth limit (see</span>
<span id="L2933"><span class="lineNum">    2933</span>              : // |X509_VERIFY_PARAM_set_depth|) and the |X509_V_FLAG_TRUSTED_FIRST| flag. This</span>
<span id="L2934"><span class="lineNum">    2934</span>              : // warning does not apply if the parameters were set in |store|.</span>
<span id="L2935"><span class="lineNum">    2935</span>              : //</span>
<span id="L2936"><span class="lineNum">    2936</span>              : // TODO(crbug.com/boringssl/441): This behavior is very surprising. Can we</span>
<span id="L2937"><span class="lineNum">    2937</span>              : // remove this notion of late defaults? The unsettable value at |X509_STORE| is</span>
<span id="L2938"><span class="lineNum">    2938</span>              : // -1, which rejects everything but explicitly-trusted self-signed certificates.</span>
<span id="L2939"><span class="lineNum">    2939</span>              : // |X509_V_FLAG_TRUSTED_FIRST| is mostly a workaround for poor path-building.</span>
<span id="L2940"><span class="lineNum">    2940</span>              : OPENSSL_EXPORT X509_VERIFY_PARAM *X509_STORE_get0_param(X509_STORE *store);</span>
<span id="L2941"><span class="lineNum">    2941</span>              : </span>
<span id="L2942"><span class="lineNum">    2942</span>              : // X509_STORE_set1_param copies verification parameters from |param| as in</span>
<span id="L2943"><span class="lineNum">    2943</span>              : // |X509_VERIFY_PARAM_set1|. It returns one on success and zero on error.</span>
<span id="L2944"><span class="lineNum">    2944</span>              : OPENSSL_EXPORT int X509_STORE_set1_param(X509_STORE *store,</span>
<span id="L2945"><span class="lineNum">    2945</span>              :                                          const X509_VERIFY_PARAM *param);</span>
<span id="L2946"><span class="lineNum">    2946</span>              : </span>
<span id="L2947"><span class="lineNum">    2947</span>              : // X509_STORE_set_flags enables all values in |flags| in |store|'s verification</span>
<span id="L2948"><span class="lineNum">    2948</span>              : // flags. |flags| should be a combination of |X509_V_FLAG_*| constants.</span>
<span id="L2949"><span class="lineNum">    2949</span>              : //</span>
<span id="L2950"><span class="lineNum">    2950</span>              : // WARNING: These flags will be combined with default flags when copied to an</span>
<span id="L2951"><span class="lineNum">    2951</span>              : // |X509_STORE_CTX|. This means it is impossible to unset those defaults from</span>
<span id="L2952"><span class="lineNum">    2952</span>              : // the |X509_STORE|. See discussion in |X509_STORE_get0_param|.</span>
<span id="L2953"><span class="lineNum">    2953</span>              : OPENSSL_EXPORT int X509_STORE_set_flags(X509_STORE *store, unsigned long flags);</span>
<span id="L2954"><span class="lineNum">    2954</span>              : </span>
<span id="L2955"><span class="lineNum">    2955</span>              : // X509_STORE_set_depth configures |store| to, by default, limit certificate</span>
<span id="L2956"><span class="lineNum">    2956</span>              : // chains to |depth| intermediate certificates. This count excludes both the</span>
<span id="L2957"><span class="lineNum">    2957</span>              : // target certificate and the trust anchor (root certificate).</span>
<span id="L2958"><span class="lineNum">    2958</span>              : OPENSSL_EXPORT int X509_STORE_set_depth(X509_STORE *store, int depth);</span>
<span id="L2959"><span class="lineNum">    2959</span>              : </span>
<span id="L2960"><span class="lineNum">    2960</span>              : // X509_STORE_set_purpose configures the purpose check for |store|. See</span>
<span id="L2961"><span class="lineNum">    2961</span>              : // |X509_VERIFY_PARAM_set_purpose| for details.</span>
<span id="L2962"><span class="lineNum">    2962</span>              : OPENSSL_EXPORT int X509_STORE_set_purpose(X509_STORE *store, int purpose);</span>
<span id="L2963"><span class="lineNum">    2963</span>              : </span>
<span id="L2964"><span class="lineNum">    2964</span>              : // X509_STORE_set_trust configures the trust check for |store|. See</span>
<span id="L2965"><span class="lineNum">    2965</span>              : // |X509_VERIFY_PARAM_set_trust| for details.</span>
<span id="L2966"><span class="lineNum">    2966</span>              : OPENSSL_EXPORT int X509_STORE_set_trust(X509_STORE *store, int trust);</span>
<span id="L2967"><span class="lineNum">    2967</span>              : </span>
<span id="L2968"><span class="lineNum">    2968</span>              : // The following constants indicate the type of an |X509_OBJECT|.</span>
<span id="L2969"><span class="lineNum">    2969</span>              : #define X509_LU_NONE 0</span>
<span id="L2970"><span class="lineNum">    2970</span>              : #define X509_LU_X509 1</span>
<span id="L2971"><span class="lineNum">    2971</span>              : #define X509_LU_CRL 2</span>
<span id="L2972"><span class="lineNum">    2972</span>              : #define X509_LU_PKEY 3</span>
<span id="L2973"><span class="lineNum">    2973</span>              : </span>
<span id="L2974"><span class="lineNum">    2974</span>              : DEFINE_STACK_OF(X509_OBJECT)</span>
<span id="L2975"><span class="lineNum">    2975</span>              : </span>
<span id="L2976"><span class="lineNum">    2976</span>              : // X509_OBJECT_new returns a newly-allocated, empty |X509_OBJECT| or NULL on</span>
<span id="L2977"><span class="lineNum">    2977</span>              : // error.</span>
<span id="L2978"><span class="lineNum">    2978</span>              : OPENSSL_EXPORT X509_OBJECT *X509_OBJECT_new(void);</span>
<span id="L2979"><span class="lineNum">    2979</span>              : </span>
<span id="L2980"><span class="lineNum">    2980</span>              : // X509_OBJECT_free releases memory associated with |obj|.</span>
<span id="L2981"><span class="lineNum">    2981</span>              : OPENSSL_EXPORT void X509_OBJECT_free(X509_OBJECT *obj);</span>
<span id="L2982"><span class="lineNum">    2982</span>              : </span>
<span id="L2983"><span class="lineNum">    2983</span>              : // X509_OBJECT_get_type returns the type of |obj|, which will be one of the</span>
<span id="L2984"><span class="lineNum">    2984</span>              : // |X509_LU_*| constants.</span>
<span id="L2985"><span class="lineNum">    2985</span>              : OPENSSL_EXPORT int X509_OBJECT_get_type(const X509_OBJECT *obj);</span>
<span id="L2986"><span class="lineNum">    2986</span>              : </span>
<span id="L2987"><span class="lineNum">    2987</span>              : // X509_OBJECT_get0_X509 returns |obj| as a certificate, or NULL if |obj| is not</span>
<span id="L2988"><span class="lineNum">    2988</span>              : // a certificate.</span>
<span id="L2989"><span class="lineNum">    2989</span>              : OPENSSL_EXPORT X509 *X509_OBJECT_get0_X509(const X509_OBJECT *obj);</span>
<span id="L2990"><span class="lineNum">    2990</span>              : </span>
<span id="L2991"><span class="lineNum">    2991</span>              : // X509_STORE_get1_objects returns a newly-allocated stack containing the</span>
<span id="L2992"><span class="lineNum">    2992</span>              : // contents of |store|, or NULL on error. The caller must release the result</span>
<span id="L2993"><span class="lineNum">    2993</span>              : // with |sk_X509_OBJECT_pop_free| and |X509_OBJECT_free| when done.</span>
<span id="L2994"><span class="lineNum">    2994</span>              : //</span>
<span id="L2995"><span class="lineNum">    2995</span>              : // The result will include all certificates and CRLs added via</span>
<span id="L2996"><span class="lineNum">    2996</span>              : // |X509_STORE_add_cert| and |X509_STORE_add_crl|, as well as any cached objects</span>
<span id="L2997"><span class="lineNum">    2997</span>              : // added by |X509_LOOKUP_add_dir|. The last of these may change over time, as</span>
<span id="L2998"><span class="lineNum">    2998</span>              : // different objects are loaded from the filesystem. Callers should not depend</span>
<span id="L2999"><span class="lineNum">    2999</span>              : // on this caching behavior. The objects are returned in no particular order.</span>
<span id="L3000"><span class="lineNum">    3000</span>              : OPENSSL_EXPORT STACK_OF(X509_OBJECT) *X509_STORE_get1_objects(</span>
<span id="L3001"><span class="lineNum">    3001</span>              :     X509_STORE *store);</span>
<span id="L3002"><span class="lineNum">    3002</span>              : </span>
<span id="L3003"><span class="lineNum">    3003</span>              : </span>
<span id="L3004"><span class="lineNum">    3004</span>              : // Certificate verification.</span>
<span id="L3005"><span class="lineNum">    3005</span>              : //</span>
<span id="L3006"><span class="lineNum">    3006</span>              : // An |X509_STORE_CTX| object represents a single certificate verification</span>
<span id="L3007"><span class="lineNum">    3007</span>              : // operation. To verify a certificate chain, callers construct an</span>
<span id="L3008"><span class="lineNum">    3008</span>              : // |X509_STORE_CTX|, initialize it with |X509_STORE_CTX_init|, configure extra</span>
<span id="L3009"><span class="lineNum">    3009</span>              : // parameters with |X509_STORE_CTX_get0_param|, and call |X509_verify_cert|.</span>
<span id="L3010"><span class="lineNum">    3010</span>              : </span>
<span id="L3011"><span class="lineNum">    3011</span>              : // X509_STORE_CTX_new returns a newly-allocated, empty |X509_STORE_CTX|, or NULL</span>
<span id="L3012"><span class="lineNum">    3012</span>              : // on error.</span>
<span id="L3013"><span class="lineNum">    3013</span>              : OPENSSL_EXPORT X509_STORE_CTX *X509_STORE_CTX_new(void);</span>
<span id="L3014"><span class="lineNum">    3014</span>              : </span>
<span id="L3015"><span class="lineNum">    3015</span>              : // X509_STORE_CTX_free releases memory associated with |ctx|.</span>
<span id="L3016"><span class="lineNum">    3016</span>              : OPENSSL_EXPORT void X509_STORE_CTX_free(X509_STORE_CTX *ctx);</span>
<span id="L3017"><span class="lineNum">    3017</span>              : </span>
<span id="L3018"><span class="lineNum">    3018</span>              : // X509_STORE_CTX_init initializes |ctx| to verify |x509|, using trusted</span>
<span id="L3019"><span class="lineNum">    3019</span>              : // certificates and parameters in |store|. It returns one on success and zero on</span>
<span id="L3020"><span class="lineNum">    3020</span>              : // error. |chain| is a list of untrusted intermediate certificates to use in</span>
<span id="L3021"><span class="lineNum">    3021</span>              : // verification.</span>
<span id="L3022"><span class="lineNum">    3022</span>              : //</span>
<span id="L3023"><span class="lineNum">    3023</span>              : // |ctx| stores pointers to |store|, |x509|, and |chain|. Each of these objects</span>
<span id="L3024"><span class="lineNum">    3024</span>              : // must outlive |ctx| and may not be mutated for the duration of the certificate</span>
<span id="L3025"><span class="lineNum">    3025</span>              : // verification.</span>
<span id="L3026"><span class="lineNum">    3026</span>              : OPENSSL_EXPORT int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store,</span>
<span id="L3027"><span class="lineNum">    3027</span>              :                                        X509 *x509, STACK_OF(X509) *chain);</span>
<span id="L3028"><span class="lineNum">    3028</span>              : </span>
<span id="L3029"><span class="lineNum">    3029</span>              : // X509_verify_cert performs certifice verification with |ctx|, which must have</span>
<span id="L3030"><span class="lineNum">    3030</span>              : // been initialized with |X509_STORE_CTX_init|. It returns one on success and</span>
<span id="L3031"><span class="lineNum">    3031</span>              : // zero on error. On success, |X509_STORE_CTX_get0_chain| or</span>
<span id="L3032"><span class="lineNum">    3032</span>              : // |X509_STORE_CTX_get1_chain| may be used to return the verified certificate</span>
<span id="L3033"><span class="lineNum">    3033</span>              : // chain. On error, |X509_STORE_CTX_get_error| may be used to return additional</span>
<span id="L3034"><span class="lineNum">    3034</span>              : // error information.</span>
<span id="L3035"><span class="lineNum">    3035</span>              : //</span>
<span id="L3036"><span class="lineNum">    3036</span>              : // WARNING: Most failure conditions from this function do not use the error</span>
<span id="L3037"><span class="lineNum">    3037</span>              : // queue. Use |X509_STORE_CTX_get_error| to determine the cause of the error.</span>
<span id="L3038"><span class="lineNum">    3038</span>              : OPENSSL_EXPORT int X509_verify_cert(X509_STORE_CTX *ctx);</span>
<span id="L3039"><span class="lineNum">    3039</span>              : </span>
<span id="L3040"><span class="lineNum">    3040</span>              : // X509_STORE_CTX_get0_chain, after a successful |X509_verify_cert| call,</span>
<span id="L3041"><span class="lineNum">    3041</span>              : // returns the verified certificate chain. The chain begins with the leaf and</span>
<span id="L3042"><span class="lineNum">    3042</span>              : // ends with trust anchor.</span>
<span id="L3043"><span class="lineNum">    3043</span>              : //</span>
<span id="L3044"><span class="lineNum">    3044</span>              : // At other points, such as after a failed verification or during the deprecated</span>
<span id="L3045"><span class="lineNum">    3045</span>              : // verification callback, it returns the partial chain built so far. Callers</span>
<span id="L3046"><span class="lineNum">    3046</span>              : // should avoid relying on this as this exposes unstable library implementation</span>
<span id="L3047"><span class="lineNum">    3047</span>              : // details.</span>
<span id="L3048"><span class="lineNum">    3048</span>              : OPENSSL_EXPORT STACK_OF(X509) *X509_STORE_CTX_get0_chain(</span>
<span id="L3049"><span class="lineNum">    3049</span>              :     const X509_STORE_CTX *ctx);</span>
<span id="L3050"><span class="lineNum">    3050</span>              : </span>
<span id="L3051"><span class="lineNum">    3051</span>              : // X509_STORE_CTX_get1_chain behaves like |X509_STORE_CTX_get0_chain| but</span>
<span id="L3052"><span class="lineNum">    3052</span>              : // returns a newly-allocated |STACK_OF(X509)| containing the completed chain,</span>
<span id="L3053"><span class="lineNum">    3053</span>              : // with each certificate's reference count incremented. Callers must free the</span>
<span id="L3054"><span class="lineNum">    3054</span>              : // result with |sk_X509_pop_free| and |X509_free| when done.</span>
<span id="L3055"><span class="lineNum">    3055</span>              : OPENSSL_EXPORT STACK_OF(X509) *X509_STORE_CTX_get1_chain(</span>
<span id="L3056"><span class="lineNum">    3056</span>              :     const X509_STORE_CTX *ctx);</span>
<span id="L3057"><span class="lineNum">    3057</span>              : </span>
<span id="L3058"><span class="lineNum">    3058</span>              : // The following values are possible outputs of |X509_STORE_CTX_get_error|.</span>
<span id="L3059"><span class="lineNum">    3059</span>              : #define X509_V_OK 0</span>
<span id="L3060"><span class="lineNum">    3060</span>              : #define X509_V_ERR_UNSPECIFIED 1</span>
<span id="L3061"><span class="lineNum">    3061</span>              : #define X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT 2</span>
<span id="L3062"><span class="lineNum">    3062</span>              : #define X509_V_ERR_UNABLE_TO_GET_CRL 3</span>
<span id="L3063"><span class="lineNum">    3063</span>              : #define X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE 4</span>
<span id="L3064"><span class="lineNum">    3064</span>              : #define X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE 5</span>
<span id="L3065"><span class="lineNum">    3065</span>              : #define X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY 6</span>
<span id="L3066"><span class="lineNum">    3066</span>              : #define X509_V_ERR_CERT_SIGNATURE_FAILURE 7</span>
<span id="L3067"><span class="lineNum">    3067</span>              : #define X509_V_ERR_CRL_SIGNATURE_FAILURE 8</span>
<span id="L3068"><span class="lineNum">    3068</span>              : #define X509_V_ERR_CERT_NOT_YET_VALID 9</span>
<span id="L3069"><span class="lineNum">    3069</span>              : #define X509_V_ERR_CERT_HAS_EXPIRED 10</span>
<span id="L3070"><span class="lineNum">    3070</span>              : #define X509_V_ERR_CRL_NOT_YET_VALID 11</span>
<span id="L3071"><span class="lineNum">    3071</span>              : #define X509_V_ERR_CRL_HAS_EXPIRED 12</span>
<span id="L3072"><span class="lineNum">    3072</span>              : #define X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD 13</span>
<span id="L3073"><span class="lineNum">    3073</span>              : #define X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD 14</span>
<span id="L3074"><span class="lineNum">    3074</span>              : #define X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD 15</span>
<span id="L3075"><span class="lineNum">    3075</span>              : #define X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD 16</span>
<span id="L3076"><span class="lineNum">    3076</span>              : #define X509_V_ERR_OUT_OF_MEM 17</span>
<span id="L3077"><span class="lineNum">    3077</span>              : #define X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT 18</span>
<span id="L3078"><span class="lineNum">    3078</span>              : #define X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN 19</span>
<span id="L3079"><span class="lineNum">    3079</span>              : #define X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY 20</span>
<span id="L3080"><span class="lineNum">    3080</span>              : #define X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE 21</span>
<span id="L3081"><span class="lineNum">    3081</span>              : #define X509_V_ERR_CERT_CHAIN_TOO_LONG 22</span>
<span id="L3082"><span class="lineNum">    3082</span>              : #define X509_V_ERR_CERT_REVOKED 23</span>
<span id="L3083"><span class="lineNum">    3083</span>              : #define X509_V_ERR_INVALID_CA 24</span>
<span id="L3084"><span class="lineNum">    3084</span>              : #define X509_V_ERR_PATH_LENGTH_EXCEEDED 25</span>
<span id="L3085"><span class="lineNum">    3085</span>              : #define X509_V_ERR_INVALID_PURPOSE 26</span>
<span id="L3086"><span class="lineNum">    3086</span>              : #define X509_V_ERR_CERT_UNTRUSTED 27</span>
<span id="L3087"><span class="lineNum">    3087</span>              : #define X509_V_ERR_CERT_REJECTED 28</span>
<span id="L3088"><span class="lineNum">    3088</span>              : #define X509_V_ERR_SUBJECT_ISSUER_MISMATCH 29</span>
<span id="L3089"><span class="lineNum">    3089</span>              : #define X509_V_ERR_AKID_SKID_MISMATCH 30</span>
<span id="L3090"><span class="lineNum">    3090</span>              : #define X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH 31</span>
<span id="L3091"><span class="lineNum">    3091</span>              : #define X509_V_ERR_KEYUSAGE_NO_CERTSIGN 32</span>
<span id="L3092"><span class="lineNum">    3092</span>              : #define X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER 33</span>
<span id="L3093"><span class="lineNum">    3093</span>              : #define X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION 34</span>
<span id="L3094"><span class="lineNum">    3094</span>              : #define X509_V_ERR_KEYUSAGE_NO_CRL_SIGN 35</span>
<span id="L3095"><span class="lineNum">    3095</span>              : #define X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION 36</span>
<span id="L3096"><span class="lineNum">    3096</span>              : #define X509_V_ERR_INVALID_NON_CA 37</span>
<span id="L3097"><span class="lineNum">    3097</span>              : #define X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED 38</span>
<span id="L3098"><span class="lineNum">    3098</span>              : #define X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE 39</span>
<span id="L3099"><span class="lineNum">    3099</span>              : #define X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED 40</span>
<span id="L3100"><span class="lineNum">    3100</span>              : #define X509_V_ERR_INVALID_EXTENSION 41</span>
<span id="L3101"><span class="lineNum">    3101</span>              : #define X509_V_ERR_INVALID_POLICY_EXTENSION 42</span>
<span id="L3102"><span class="lineNum">    3102</span>              : #define X509_V_ERR_NO_EXPLICIT_POLICY 43</span>
<span id="L3103"><span class="lineNum">    3103</span>              : #define X509_V_ERR_DIFFERENT_CRL_SCOPE 44</span>
<span id="L3104"><span class="lineNum">    3104</span>              : #define X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE 45</span>
<span id="L3105"><span class="lineNum">    3105</span>              : #define X509_V_ERR_UNNESTED_RESOURCE 46</span>
<span id="L3106"><span class="lineNum">    3106</span>              : #define X509_V_ERR_PERMITTED_VIOLATION 47</span>
<span id="L3107"><span class="lineNum">    3107</span>              : #define X509_V_ERR_EXCLUDED_VIOLATION 48</span>
<span id="L3108"><span class="lineNum">    3108</span>              : #define X509_V_ERR_SUBTREE_MINMAX 49</span>
<span id="L3109"><span class="lineNum">    3109</span>              : #define X509_V_ERR_APPLICATION_VERIFICATION 50</span>
<span id="L3110"><span class="lineNum">    3110</span>              : #define X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE 51</span>
<span id="L3111"><span class="lineNum">    3111</span>              : #define X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX 52</span>
<span id="L3112"><span class="lineNum">    3112</span>              : #define X509_V_ERR_UNSUPPORTED_NAME_SYNTAX 53</span>
<span id="L3113"><span class="lineNum">    3113</span>              : #define X509_V_ERR_CRL_PATH_VALIDATION_ERROR 54</span>
<span id="L3114"><span class="lineNum">    3114</span>              : #define X509_V_ERR_HOSTNAME_MISMATCH 62</span>
<span id="L3115"><span class="lineNum">    3115</span>              : #define X509_V_ERR_EMAIL_MISMATCH 63</span>
<span id="L3116"><span class="lineNum">    3116</span>              : #define X509_V_ERR_IP_ADDRESS_MISMATCH 64</span>
<span id="L3117"><span class="lineNum">    3117</span>              : #define X509_V_ERR_INVALID_CALL 65</span>
<span id="L3118"><span class="lineNum">    3118</span>              : #define X509_V_ERR_STORE_LOOKUP 66</span>
<span id="L3119"><span class="lineNum">    3119</span>              : #define X509_V_ERR_NAME_CONSTRAINTS_WITHOUT_SANS 67</span>
<span id="L3120"><span class="lineNum">    3120</span>              : </span>
<span id="L3121"><span class="lineNum">    3121</span>              : // X509_STORE_CTX_get_error, after |X509_verify_cert| returns, returns</span>
<span id="L3122"><span class="lineNum">    3122</span>              : // |X509_V_OK| if verification succeeded or an |X509_V_ERR_*| describing why</span>
<span id="L3123"><span class="lineNum">    3123</span>              : // verification failed. This will be consistent with |X509_verify_cert|'s return</span>
<span id="L3124"><span class="lineNum">    3124</span>              : // value, unless the caller used the deprecated verification callback (see</span>
<span id="L3125"><span class="lineNum">    3125</span>              : // |X509_STORE_CTX_set_verify_cb|) in a way that breaks |ctx|'s invariants.</span>
<span id="L3126"><span class="lineNum">    3126</span>              : //</span>
<span id="L3127"><span class="lineNum">    3127</span>              : // If called during the deprecated verification callback when |ok| is zero, it</span>
<span id="L3128"><span class="lineNum">    3128</span>              : // returns the current error under consideration.</span>
<span id="L3129"><span class="lineNum">    3129</span>              : OPENSSL_EXPORT int X509_STORE_CTX_get_error(const X509_STORE_CTX *ctx);</span>
<span id="L3130"><span class="lineNum">    3130</span>              : </span>
<span id="L3131"><span class="lineNum">    3131</span>              : // X509_STORE_CTX_set_error sets |ctx|'s error to |err|, which should be</span>
<span id="L3132"><span class="lineNum">    3132</span>              : // |X509_V_OK| or an |X509_V_ERR_*| constant. It is not expected to be called in</span>
<span id="L3133"><span class="lineNum">    3133</span>              : // typical |X509_STORE_CTX| usage, but may be used in callback APIs where</span>
<span id="L3134"><span class="lineNum">    3134</span>              : // applications synthesize |X509_STORE_CTX| error conditions. See also</span>
<span id="L3135"><span class="lineNum">    3135</span>              : // |X509_STORE_CTX_set_verify_cb| and |SSL_CTX_set_cert_verify_callback|.</span>
<span id="L3136"><span class="lineNum">    3136</span>              : OPENSSL_EXPORT void X509_STORE_CTX_set_error(X509_STORE_CTX *ctx, int err);</span>
<span id="L3137"><span class="lineNum">    3137</span>              : </span>
<span id="L3138"><span class="lineNum">    3138</span>              : // X509_verify_cert_error_string returns |err| as a human-readable string, where</span>
<span id="L3139"><span class="lineNum">    3139</span>              : // |err| should be one of the |X509_V_*| values. If |err| is unknown, it returns</span>
<span id="L3140"><span class="lineNum">    3140</span>              : // a default description.</span>
<span id="L3141"><span class="lineNum">    3141</span>              : OPENSSL_EXPORT const char *X509_verify_cert_error_string(long err);</span>
<span id="L3142"><span class="lineNum">    3142</span>              : </span>
<span id="L3143"><span class="lineNum">    3143</span>              : // X509_STORE_CTX_get_error_depth returns the depth at which the error returned</span>
<span id="L3144"><span class="lineNum">    3144</span>              : // by |X509_STORE_CTX_get_error| occured. This is zero-indexed integer into the</span>
<span id="L3145"><span class="lineNum">    3145</span>              : // certificate chain. Zero indicates the target certificate, one its issuer, and</span>
<span id="L3146"><span class="lineNum">    3146</span>              : // so on.</span>
<span id="L3147"><span class="lineNum">    3147</span>              : OPENSSL_EXPORT int X509_STORE_CTX_get_error_depth(const X509_STORE_CTX *ctx);</span>
<span id="L3148"><span class="lineNum">    3148</span>              : </span>
<span id="L3149"><span class="lineNum">    3149</span>              : // X509_STORE_CTX_get_current_cert returns the certificate which caused the</span>
<span id="L3150"><span class="lineNum">    3150</span>              : // error returned by |X509_STORE_CTX_get_error|.</span>
<span id="L3151"><span class="lineNum">    3151</span>              : OPENSSL_EXPORT X509 *X509_STORE_CTX_get_current_cert(const X509_STORE_CTX *ctx);</span>
<span id="L3152"><span class="lineNum">    3152</span>              : </span>
<span id="L3153"><span class="lineNum">    3153</span>              : // X509_STORE_CTX_get0_current_crl returns the CRL which caused the error</span>
<span id="L3154"><span class="lineNum">    3154</span>              : // returned by |X509_STORE_CTX_get_error|.</span>
<span id="L3155"><span class="lineNum">    3155</span>              : OPENSSL_EXPORT X509_CRL *X509_STORE_CTX_get0_current_crl(</span>
<span id="L3156"><span class="lineNum">    3156</span>              :     const X509_STORE_CTX *ctx);</span>
<span id="L3157"><span class="lineNum">    3157</span>              : </span>
<span id="L3158"><span class="lineNum">    3158</span>              : // X509_STORE_CTX_get0_store returns the |X509_STORE| that |ctx| uses.</span>
<span id="L3159"><span class="lineNum">    3159</span>              : OPENSSL_EXPORT X509_STORE *X509_STORE_CTX_get0_store(const X509_STORE_CTX *ctx);</span>
<span id="L3160"><span class="lineNum">    3160</span>              : </span>
<span id="L3161"><span class="lineNum">    3161</span>              : // X509_STORE_CTX_get0_cert returns the leaf certificate that |ctx| is</span>
<span id="L3162"><span class="lineNum">    3162</span>              : // verifying.</span>
<span id="L3163"><span class="lineNum">    3163</span>              : OPENSSL_EXPORT X509 *X509_STORE_CTX_get0_cert(const X509_STORE_CTX *ctx);</span>
<span id="L3164"><span class="lineNum">    3164</span>              : </span>
<span id="L3165"><span class="lineNum">    3165</span>              : // X509_STORE_CTX_get0_untrusted returns the stack of untrusted intermediates</span>
<span id="L3166"><span class="lineNum">    3166</span>              : // used by |ctx| for certificate verification.</span>
<span id="L3167"><span class="lineNum">    3167</span>              : OPENSSL_EXPORT STACK_OF(X509) *X509_STORE_CTX_get0_untrusted(</span>
<span id="L3168"><span class="lineNum">    3168</span>              :     const X509_STORE_CTX *ctx);</span>
<span id="L3169"><span class="lineNum">    3169</span>              : </span>
<span id="L3170"><span class="lineNum">    3170</span>              : // X509_STORE_CTX_set0_trusted_stack configures |ctx| to trust the certificates</span>
<span id="L3171"><span class="lineNum">    3171</span>              : // in |sk|. |sk| must remain valid for the duration of |ctx|. Calling this</span>
<span id="L3172"><span class="lineNum">    3172</span>              : // function causes |ctx| to ignore any certificates configured in the</span>
<span id="L3173"><span class="lineNum">    3173</span>              : // |X509_STORE|. Certificates in |sk| are still subject to the check described</span>
<span id="L3174"><span class="lineNum">    3174</span>              : // in |X509_VERIFY_PARAM_set_trust|.</span>
<span id="L3175"><span class="lineNum">    3175</span>              : //</span>
<span id="L3176"><span class="lineNum">    3176</span>              : // WARNING: This function differs from most |set0| functions in that it does not</span>
<span id="L3177"><span class="lineNum">    3177</span>              : // take ownership of its input. The caller is required to ensure the lifetimes</span>
<span id="L3178"><span class="lineNum">    3178</span>              : // are consistent.</span>
<span id="L3179"><span class="lineNum">    3179</span>              : OPENSSL_EXPORT void X509_STORE_CTX_set0_trusted_stack(X509_STORE_CTX *ctx,</span>
<span id="L3180"><span class="lineNum">    3180</span>              :                                                       STACK_OF(X509) *sk);</span>
<span id="L3181"><span class="lineNum">    3181</span>              : </span>
<span id="L3182"><span class="lineNum">    3182</span>              : // X509_STORE_CTX_set0_crls configures |ctx| to consider the CRLs in |sk| as</span>
<span id="L3183"><span class="lineNum">    3183</span>              : // candidates for CRL lookup. |sk| must remain valid for the duration of |ctx|.</span>
<span id="L3184"><span class="lineNum">    3184</span>              : // These CRLs are considered in addition to CRLs found in |X509_STORE|.</span>
<span id="L3185"><span class="lineNum">    3185</span>              : //</span>
<span id="L3186"><span class="lineNum">    3186</span>              : // WARNING: This function differs from most |set0| functions in that it does not</span>
<span id="L3187"><span class="lineNum">    3187</span>              : // take ownership of its input. The caller is required to ensure the lifetimes</span>
<span id="L3188"><span class="lineNum">    3188</span>              : // are consistent.</span>
<span id="L3189"><span class="lineNum">    3189</span>              : OPENSSL_EXPORT void X509_STORE_CTX_set0_crls(X509_STORE_CTX *ctx,</span>
<span id="L3190"><span class="lineNum">    3190</span>              :                                              STACK_OF(X509_CRL) *sk);</span>
<span id="L3191"><span class="lineNum">    3191</span>              : </span>
<span id="L3192"><span class="lineNum">    3192</span>              : // X509_STORE_CTX_set_default looks up the set of parameters named |name| and</span>
<span id="L3193"><span class="lineNum">    3193</span>              : // applies those default verification parameters for |ctx|. As in</span>
<span id="L3194"><span class="lineNum">    3194</span>              : // |X509_VERIFY_PARAM_inherit|, only unset parameters are changed. This function</span>
<span id="L3195"><span class="lineNum">    3195</span>              : // returns one on success and zero on error.</span>
<span id="L3196"><span class="lineNum">    3196</span>              : //</span>
<span id="L3197"><span class="lineNum">    3197</span>              : // The supported values of |name| are:</span>
<span id="L3198"><span class="lineNum">    3198</span>              : // - &quot;default&quot; is an internal value which configures some late defaults. See the</span>
<span id="L3199"><span class="lineNum">    3199</span>              : //   discussion in |X509_STORE_get0_param|.</span>
<span id="L3200"><span class="lineNum">    3200</span>              : // - &quot;pkcs7&quot; configures default trust and purpose checks for PKCS#7 signatures.</span>
<span id="L3201"><span class="lineNum">    3201</span>              : // - &quot;smime_sign&quot; configures trust and purpose checks for S/MIME signatures.</span>
<span id="L3202"><span class="lineNum">    3202</span>              : // - &quot;ssl_client&quot; configures trust and purpose checks for TLS clients.</span>
<span id="L3203"><span class="lineNum">    3203</span>              : // - &quot;ssl_server&quot; configures trust and purpose checks for TLS servers.</span>
<span id="L3204"><span class="lineNum">    3204</span>              : //</span>
<span id="L3205"><span class="lineNum">    3205</span>              : // TODO(crbug.com/boringssl/441): Make &quot;default&quot; a no-op.</span>
<span id="L3206"><span class="lineNum">    3206</span>              : OPENSSL_EXPORT int X509_STORE_CTX_set_default(X509_STORE_CTX *ctx,</span>
<span id="L3207"><span class="lineNum">    3207</span>              :                                               const char *name);</span>
<span id="L3208"><span class="lineNum">    3208</span>              : </span>
<span id="L3209"><span class="lineNum">    3209</span>              : // X509_STORE_CTX_get0_param returns |ctx|'s verification parameters. This</span>
<span id="L3210"><span class="lineNum">    3210</span>              : // object is mutable and may be modified by the caller.</span>
<span id="L3211"><span class="lineNum">    3211</span>              : OPENSSL_EXPORT X509_VERIFY_PARAM *X509_STORE_CTX_get0_param(</span>
<span id="L3212"><span class="lineNum">    3212</span>              :     X509_STORE_CTX *ctx);</span>
<span id="L3213"><span class="lineNum">    3213</span>              : </span>
<span id="L3214"><span class="lineNum">    3214</span>              : // X509_STORE_CTX_set0_param returns |ctx|'s verification parameters to |param|</span>
<span id="L3215"><span class="lineNum">    3215</span>              : // and takes ownership of |param|. After this function returns, the caller</span>
<span id="L3216"><span class="lineNum">    3216</span>              : // should not free |param|.</span>
<span id="L3217"><span class="lineNum">    3217</span>              : //</span>
<span id="L3218"><span class="lineNum">    3218</span>              : // WARNING: This function discards any values which were previously applied in</span>
<span id="L3219"><span class="lineNum">    3219</span>              : // |ctx|, including the &quot;default&quot; parameters applied late in</span>
<span id="L3220"><span class="lineNum">    3220</span>              : // |X509_STORE_CTX_init|. These late defaults are not applied to parameters</span>
<span id="L3221"><span class="lineNum">    3221</span>              : // created standalone by |X509_VERIFY_PARAM_new|.</span>
<span id="L3222"><span class="lineNum">    3222</span>              : //</span>
<span id="L3223"><span class="lineNum">    3223</span>              : // TODO(crbug.com/boringssl/441): This behavior is very surprising. Should we</span>
<span id="L3224"><span class="lineNum">    3224</span>              : // re-apply the late defaults in |param|, or somehow avoid this notion of late</span>
<span id="L3225"><span class="lineNum">    3225</span>              : // defaults altogether?</span>
<span id="L3226"><span class="lineNum">    3226</span>              : OPENSSL_EXPORT void X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx,</span>
<span id="L3227"><span class="lineNum">    3227</span>              :                                               X509_VERIFY_PARAM *param);</span>
<span id="L3228"><span class="lineNum">    3228</span>              : </span>
<span id="L3229"><span class="lineNum">    3229</span>              : // X509_STORE_CTX_set_flags enables all values in |flags| in |ctx|'s</span>
<span id="L3230"><span class="lineNum">    3230</span>              : // verification flags. |flags| should be a combination of |X509_V_FLAG_*|</span>
<span id="L3231"><span class="lineNum">    3231</span>              : // constants.</span>
<span id="L3232"><span class="lineNum">    3232</span>              : OPENSSL_EXPORT void X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx,</span>
<span id="L3233"><span class="lineNum">    3233</span>              :                                              unsigned long flags);</span>
<span id="L3234"><span class="lineNum">    3234</span>              : </span>
<span id="L3235"><span class="lineNum">    3235</span>              : // X509_STORE_CTX_set_time configures certificate verification to use |t|</span>
<span id="L3236"><span class="lineNum">    3236</span>              : // instead of the current time. |flags| is ignored and should be zero.</span>
<span id="L3237"><span class="lineNum">    3237</span>              : OPENSSL_EXPORT void X509_STORE_CTX_set_time(X509_STORE_CTX *ctx,</span>
<span id="L3238"><span class="lineNum">    3238</span>              :                                             unsigned long flags, time_t t);</span>
<span id="L3239"><span class="lineNum">    3239</span>              : </span>
<span id="L3240"><span class="lineNum">    3240</span>              : // X509_STORE_CTX_set_time_posix configures certificate verification to use |t|</span>
<span id="L3241"><span class="lineNum">    3241</span>              : // instead of the current time. |t| is interpreted as a POSIX timestamp in</span>
<span id="L3242"><span class="lineNum">    3242</span>              : // seconds. |flags| is ignored and should be zero.</span>
<span id="L3243"><span class="lineNum">    3243</span>              : OPENSSL_EXPORT void X509_STORE_CTX_set_time_posix(X509_STORE_CTX *ctx,</span>
<span id="L3244"><span class="lineNum">    3244</span>              :                                                   unsigned long flags,</span>
<span id="L3245"><span class="lineNum">    3245</span>              :                                                   int64_t t);</span>
<span id="L3246"><span class="lineNum">    3246</span>              : </span>
<span id="L3247"><span class="lineNum">    3247</span>              : // X509_STORE_CTX_set_depth configures |ctx| to, by default, limit certificate</span>
<span id="L3248"><span class="lineNum">    3248</span>              : // chains to |depth| intermediate certificates. This count excludes both the</span>
<span id="L3249"><span class="lineNum">    3249</span>              : // target certificate and the trust anchor (root certificate).</span>
<span id="L3250"><span class="lineNum">    3250</span>              : OPENSSL_EXPORT void X509_STORE_CTX_set_depth(X509_STORE_CTX *ctx, int depth);</span>
<span id="L3251"><span class="lineNum">    3251</span>              : </span>
<span id="L3252"><span class="lineNum">    3252</span>              : // X509_STORE_CTX_set_purpose simultaneously configures |ctx|'s purpose and</span>
<span id="L3253"><span class="lineNum">    3253</span>              : // trust checks, if unset. It returns one on success and zero if |purpose| is</span>
<span id="L3254"><span class="lineNum">    3254</span>              : // not a valid purpose value. |purpose| should be an |X509_PURPOSE_*| constant.</span>
<span id="L3255"><span class="lineNum">    3255</span>              : // If so, it configures |ctx| with a purpose check of |purpose| and a trust</span>
<span id="L3256"><span class="lineNum">    3256</span>              : // check of |purpose|'s corresponding trust value. If either the purpose or</span>
<span id="L3257"><span class="lineNum">    3257</span>              : // trust check had already been specified for |ctx|, that corresponding</span>
<span id="L3258"><span class="lineNum">    3258</span>              : // modification is silently dropped.</span>
<span id="L3259"><span class="lineNum">    3259</span>              : //</span>
<span id="L3260"><span class="lineNum">    3260</span>              : // See |X509_VERIFY_PARAM_set_purpose| and |X509_VERIFY_PARAM_set_trust| for</span>
<span id="L3261"><span class="lineNum">    3261</span>              : // details on the purpose and trust checks, respectively.</span>
<span id="L3262"><span class="lineNum">    3262</span>              : //</span>
<span id="L3263"><span class="lineNum">    3263</span>              : // If |purpose| is |X509_PURPOSE_ANY|, this function returns an error because it</span>
<span id="L3264"><span class="lineNum">    3264</span>              : // has no corresponding |X509_TRUST_*| value. It is not possible to set</span>
<span id="L3265"><span class="lineNum">    3265</span>              : // |X509_PURPOSE_ANY| with this function, only |X509_VERIFY_PARAM_set_purpose|.</span>
<span id="L3266"><span class="lineNum">    3266</span>              : //</span>
<span id="L3267"><span class="lineNum">    3267</span>              : // WARNING: Unlike similarly named functions in this header, this function</span>
<span id="L3268"><span class="lineNum">    3268</span>              : // silently does not behave the same as |X509_VERIFY_PARAM_set_purpose|. Callers</span>
<span id="L3269"><span class="lineNum">    3269</span>              : // may use |X509_VERIFY_PARAM_set_purpose| with |X509_STORE_CTX_get0_param| to</span>
<span id="L3270"><span class="lineNum">    3270</span>              : // avoid this difference.</span>
<span id="L3271"><span class="lineNum">    3271</span>              : OPENSSL_EXPORT int X509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int purpose);</span>
<span id="L3272"><span class="lineNum">    3272</span>              : </span>
<span id="L3273"><span class="lineNum">    3273</span>              : // X509_STORE_CTX_set_trust configures |ctx|'s trust check, if unset. It returns</span>
<span id="L3274"><span class="lineNum">    3274</span>              : // one on success and zero if |trust| is not a valid trust value. |trust| should</span>
<span id="L3275"><span class="lineNum">    3275</span>              : // be an |X509_TRUST_*| constant. If so, it configures |ctx| with a trust check</span>
<span id="L3276"><span class="lineNum">    3276</span>              : // of |trust|. If the trust check had already been specified for |ctx|, it</span>
<span id="L3277"><span class="lineNum">    3277</span>              : // silently does nothing.</span>
<span id="L3278"><span class="lineNum">    3278</span>              : //</span>
<span id="L3279"><span class="lineNum">    3279</span>              : // See |X509_VERIFY_PARAM_set_trust| for details on the purpose and trust check.</span>
<span id="L3280"><span class="lineNum">    3280</span>              : //</span>
<span id="L3281"><span class="lineNum">    3281</span>              : // WARNING: Unlike similarly named functions in this header, this function</span>
<span id="L3282"><span class="lineNum">    3282</span>              : // does not behave the same as |X509_VERIFY_PARAM_set_trust|. Callers may use</span>
<span id="L3283"><span class="lineNum">    3283</span>              : // |X509_VERIFY_PARAM_set_trust| with |X509_STORE_CTX_get0_param| to avoid this</span>
<span id="L3284"><span class="lineNum">    3284</span>              : // difference.</span>
<span id="L3285"><span class="lineNum">    3285</span>              : OPENSSL_EXPORT int X509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int trust);</span>
<span id="L3286"><span class="lineNum">    3286</span>              : </span>
<span id="L3287"><span class="lineNum">    3287</span>              : </span>
<span id="L3288"><span class="lineNum">    3288</span>              : // Verification parameters.</span>
<span id="L3289"><span class="lineNum">    3289</span>              : //</span>
<span id="L3290"><span class="lineNum">    3290</span>              : // An |X509_VERIFY_PARAM| contains a set of parameters for certificate</span>
<span id="L3291"><span class="lineNum">    3291</span>              : // verification.</span>
<span id="L3292"><span class="lineNum">    3292</span>              : </span>
<span id="L3293"><span class="lineNum">    3293</span>              : // X509_VERIFY_PARAM_new returns a newly-allocated |X509_VERIFY_PARAM|, or NULL</span>
<span id="L3294"><span class="lineNum">    3294</span>              : // on error.</span>
<span id="L3295"><span class="lineNum">    3295</span>              : OPENSSL_EXPORT X509_VERIFY_PARAM *X509_VERIFY_PARAM_new(void);</span>
<span id="L3296"><span class="lineNum">    3296</span>              : </span>
<span id="L3297"><span class="lineNum">    3297</span>              : // X509_VERIFY_PARAM_free releases memory associated with |param|.</span>
<span id="L3298"><span class="lineNum">    3298</span>              : OPENSSL_EXPORT void X509_VERIFY_PARAM_free(X509_VERIFY_PARAM *param);</span>
<span id="L3299"><span class="lineNum">    3299</span>              : </span>
<span id="L3300"><span class="lineNum">    3300</span>              : // X509_VERIFY_PARAM_inherit applies |from| as the default values for |to|. That</span>
<span id="L3301"><span class="lineNum">    3301</span>              : // is, for each parameter that is unset in |to|, it copies the value in |from|.</span>
<span id="L3302"><span class="lineNum">    3302</span>              : // This function returns one on success and zero on error.</span>
<span id="L3303"><span class="lineNum">    3303</span>              : OPENSSL_EXPORT int X509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *to,</span>
<span id="L3304"><span class="lineNum">    3304</span>              :                                              const X509_VERIFY_PARAM *from);</span>
<span id="L3305"><span class="lineNum">    3305</span>              : </span>
<span id="L3306"><span class="lineNum">    3306</span>              : // X509_VERIFY_PARAM_set1 copies parameters from |from| to |to|. If a parameter</span>
<span id="L3307"><span class="lineNum">    3307</span>              : // is unset in |from|, the existing value in |to| is preserved. This function</span>
<span id="L3308"><span class="lineNum">    3308</span>              : // returns one on success and zero on error.</span>
<span id="L3309"><span class="lineNum">    3309</span>              : OPENSSL_EXPORT int X509_VERIFY_PARAM_set1(X509_VERIFY_PARAM *to,</span>
<span id="L3310"><span class="lineNum">    3310</span>              :                                           const X509_VERIFY_PARAM *from);</span>
<span id="L3311"><span class="lineNum">    3311</span>              : </span>
<span id="L3312"><span class="lineNum">    3312</span>              : // X509_V_FLAG_* are flags for |X509_VERIFY_PARAM_set_flags| and</span>
<span id="L3313"><span class="lineNum">    3313</span>              : // |X509_VERIFY_PARAM_clear_flags|.</span>
<span id="L3314"><span class="lineNum">    3314</span>              : </span>
<span id="L3315"><span class="lineNum">    3315</span>              : // X509_V_FLAG_CB_ISSUER_CHECK causes the deprecated verify callback (see</span>
<span id="L3316"><span class="lineNum">    3316</span>              : // |X509_STORE_CTX_set_verify_cb|) to be called for errors while matching</span>
<span id="L3317"><span class="lineNum">    3317</span>              : // subject and issuer certificates.</span>
<span id="L3318"><span class="lineNum">    3318</span>              : #define X509_V_FLAG_CB_ISSUER_CHECK 0x1</span>
<span id="L3319"><span class="lineNum">    3319</span>              : // X509_V_FLAG_USE_CHECK_TIME is an internal flag used to track whether</span>
<span id="L3320"><span class="lineNum">    3320</span>              : // |X509_STORE_CTX_set_time| has been used. If cleared, the system time is</span>
<span id="L3321"><span class="lineNum">    3321</span>              : // restored.</span>
<span id="L3322"><span class="lineNum">    3322</span>              : #define X509_V_FLAG_USE_CHECK_TIME 0x2</span>
<span id="L3323"><span class="lineNum">    3323</span>              : // X509_V_FLAG_CRL_CHECK enables CRL lookup and checking for the leaf.</span>
<span id="L3324"><span class="lineNum">    3324</span>              : #define X509_V_FLAG_CRL_CHECK 0x4</span>
<span id="L3325"><span class="lineNum">    3325</span>              : // X509_V_FLAG_CRL_CHECK_ALL enables CRL lookup and checking for the entire</span>
<span id="L3326"><span class="lineNum">    3326</span>              : // certificate chain. |X509_V_FLAG_CRL_CHECK| must be set for this flag to take</span>
<span id="L3327"><span class="lineNum">    3327</span>              : // effect.</span>
<span id="L3328"><span class="lineNum">    3328</span>              : #define X509_V_FLAG_CRL_CHECK_ALL 0x8</span>
<span id="L3329"><span class="lineNum">    3329</span>              : // X509_V_FLAG_IGNORE_CRITICAL ignores unhandled critical extensions. Do not use</span>
<span id="L3330"><span class="lineNum">    3330</span>              : // this option. Critical extensions ensure the verifier does not bypass</span>
<span id="L3331"><span class="lineNum">    3331</span>              : // unrecognized security restrictions in certificates.</span>
<span id="L3332"><span class="lineNum">    3332</span>              : #define X509_V_FLAG_IGNORE_CRITICAL 0x10</span>
<span id="L3333"><span class="lineNum">    3333</span>              : // X509_V_FLAG_X509_STRICT does nothing. Its functionality has been enabled by</span>
<span id="L3334"><span class="lineNum">    3334</span>              : // default.</span>
<span id="L3335"><span class="lineNum">    3335</span>              : #define X509_V_FLAG_X509_STRICT 0x00</span>
<span id="L3336"><span class="lineNum">    3336</span>              : // X509_V_FLAG_ALLOW_PROXY_CERTS does nothing. Proxy certificate support has</span>
<span id="L3337"><span class="lineNum">    3337</span>              : // been removed.</span>
<span id="L3338"><span class="lineNum">    3338</span>              : #define X509_V_FLAG_ALLOW_PROXY_CERTS 0x40</span>
<span id="L3339"><span class="lineNum">    3339</span>              : // X509_V_FLAG_POLICY_CHECK does nothing. Policy checking is always enabled.</span>
<span id="L3340"><span class="lineNum">    3340</span>              : #define X509_V_FLAG_POLICY_CHECK 0x80</span>
<span id="L3341"><span class="lineNum">    3341</span>              : // X509_V_FLAG_EXPLICIT_POLICY requires some policy OID to be asserted by the</span>
<span id="L3342"><span class="lineNum">    3342</span>              : // final certificate chain. See initial-explicit-policy from RFC 5280,</span>
<span id="L3343"><span class="lineNum">    3343</span>              : // section 6.1.1.</span>
<span id="L3344"><span class="lineNum">    3344</span>              : #define X509_V_FLAG_EXPLICIT_POLICY 0x100</span>
<span id="L3345"><span class="lineNum">    3345</span>              : // X509_V_FLAG_INHIBIT_ANY inhibits the anyPolicy OID. See</span>
<span id="L3346"><span class="lineNum">    3346</span>              : // initial-any-policy-inhibit from RFC 5280, section 6.1.1.</span>
<span id="L3347"><span class="lineNum">    3347</span>              : #define X509_V_FLAG_INHIBIT_ANY 0x200</span>
<span id="L3348"><span class="lineNum">    3348</span>              : // X509_V_FLAG_INHIBIT_MAP inhibits policy mapping. See</span>
<span id="L3349"><span class="lineNum">    3349</span>              : // initial-policy-mapping-inhibit from RFC 5280, section 6.1.1.</span>
<span id="L3350"><span class="lineNum">    3350</span>              : #define X509_V_FLAG_INHIBIT_MAP 0x400</span>
<span id="L3351"><span class="lineNum">    3351</span>              : // X509_V_FLAG_NOTIFY_POLICY does nothing. Its functionality has been removed.</span>
<span id="L3352"><span class="lineNum">    3352</span>              : #define X509_V_FLAG_NOTIFY_POLICY 0x800</span>
<span id="L3353"><span class="lineNum">    3353</span>              : // X509_V_FLAG_EXTENDED_CRL_SUPPORT causes all verifications to fail. Extended</span>
<span id="L3354"><span class="lineNum">    3354</span>              : // CRL features have been removed.</span>
<span id="L3355"><span class="lineNum">    3355</span>              : #define X509_V_FLAG_EXTENDED_CRL_SUPPORT 0x1000</span>
<span id="L3356"><span class="lineNum">    3356</span>              : // X509_V_FLAG_USE_DELTAS causes all verifications to fail. Delta CRL support</span>
<span id="L3357"><span class="lineNum">    3357</span>              : // has been removed.</span>
<span id="L3358"><span class="lineNum">    3358</span>              : #define X509_V_FLAG_USE_DELTAS 0x2000</span>
<span id="L3359"><span class="lineNum">    3359</span>              : // X509_V_FLAG_CHECK_SS_SIGNATURE checks the redundant signature on self-signed</span>
<span id="L3360"><span class="lineNum">    3360</span>              : // trust anchors. This check provides no security benefit and only wastes CPU.</span>
<span id="L3361"><span class="lineNum">    3361</span>              : #define X509_V_FLAG_CHECK_SS_SIGNATURE 0x4000</span>
<span id="L3362"><span class="lineNum">    3362</span>              : // X509_V_FLAG_TRUSTED_FIRST, during path-building, checks for a match in the</span>
<span id="L3363"><span class="lineNum">    3363</span>              : // trust store before considering an untrusted intermediate. This flag is</span>
<span id="L3364"><span class="lineNum">    3364</span>              : // enabled by default.</span>
<span id="L3365"><span class="lineNum">    3365</span>              : #define X509_V_FLAG_TRUSTED_FIRST 0x8000</span>
<span id="L3366"><span class="lineNum">    3366</span>              : // X509_V_FLAG_PARTIAL_CHAIN treats all trusted certificates as trust anchors,</span>
<span id="L3367"><span class="lineNum">    3367</span>              : // independent of the |X509_VERIFY_PARAM_set_trust| setting.</span>
<span id="L3368"><span class="lineNum">    3368</span>              : #define X509_V_FLAG_PARTIAL_CHAIN 0x80000</span>
<span id="L3369"><span class="lineNum">    3369</span>              : // X509_V_FLAG_NO_ALT_CHAINS disables building alternative chains if the initial</span>
<span id="L3370"><span class="lineNum">    3370</span>              : // one was rejected.</span>
<span id="L3371"><span class="lineNum">    3371</span>              : #define X509_V_FLAG_NO_ALT_CHAINS 0x100000</span>
<span id="L3372"><span class="lineNum">    3372</span>              : // X509_V_FLAG_NO_CHECK_TIME disables all time checks in certificate</span>
<span id="L3373"><span class="lineNum">    3373</span>              : // verification.</span>
<span id="L3374"><span class="lineNum">    3374</span>              : #define X509_V_FLAG_NO_CHECK_TIME 0x200000</span>
<span id="L3375"><span class="lineNum">    3375</span>              : </span>
<span id="L3376"><span class="lineNum">    3376</span>              : // X509_VERIFY_PARAM_set_flags enables all values in |flags| in |param|'s</span>
<span id="L3377"><span class="lineNum">    3377</span>              : // verification flags and returns one. |flags| should be a combination of</span>
<span id="L3378"><span class="lineNum">    3378</span>              : // |X509_V_FLAG_*| constants.</span>
<span id="L3379"><span class="lineNum">    3379</span>              : OPENSSL_EXPORT int X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *param,</span>
<span id="L3380"><span class="lineNum">    3380</span>              :                                                unsigned long flags);</span>
<span id="L3381"><span class="lineNum">    3381</span>              : </span>
<span id="L3382"><span class="lineNum">    3382</span>              : // X509_VERIFY_PARAM_clear_flags disables all values in |flags| in |param|'s</span>
<span id="L3383"><span class="lineNum">    3383</span>              : // verification flags and returns one. |flags| should be a combination of</span>
<span id="L3384"><span class="lineNum">    3384</span>              : // |X509_V_FLAG_*| constants.</span>
<span id="L3385"><span class="lineNum">    3385</span>              : OPENSSL_EXPORT int X509_VERIFY_PARAM_clear_flags(X509_VERIFY_PARAM *param,</span>
<span id="L3386"><span class="lineNum">    3386</span>              :                                                  unsigned long flags);</span>
<span id="L3387"><span class="lineNum">    3387</span>              : </span>
<span id="L3388"><span class="lineNum">    3388</span>              : // X509_VERIFY_PARAM_get_flags returns |param|'s verification flags.</span>
<span id="L3389"><span class="lineNum">    3389</span>              : OPENSSL_EXPORT unsigned long X509_VERIFY_PARAM_get_flags(</span>
<span id="L3390"><span class="lineNum">    3390</span>              :     const X509_VERIFY_PARAM *param);</span>
<span id="L3391"><span class="lineNum">    3391</span>              : </span>
<span id="L3392"><span class="lineNum">    3392</span>              : // X509_VERIFY_PARAM_set_depth configures |param| to limit certificate chains to</span>
<span id="L3393"><span class="lineNum">    3393</span>              : // |depth| intermediate certificates. This count excludes both the target</span>
<span id="L3394"><span class="lineNum">    3394</span>              : // certificate and the trust anchor (root certificate).</span>
<span id="L3395"><span class="lineNum">    3395</span>              : OPENSSL_EXPORT void X509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *param,</span>
<span id="L3396"><span class="lineNum">    3396</span>              :                                                 int depth);</span>
<span id="L3397"><span class="lineNum">    3397</span>              : </span>
<span id="L3398"><span class="lineNum">    3398</span>              : // X509_VERIFY_PARAM_get_depth returns the maximum depth configured in |param|.</span>
<span id="L3399"><span class="lineNum">    3399</span>              : // See |X509_VERIFY_PARAM_set_depth|.</span>
<span id="L3400"><span class="lineNum">    3400</span>              : OPENSSL_EXPORT int X509_VERIFY_PARAM_get_depth(const X509_VERIFY_PARAM *param);</span>
<span id="L3401"><span class="lineNum">    3401</span>              : </span>
<span id="L3402"><span class="lineNum">    3402</span>              : // X509_VERIFY_PARAM_set_time configures certificate verification to use |t|</span>
<span id="L3403"><span class="lineNum">    3403</span>              : // instead of the current time.</span>
<span id="L3404"><span class="lineNum">    3404</span>              : OPENSSL_EXPORT void X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *param,</span>
<span id="L3405"><span class="lineNum">    3405</span>              :                                                time_t t);</span>
<span id="L3406"><span class="lineNum">    3406</span>              : </span>
<span id="L3407"><span class="lineNum">    3407</span>              : // X509_VERIFY_PARAM_set_time_posix configures certificate verification to use</span>
<span id="L3408"><span class="lineNum">    3408</span>              : // |t| instead of the current time. |t| is interpreted as a POSIX timestamp in</span>
<span id="L3409"><span class="lineNum">    3409</span>              : // seconds.</span>
<span id="L3410"><span class="lineNum">    3410</span>              : OPENSSL_EXPORT void X509_VERIFY_PARAM_set_time_posix(X509_VERIFY_PARAM *param,</span>
<span id="L3411"><span class="lineNum">    3411</span>              :                                                      int64_t t);</span>
<span id="L3412"><span class="lineNum">    3412</span>              : </span>
<span id="L3413"><span class="lineNum">    3413</span>              : // X509_VERIFY_PARAM_add0_policy adds |policy| to the user-initial-policy-set</span>
<span id="L3414"><span class="lineNum">    3414</span>              : // (see Section 6.1.1 of RFC 5280). On success, it takes ownership of</span>
<span id="L3415"><span class="lineNum">    3415</span>              : // |policy| and returns one. Otherwise, it returns zero and the caller retains</span>
<span id="L3416"><span class="lineNum">    3416</span>              : // owneship of |policy|.</span>
<span id="L3417"><span class="lineNum">    3417</span>              : OPENSSL_EXPORT int X509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *param,</span>
<span id="L3418"><span class="lineNum">    3418</span>              :                                                  ASN1_OBJECT *policy);</span>
<span id="L3419"><span class="lineNum">    3419</span>              : </span>
<span id="L3420"><span class="lineNum">    3420</span>              : // X509_VERIFY_PARAM_set1_policies sets the user-initial-policy-set (see</span>
<span id="L3421"><span class="lineNum">    3421</span>              : // Section 6.1.1 of RFC 5280) to a copy of |policies|. It returns one on success</span>
<span id="L3422"><span class="lineNum">    3422</span>              : // and zero on error.</span>
<span id="L3423"><span class="lineNum">    3423</span>              : OPENSSL_EXPORT int X509_VERIFY_PARAM_set1_policies(</span>
<span id="L3424"><span class="lineNum">    3424</span>              :     X509_VERIFY_PARAM *param, const STACK_OF(ASN1_OBJECT) *policies);</span>
<span id="L3425"><span class="lineNum">    3425</span>              : </span>
<span id="L3426"><span class="lineNum">    3426</span>              : // X509_VERIFY_PARAM_set1_host configures |param| to check for the DNS name</span>
<span id="L3427"><span class="lineNum">    3427</span>              : // specified by |name|. It returns one on success and zero on error.</span>
<span id="L3428"><span class="lineNum">    3428</span>              : //</span>
<span id="L3429"><span class="lineNum">    3429</span>              : // By default, both subject alternative names and the subject's common name</span>
<span id="L3430"><span class="lineNum">    3430</span>              : // attribute are checked. The latter has long been deprecated, so callers should</span>
<span id="L3431"><span class="lineNum">    3431</span>              : // call |X509_VERIFY_PARAM_set_hostflags| with</span>
<span id="L3432"><span class="lineNum">    3432</span>              : // |X509_CHECK_FLAG_NEVER_CHECK_SUBJECT| to use the standard behavior.</span>
<span id="L3433"><span class="lineNum">    3433</span>              : // https://crbug.com/boringssl/464 tracks fixing the default.</span>
<span id="L3434"><span class="lineNum">    3434</span>              : OPENSSL_EXPORT int X509_VERIFY_PARAM_set1_host(X509_VERIFY_PARAM *param,</span>
<span id="L3435"><span class="lineNum">    3435</span>              :                                                const char *name,</span>
<span id="L3436"><span class="lineNum">    3436</span>              :                                                size_t name_len);</span>
<span id="L3437"><span class="lineNum">    3437</span>              : </span>
<span id="L3438"><span class="lineNum">    3438</span>              : // X509_VERIFY_PARAM_add1_host adds |name| to the list of names checked by</span>
<span id="L3439"><span class="lineNum">    3439</span>              : // |param|. If any configured DNS name matches the certificate, verification</span>
<span id="L3440"><span class="lineNum">    3440</span>              : // succeeds. It returns one on success and zero on error.</span>
<span id="L3441"><span class="lineNum">    3441</span>              : //</span>
<span id="L3442"><span class="lineNum">    3442</span>              : // By default, both subject alternative names and the subject's common name</span>
<span id="L3443"><span class="lineNum">    3443</span>              : // attribute are checked. The latter has long been deprecated, so callers should</span>
<span id="L3444"><span class="lineNum">    3444</span>              : // call |X509_VERIFY_PARAM_set_hostflags| with</span>
<span id="L3445"><span class="lineNum">    3445</span>              : // |X509_CHECK_FLAG_NEVER_CHECK_SUBJECT| to use the standard behavior.</span>
<span id="L3446"><span class="lineNum">    3446</span>              : // https://crbug.com/boringssl/464 tracks fixing the default.</span>
<span id="L3447"><span class="lineNum">    3447</span>              : OPENSSL_EXPORT int X509_VERIFY_PARAM_add1_host(X509_VERIFY_PARAM *param,</span>
<span id="L3448"><span class="lineNum">    3448</span>              :                                                const char *name,</span>
<span id="L3449"><span class="lineNum">    3449</span>              :                                                size_t name_len);</span>
<span id="L3450"><span class="lineNum">    3450</span>              : </span>
<span id="L3451"><span class="lineNum">    3451</span>              : // X509_CHECK_FLAG_NO_WILDCARDS disables wildcard matching for DNS names.</span>
<span id="L3452"><span class="lineNum">    3452</span>              : #define X509_CHECK_FLAG_NO_WILDCARDS 0x2</span>
<span id="L3453"><span class="lineNum">    3453</span>              : </span>
<span id="L3454"><span class="lineNum">    3454</span>              : // X509_CHECK_FLAG_NEVER_CHECK_SUBJECT disables the subject fallback, normally</span>
<span id="L3455"><span class="lineNum">    3455</span>              : // enabled when subjectAltNames is missing.</span>
<span id="L3456"><span class="lineNum">    3456</span>              : #define X509_CHECK_FLAG_NEVER_CHECK_SUBJECT 0x20</span>
<span id="L3457"><span class="lineNum">    3457</span>              : </span>
<span id="L3458"><span class="lineNum">    3458</span>              : // X509_VERIFY_PARAM_set_hostflags sets the name-checking flags on |param| to</span>
<span id="L3459"><span class="lineNum">    3459</span>              : // |flags|. |flags| should be a combination of |X509_CHECK_FLAG_*| constants.</span>
<span id="L3460"><span class="lineNum">    3460</span>              : OPENSSL_EXPORT void X509_VERIFY_PARAM_set_hostflags(X509_VERIFY_PARAM *param,</span>
<span id="L3461"><span class="lineNum">    3461</span>              :                                                     unsigned int flags);</span>
<span id="L3462"><span class="lineNum">    3462</span>              : </span>
<span id="L3463"><span class="lineNum">    3463</span>              : // X509_VERIFY_PARAM_set1_email configures |param| to check for the email</span>
<span id="L3464"><span class="lineNum">    3464</span>              : // address specified by |email|. It returns one on success and zero on error.</span>
<span id="L3465"><span class="lineNum">    3465</span>              : //</span>
<span id="L3466"><span class="lineNum">    3466</span>              : // By default, both subject alternative names and the subject's email address</span>
<span id="L3467"><span class="lineNum">    3467</span>              : // attribute are checked. The |X509_CHECK_FLAG_NEVER_CHECK_SUBJECT| flag may be</span>
<span id="L3468"><span class="lineNum">    3468</span>              : // used to change this behavior.</span>
<span id="L3469"><span class="lineNum">    3469</span>              : OPENSSL_EXPORT int X509_VERIFY_PARAM_set1_email(X509_VERIFY_PARAM *param,</span>
<span id="L3470"><span class="lineNum">    3470</span>              :                                                 const char *email,</span>
<span id="L3471"><span class="lineNum">    3471</span>              :                                                 size_t email_len);</span>
<span id="L3472"><span class="lineNum">    3472</span>              : </span>
<span id="L3473"><span class="lineNum">    3473</span>              : // X509_VERIFY_PARAM_set1_ip configures |param| to check for the IP address</span>
<span id="L3474"><span class="lineNum">    3474</span>              : // specified by |ip|. It returns one on success and zero on error. The IP</span>
<span id="L3475"><span class="lineNum">    3475</span>              : // address is specified in its binary representation. |ip_len| must be 4 for an</span>
<span id="L3476"><span class="lineNum">    3476</span>              : // IPv4 address and 16 for an IPv6 address.</span>
<span id="L3477"><span class="lineNum">    3477</span>              : OPENSSL_EXPORT int X509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM *param,</span>
<span id="L3478"><span class="lineNum">    3478</span>              :                                              const uint8_t *ip, size_t ip_len);</span>
<span id="L3479"><span class="lineNum">    3479</span>              : </span>
<span id="L3480"><span class="lineNum">    3480</span>              : // X509_VERIFY_PARAM_set1_ip_asc decodes |ipasc| as the ASCII representation of</span>
<span id="L3481"><span class="lineNum">    3481</span>              : // an IPv4 or IPv6 address, and configures |param| to check for it. It returns</span>
<span id="L3482"><span class="lineNum">    3482</span>              : // one on success and zero on error.</span>
<span id="L3483"><span class="lineNum">    3483</span>              : OPENSSL_EXPORT int X509_VERIFY_PARAM_set1_ip_asc(X509_VERIFY_PARAM *param,</span>
<span id="L3484"><span class="lineNum">    3484</span>              :                                                  const char *ipasc);</span>
<span id="L3485"><span class="lineNum">    3485</span>              : </span>
<span id="L3486"><span class="lineNum">    3486</span>              : // X509_PURPOSE_SSL_CLIENT validates TLS client certificates. It checks for the</span>
<span id="L3487"><span class="lineNum">    3487</span>              : // id-kp-clientAuth EKU and one of digitalSignature or keyAgreement key usages.</span>
<span id="L3488"><span class="lineNum">    3488</span>              : // The TLS library is expected to check for the key usage specific to the</span>
<span id="L3489"><span class="lineNum">    3489</span>              : // negotiated TLS parameters.</span>
<span id="L3490"><span class="lineNum">    3490</span>              : #define X509_PURPOSE_SSL_CLIENT 1</span>
<span id="L3491"><span class="lineNum">    3491</span>              : // X509_PURPOSE_SSL_SERVER validates TLS server certificates. It checks for the</span>
<span id="L3492"><span class="lineNum">    3492</span>              : // id-kp-clientAuth EKU and one of digitalSignature, keyAgreement, or</span>
<span id="L3493"><span class="lineNum">    3493</span>              : // keyEncipherment key usages. The TLS library is expected to check for the key</span>
<span id="L3494"><span class="lineNum">    3494</span>              : // usage specific to the negotiated TLS parameters.</span>
<span id="L3495"><span class="lineNum">    3495</span>              : #define X509_PURPOSE_SSL_SERVER 2</span>
<span id="L3496"><span class="lineNum">    3496</span>              : // X509_PURPOSE_NS_SSL_SERVER is a legacy mode. It behaves like</span>
<span id="L3497"><span class="lineNum">    3497</span>              : // |X509_PURPOSE_SSL_SERVER|, but only accepts the keyEncipherment key usage,</span>
<span id="L3498"><span class="lineNum">    3498</span>              : // used by SSL 2.0 and RSA key exchange. Do not use this.</span>
<span id="L3499"><span class="lineNum">    3499</span>              : #define X509_PURPOSE_NS_SSL_SERVER 3</span>
<span id="L3500"><span class="lineNum">    3500</span>              : // X509_PURPOSE_SMIME_SIGN validates S/MIME signing certificates. It checks for</span>
<span id="L3501"><span class="lineNum">    3501</span>              : // the id-kp-emailProtection EKU and one of digitalSignature or nonRepudiation</span>
<span id="L3502"><span class="lineNum">    3502</span>              : // key usages.</span>
<span id="L3503"><span class="lineNum">    3503</span>              : #define X509_PURPOSE_SMIME_SIGN 4</span>
<span id="L3504"><span class="lineNum">    3504</span>              : // X509_PURPOSE_SMIME_ENCRYPT validates S/MIME encryption certificates. It</span>
<span id="L3505"><span class="lineNum">    3505</span>              : // checks for the id-kp-emailProtection EKU and keyEncipherment key usage.</span>
<span id="L3506"><span class="lineNum">    3506</span>              : #define X509_PURPOSE_SMIME_ENCRYPT 5</span>
<span id="L3507"><span class="lineNum">    3507</span>              : // X509_PURPOSE_CRL_SIGN validates indirect CRL signers. It checks for the</span>
<span id="L3508"><span class="lineNum">    3508</span>              : // cRLSign key usage. BoringSSL does not support indirect CRLs and does not use</span>
<span id="L3509"><span class="lineNum">    3509</span>              : // this mode.</span>
<span id="L3510"><span class="lineNum">    3510</span>              : #define X509_PURPOSE_CRL_SIGN 6</span>
<span id="L3511"><span class="lineNum">    3511</span>              : // X509_PURPOSE_ANY performs no EKU or key usage checks. Such checks are the</span>
<span id="L3512"><span class="lineNum">    3512</span>              : // responsibility of the caller.</span>
<span id="L3513"><span class="lineNum">    3513</span>              : #define X509_PURPOSE_ANY 7</span>
<span id="L3514"><span class="lineNum">    3514</span>              : // X509_PURPOSE_OCSP_HELPER performs no EKU or key usage checks. It was</span>
<span id="L3515"><span class="lineNum">    3515</span>              : // historically used in OpenSSL's OCSP implementation, which left those checks</span>
<span id="L3516"><span class="lineNum">    3516</span>              : // to the OCSP implementation itself.</span>
<span id="L3517"><span class="lineNum">    3517</span>              : #define X509_PURPOSE_OCSP_HELPER 8</span>
<span id="L3518"><span class="lineNum">    3518</span>              : // X509_PURPOSE_TIMESTAMP_SIGN validates Time Stamping Authority (RFC 3161)</span>
<span id="L3519"><span class="lineNum">    3519</span>              : // certificates. It checks for the id-kp-timeStamping EKU and one of</span>
<span id="L3520"><span class="lineNum">    3520</span>              : // digitalSignature or nonRepudiation key usages. It additionally checks that</span>
<span id="L3521"><span class="lineNum">    3521</span>              : // the EKU extension is critical and that no other EKUs or key usages are</span>
<span id="L3522"><span class="lineNum">    3522</span>              : // asserted.</span>
<span id="L3523"><span class="lineNum">    3523</span>              : #define X509_PURPOSE_TIMESTAMP_SIGN 9</span>
<span id="L3524"><span class="lineNum">    3524</span>              : </span>
<span id="L3525"><span class="lineNum">    3525</span>              : // X509_VERIFY_PARAM_set_purpose configures |param| to validate certificates for</span>
<span id="L3526"><span class="lineNum">    3526</span>              : // a specified purpose. It returns one on success and zero if |purpose| is not a</span>
<span id="L3527"><span class="lineNum">    3527</span>              : // valid purpose type. |purpose| should be one of the |X509_PURPOSE_*| values.</span>
<span id="L3528"><span class="lineNum">    3528</span>              : //</span>
<span id="L3529"><span class="lineNum">    3529</span>              : // This option controls checking the extended key usage (EKU) and key usage</span>
<span id="L3530"><span class="lineNum">    3530</span>              : // extensions. These extensions specify how a certificate's public key may be</span>
<span id="L3531"><span class="lineNum">    3531</span>              : // used and are important to avoid cross-protocol attacks, particularly in PKIs</span>
<span id="L3532"><span class="lineNum">    3532</span>              : // that may issue certificates for multiple protocols, or for protocols that use</span>
<span id="L3533"><span class="lineNum">    3533</span>              : // keys in multiple ways. If not configured, these security checks are the</span>
<span id="L3534"><span class="lineNum">    3534</span>              : // caller's responsibility.</span>
<span id="L3535"><span class="lineNum">    3535</span>              : //</span>
<span id="L3536"><span class="lineNum">    3536</span>              : // This library applies the EKU checks to all untrusted intermediates. Although</span>
<span id="L3537"><span class="lineNum">    3537</span>              : // not defined in RFC 5280, this matches widely-deployed practice. It also does</span>
<span id="L3538"><span class="lineNum">    3538</span>              : // not accept anyExtendedKeyUsage.</span>
<span id="L3539"><span class="lineNum">    3539</span>              : //</span>
<span id="L3540"><span class="lineNum">    3540</span>              : // Many purpose values have a corresponding trust value, which is not configured</span>
<span id="L3541"><span class="lineNum">    3541</span>              : // by this function.  See |X509_VERIFY_PARAM_set_trust| for details. Callers</span>
<span id="L3542"><span class="lineNum">    3542</span>              : // that wish to configure both should either call both functions, or use</span>
<span id="L3543"><span class="lineNum">    3543</span>              : // |X509_STORE_CTX_set_purpose|.</span>
<span id="L3544"><span class="lineNum">    3544</span>              : //</span>
<span id="L3545"><span class="lineNum">    3545</span>              : // It is currently not possible to configure custom EKU OIDs or key usage bits.</span>
<span id="L3546"><span class="lineNum">    3546</span>              : // Contact the BoringSSL maintainers if your application needs to do so. OpenSSL</span>
<span id="L3547"><span class="lineNum">    3547</span>              : // had an |X509_PURPOSE_add| API, but it was not thread-safe and relied on</span>
<span id="L3548"><span class="lineNum">    3548</span>              : // global mutable state, so we removed it.</span>
<span id="L3549"><span class="lineNum">    3549</span>              : //</span>
<span id="L3550"><span class="lineNum">    3550</span>              : // TODO(davidben): This function additionally configures checking the legacy</span>
<span id="L3551"><span class="lineNum">    3551</span>              : // Netscape certificate type extension. Remove this.</span>
<span id="L3552"><span class="lineNum">    3552</span>              : OPENSSL_EXPORT int X509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *param,</span>
<span id="L3553"><span class="lineNum">    3553</span>              :                                                  int purpose);</span>
<span id="L3554"><span class="lineNum">    3554</span>              : </span>
<span id="L3555"><span class="lineNum">    3555</span>              : // X509_TRUST_COMPAT evaluates trust using only the self-signed fallback. Trust</span>
<span id="L3556"><span class="lineNum">    3556</span>              : // and distrust OIDs are ignored.</span>
<span id="L3557"><span class="lineNum">    3557</span>              : #define X509_TRUST_COMPAT 1</span>
<span id="L3558"><span class="lineNum">    3558</span>              : // X509_TRUST_SSL_CLIENT evaluates trust with the |NID_client_auth| OID, for</span>
<span id="L3559"><span class="lineNum">    3559</span>              : // validating TLS client certificates.</span>
<span id="L3560"><span class="lineNum">    3560</span>              : #define X509_TRUST_SSL_CLIENT 2</span>
<span id="L3561"><span class="lineNum">    3561</span>              : // X509_TRUST_SSL_SERVER evaluates trust with the |NID_server_auth| OID, for</span>
<span id="L3562"><span class="lineNum">    3562</span>              : // validating TLS server certificates.</span>
<span id="L3563"><span class="lineNum">    3563</span>              : #define X509_TRUST_SSL_SERVER 3</span>
<span id="L3564"><span class="lineNum">    3564</span>              : // X509_TRUST_EMAIL evaluates trust with the |NID_email_protect| OID, for</span>
<span id="L3565"><span class="lineNum">    3565</span>              : // validating S/MIME email certificates.</span>
<span id="L3566"><span class="lineNum">    3566</span>              : #define X509_TRUST_EMAIL 4</span>
<span id="L3567"><span class="lineNum">    3567</span>              : // X509_TRUST_OBJECT_SIGN evaluates trust with the |NID_code_sign| OID, for</span>
<span id="L3568"><span class="lineNum">    3568</span>              : // validating code signing certificates.</span>
<span id="L3569"><span class="lineNum">    3569</span>              : #define X509_TRUST_OBJECT_SIGN 5</span>
<span id="L3570"><span class="lineNum">    3570</span>              : // X509_TRUST_TSA evaluates trust with the |NID_time_stamp| OID, for validating</span>
<span id="L3571"><span class="lineNum">    3571</span>              : // Time Stamping Authority (RFC 3161) certificates.</span>
<span id="L3572"><span class="lineNum">    3572</span>              : #define X509_TRUST_TSA 8</span>
<span id="L3573"><span class="lineNum">    3573</span>              : </span>
<span id="L3574"><span class="lineNum">    3574</span>              : // X509_VERIFY_PARAM_set_trust configures which certificates from |X509_STORE|</span>
<span id="L3575"><span class="lineNum">    3575</span>              : // are trust anchors. It returns one on success and zero if |trust| is not a</span>
<span id="L3576"><span class="lineNum">    3576</span>              : // valid trust value. |trust| should be one of the |X509_TRUST_*| constants.</span>
<span id="L3577"><span class="lineNum">    3577</span>              : // This function allows applications to vary trust anchors when the same set of</span>
<span id="L3578"><span class="lineNum">    3578</span>              : // trusted certificates is used in multiple contexts.</span>
<span id="L3579"><span class="lineNum">    3579</span>              : //</span>
<span id="L3580"><span class="lineNum">    3580</span>              : // Two properties determine whether a certificate is a trust anchor:</span>
<span id="L3581"><span class="lineNum">    3581</span>              : //</span>
<span id="L3582"><span class="lineNum">    3582</span>              : // - Whether it is trusted or distrusted for some OID, via auxiliary information</span>
<span id="L3583"><span class="lineNum">    3583</span>              : //   configured by |X509_add1_trust_object| or |X509_add1_reject_object|.</span>
<span id="L3584"><span class="lineNum">    3584</span>              : //</span>
<span id="L3585"><span class="lineNum">    3585</span>              : // - Whether it is &quot;self-signed&quot;. That is, whether |X509_get_extension_flags|</span>
<span id="L3586"><span class="lineNum">    3586</span>              : //   includes |EXFLAG_SS|. The signature itself is not checked.</span>
<span id="L3587"><span class="lineNum">    3587</span>              : //</span>
<span id="L3588"><span class="lineNum">    3588</span>              : // When this function is called, |trust| determines the OID to check in the</span>
<span id="L3589"><span class="lineNum">    3589</span>              : // first case. If the certificate is not explicitly trusted or distrusted for</span>
<span id="L3590"><span class="lineNum">    3590</span>              : // any OID, it is trusted if self-signed instead.</span>
<span id="L3591"><span class="lineNum">    3591</span>              : //</span>
<span id="L3592"><span class="lineNum">    3592</span>              : // If unset, the default behavior is to check for the |NID_anyExtendedKeyUsage|</span>
<span id="L3593"><span class="lineNum">    3593</span>              : // OID. If the certificate is not explicitly trusted or distrusted for this OID,</span>
<span id="L3594"><span class="lineNum">    3594</span>              : // it is trusted if self-signed instead. Note this slightly differs from the</span>
<span id="L3595"><span class="lineNum">    3595</span>              : // above.</span>
<span id="L3596"><span class="lineNum">    3596</span>              : //</span>
<span id="L3597"><span class="lineNum">    3597</span>              : // If the |X509_V_FLAG_PARTIAL_CHAIN| is set, every certificate from</span>
<span id="L3598"><span class="lineNum">    3598</span>              : // |X509_STORE| is a trust anchor, unless it was explicitly distrusted for the</span>
<span id="L3599"><span class="lineNum">    3599</span>              : // OID.</span>
<span id="L3600"><span class="lineNum">    3600</span>              : //</span>
<span id="L3601"><span class="lineNum">    3601</span>              : // It is currently not possible to configure custom trust OIDs. Contact the</span>
<span id="L3602"><span class="lineNum">    3602</span>              : // BoringSSL maintainers if your application needs to do so. OpenSSL had an</span>
<span id="L3603"><span class="lineNum">    3603</span>              : // |X509_TRUST_add| API, but it was not thread-safe and relied on global mutable</span>
<span id="L3604"><span class="lineNum">    3604</span>              : // state, so we removed it.</span>
<span id="L3605"><span class="lineNum">    3605</span>              : OPENSSL_EXPORT int X509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM *param,</span>
<span id="L3606"><span class="lineNum">    3606</span>              :                                                int trust);</span>
<span id="L3607"><span class="lineNum">    3607</span>              : </span>
<span id="L3608"><span class="lineNum">    3608</span>              : </span>
<span id="L3609"><span class="lineNum">    3609</span>              : // Filesystem-based certificate stores.</span>
<span id="L3610"><span class="lineNum">    3610</span>              : //</span>
<span id="L3611"><span class="lineNum">    3611</span>              : // An |X509_STORE| may be configured to get its contents from the filesystem.</span>
<span id="L3612"><span class="lineNum">    3612</span>              : // This is done by adding |X509_LOOKUP| structures to the |X509_STORE| with</span>
<span id="L3613"><span class="lineNum">    3613</span>              : // |X509_STORE_add_lookup| and then configuring the |X509_LOOKUP| with paths.</span>
<span id="L3614"><span class="lineNum">    3614</span>              : //</span>
<span id="L3615"><span class="lineNum">    3615</span>              : // Most cases can use |X509_STORE_load_locations|, which configures the same</span>
<span id="L3616"><span class="lineNum">    3616</span>              : // thing but is simpler to use.</span>
<span id="L3617"><span class="lineNum">    3617</span>              : </span>
<span id="L3618"><span class="lineNum">    3618</span>              : // X509_STORE_load_locations configures |store| to load data from filepaths</span>
<span id="L3619"><span class="lineNum">    3619</span>              : // |file| and |dir|. It returns one on success and zero on error. Either of</span>
<span id="L3620"><span class="lineNum">    3620</span>              : // |file| or |dir| may be NULL, but at least one must be non-NULL.</span>
<span id="L3621"><span class="lineNum">    3621</span>              : //</span>
<span id="L3622"><span class="lineNum">    3622</span>              : // If |file| is non-NULL, it loads CRLs and trusted certificates in PEM format</span>
<span id="L3623"><span class="lineNum">    3623</span>              : // from the file at |file|, and them to |store|, as in |X509_load_cert_crl_file|</span>
<span id="L3624"><span class="lineNum">    3624</span>              : // with |X509_FILETYPE_PEM|.</span>
<span id="L3625"><span class="lineNum">    3625</span>              : //</span>
<span id="L3626"><span class="lineNum">    3626</span>              : // If |dir| is non-NULL, it configures |store| to load CRLs and trusted</span>
<span id="L3627"><span class="lineNum">    3627</span>              : // certificates from the directory at |dir| in PEM format, as in</span>
<span id="L3628"><span class="lineNum">    3628</span>              : // |X509_LOOKUP_add_dir| with |X509_FILETYPE_PEM|.</span>
<span id="L3629"><span class="lineNum">    3629</span>              : OPENSSL_EXPORT int X509_STORE_load_locations(X509_STORE *store,</span>
<span id="L3630"><span class="lineNum">    3630</span>              :                                              const char *file, const char *dir);</span>
<span id="L3631"><span class="lineNum">    3631</span>              : </span>
<span id="L3632"><span class="lineNum">    3632</span>              : // X509_STORE_add_lookup returns an |X509_LOOKUP| associated with |store| with</span>
<span id="L3633"><span class="lineNum">    3633</span>              : // type |method|, or NULL on error. The result is owned by |store|, so callers</span>
<span id="L3634"><span class="lineNum">    3634</span>              : // are not expected to free it. This may be used with |X509_LOOKUP_add_dir| or</span>
<span id="L3635"><span class="lineNum">    3635</span>              : // |X509_LOOKUP_load_file|, depending on |method|, to configure |store|.</span>
<span id="L3636"><span class="lineNum">    3636</span>              : //</span>
<span id="L3637"><span class="lineNum">    3637</span>              : // A single |X509_LOOKUP| may be configured with multiple paths, and an</span>
<span id="L3638"><span class="lineNum">    3638</span>              : // |X509_STORE| only contains one |X509_LOOKUP| of each type, so there is no</span>
<span id="L3639"><span class="lineNum">    3639</span>              : // need to call this function multiple times for a single type. Calling it</span>
<span id="L3640"><span class="lineNum">    3640</span>              : // multiple times will return the previous |X509_LOOKUP| of that type.</span>
<span id="L3641"><span class="lineNum">    3641</span>              : OPENSSL_EXPORT X509_LOOKUP *X509_STORE_add_lookup(</span>
<span id="L3642"><span class="lineNum">    3642</span>              :     X509_STORE *store, const X509_LOOKUP_METHOD *method);</span>
<span id="L3643"><span class="lineNum">    3643</span>              : </span>
<span id="L3644"><span class="lineNum">    3644</span>              : // X509_LOOKUP_hash_dir creates |X509_LOOKUP|s that may be used with</span>
<span id="L3645"><span class="lineNum">    3645</span>              : // |X509_LOOKUP_add_dir|.</span>
<span id="L3646"><span class="lineNum">    3646</span>              : OPENSSL_EXPORT const X509_LOOKUP_METHOD *X509_LOOKUP_hash_dir(void);</span>
<span id="L3647"><span class="lineNum">    3647</span>              : </span>
<span id="L3648"><span class="lineNum">    3648</span>              : // X509_LOOKUP_file creates |X509_LOOKUP|s that may be used with</span>
<span id="L3649"><span class="lineNum">    3649</span>              : // |X509_LOOKUP_load_file|.</span>
<span id="L3650"><span class="lineNum">    3650</span>              : //</span>
<span id="L3651"><span class="lineNum">    3651</span>              : // Although this is modeled as an |X509_LOOKUP|, this function is redundant. It</span>
<span id="L3652"><span class="lineNum">    3652</span>              : // has the same effect as loading a certificate or CRL from the filesystem, in</span>
<span id="L3653"><span class="lineNum">    3653</span>              : // the caller's desired format, and then adding it with |X509_STORE_add_cert|</span>
<span id="L3654"><span class="lineNum">    3654</span>              : // and |X509_STORE_add_crl|.</span>
<span id="L3655"><span class="lineNum">    3655</span>              : OPENSSL_EXPORT const X509_LOOKUP_METHOD *X509_LOOKUP_file(void);</span>
<span id="L3656"><span class="lineNum">    3656</span>              : </span>
<span id="L3657"><span class="lineNum">    3657</span>              : // The following constants are used to specify the format of files in an</span>
<span id="L3658"><span class="lineNum">    3658</span>              : // |X509_LOOKUP|.</span>
<span id="L3659"><span class="lineNum">    3659</span>              : #define X509_FILETYPE_PEM 1</span>
<span id="L3660"><span class="lineNum">    3660</span>              : #define X509_FILETYPE_ASN1 2</span>
<span id="L3661"><span class="lineNum">    3661</span>              : #define X509_FILETYPE_DEFAULT 3</span>
<span id="L3662"><span class="lineNum">    3662</span>              : </span>
<span id="L3663"><span class="lineNum">    3663</span>              : // X509_LOOKUP_load_file calls |X509_load_cert_crl_file|. |lookup| must have</span>
<span id="L3664"><span class="lineNum">    3664</span>              : // been constructed with |X509_LOOKUP_file|.</span>
<span id="L3665"><span class="lineNum">    3665</span>              : //</span>
<span id="L3666"><span class="lineNum">    3666</span>              : // If |type| is |X509_FILETYPE_DEFAULT|, it ignores |file| and instead uses some</span>
<span id="L3667"><span class="lineNum">    3667</span>              : // default system path with |X509_FILETYPE_PEM|. See also</span>
<span id="L3668"><span class="lineNum">    3668</span>              : // |X509_STORE_set_default_paths|.</span>
<span id="L3669"><span class="lineNum">    3669</span>              : OPENSSL_EXPORT int X509_LOOKUP_load_file(X509_LOOKUP *lookup, const char *file,</span>
<span id="L3670"><span class="lineNum">    3670</span>              :                                          int type);</span>
<span id="L3671"><span class="lineNum">    3671</span>              : </span>
<span id="L3672"><span class="lineNum">    3672</span>              : // X509_LOOKUP_add_dir configures |lookup| to load CRLs and trusted certificates</span>
<span id="L3673"><span class="lineNum">    3673</span>              : // from the directories in |path|. It returns one on success and zero on error.</span>
<span id="L3674"><span class="lineNum">    3674</span>              : // |lookup| must have been constructed with |X509_LOOKUP_hash_dir|.</span>
<span id="L3675"><span class="lineNum">    3675</span>              : //</span>
<span id="L3676"><span class="lineNum">    3676</span>              : // WARNING: |path| is interpreted as a colon-separated (semicolon-separated on</span>
<span id="L3677"><span class="lineNum">    3677</span>              : // Windows) list of paths. It is not possible to configure a path containing the</span>
<span id="L3678"><span class="lineNum">    3678</span>              : // separator character. https://crbug.com/boringssl/691 tracks removing this</span>
<span id="L3679"><span class="lineNum">    3679</span>              : // behavior.</span>
<span id="L3680"><span class="lineNum">    3680</span>              : //</span>
<span id="L3681"><span class="lineNum">    3681</span>              : // |type| should be one of the |X509_FILETYPE_*| constants and determines the</span>
<span id="L3682"><span class="lineNum">    3682</span>              : // format of the files. If |type| is |X509_FILETYPE_DEFAULT|, |path| is ignored</span>
<span id="L3683"><span class="lineNum">    3683</span>              : // and some default system path is used with |X509_FILETYPE_PEM|. See also</span>
<span id="L3684"><span class="lineNum">    3684</span>              : // |X509_STORE_set_default_paths|.</span>
<span id="L3685"><span class="lineNum">    3685</span>              : //</span>
<span id="L3686"><span class="lineNum">    3686</span>              : // Trusted certificates should be named HASH.N and CRLs should be</span>
<span id="L3687"><span class="lineNum">    3687</span>              : // named HASH.rN. HASH is |X509_NAME_hash| of the certificate subject and CRL</span>
<span id="L3688"><span class="lineNum">    3688</span>              : // issuer, respectively, in hexadecimal. N is in decimal and counts hash</span>
<span id="L3689"><span class="lineNum">    3689</span>              : // collisions consecutively, starting from zero. For example, &quot;002c0b4f.0&quot; and</span>
<span id="L3690"><span class="lineNum">    3690</span>              : // &quot;002c0b4f.r0&quot;.</span>
<span id="L3691"><span class="lineNum">    3691</span>              : //</span>
<span id="L3692"><span class="lineNum">    3692</span>              : // WARNING: Objects from |path| are loaded on demand, but cached in memory on</span>
<span id="L3693"><span class="lineNum">    3693</span>              : // the |X509_STORE|. If a CA is removed from the directory, existing</span>
<span id="L3694"><span class="lineNum">    3694</span>              : // |X509_STORE|s will continue to trust it. Cache entries are not evicted for</span>
<span id="L3695"><span class="lineNum">    3695</span>              : // the lifetime of the |X509_STORE|.</span>
<span id="L3696"><span class="lineNum">    3696</span>              : //</span>
<span id="L3697"><span class="lineNum">    3697</span>              : // WARNING: This mechanism is also not well-suited for CRL updates.</span>
<span id="L3698"><span class="lineNum">    3698</span>              : // |X509_STORE|s rely on this cache and never load the same CRL file twice. CRL</span>
<span id="L3699"><span class="lineNum">    3699</span>              : // updates must use a new file, with an incremented suffix, to be reflected in</span>
<span id="L3700"><span class="lineNum">    3700</span>              : // existing |X509_STORE|s. However, this means each CRL update will use</span>
<span id="L3701"><span class="lineNum">    3701</span>              : // additional storage and memory. Instead, configure inputs that vary per</span>
<span id="L3702"><span class="lineNum">    3702</span>              : // verification, such as CRLs, on each |X509_STORE_CTX| separately, using</span>
<span id="L3703"><span class="lineNum">    3703</span>              : // functions like |X509_STORE_CTX_set0_crl|.</span>
<span id="L3704"><span class="lineNum">    3704</span>              : OPENSSL_EXPORT int X509_LOOKUP_add_dir(X509_LOOKUP *lookup, const char *path,</span>
<span id="L3705"><span class="lineNum">    3705</span>              :                                        int type);</span>
<span id="L3706"><span class="lineNum">    3706</span>              : </span>
<span id="L3707"><span class="lineNum">    3707</span>              : // X509_L_* are commands for |X509_LOOKUP_ctrl|.</span>
<span id="L3708"><span class="lineNum">    3708</span>              : #define X509_L_FILE_LOAD 1</span>
<span id="L3709"><span class="lineNum">    3709</span>              : #define X509_L_ADD_DIR 2</span>
<span id="L3710"><span class="lineNum">    3710</span>              : </span>
<span id="L3711"><span class="lineNum">    3711</span>              : // X509_LOOKUP_ctrl implements commands on |lookup|. |cmd| specifies the</span>
<span id="L3712"><span class="lineNum">    3712</span>              : // command. The other arguments specify the operation in a command-specific way.</span>
<span id="L3713"><span class="lineNum">    3713</span>              : // Use |X509_LOOKUP_load_file| or |X509_LOOKUP_add_dir| instead.</span>
<span id="L3714"><span class="lineNum">    3714</span>              : OPENSSL_EXPORT int X509_LOOKUP_ctrl(X509_LOOKUP *lookup, int cmd,</span>
<span id="L3715"><span class="lineNum">    3715</span>              :                                     const char *argc, long argl, char **ret);</span>
<span id="L3716"><span class="lineNum">    3716</span>              : </span>
<span id="L3717"><span class="lineNum">    3717</span>              : // X509_load_cert_file loads trusted certificates from |file| and adds them to</span>
<span id="L3718"><span class="lineNum">    3718</span>              : // |lookup|'s |X509_STORE|. It returns one on success and zero on error.</span>
<span id="L3719"><span class="lineNum">    3719</span>              : //</span>
<span id="L3720"><span class="lineNum">    3720</span>              : // If |type| is |X509_FILETYPE_ASN1|, it loads a single DER-encoded certificate.</span>
<span id="L3721"><span class="lineNum">    3721</span>              : // If |type| is |X509_FILETYPE_PEM|, it loads a sequence of PEM-encoded</span>
<span id="L3722"><span class="lineNum">    3722</span>              : // certificates. |type| may not be |X509_FILETYPE_DEFAULT|.</span>
<span id="L3723"><span class="lineNum">    3723</span>              : OPENSSL_EXPORT int X509_load_cert_file(X509_LOOKUP *lookup, const char *file,</span>
<span id="L3724"><span class="lineNum">    3724</span>              :                                        int type);</span>
<span id="L3725"><span class="lineNum">    3725</span>              : </span>
<span id="L3726"><span class="lineNum">    3726</span>              : // X509_load_crl_file loads CRLs from |file| and add them it to |lookup|'s</span>
<span id="L3727"><span class="lineNum">    3727</span>              : // |X509_STORE|. It returns one on success and zero on error.</span>
<span id="L3728"><span class="lineNum">    3728</span>              : //</span>
<span id="L3729"><span class="lineNum">    3729</span>              : // If |type| is |X509_FILETYPE_ASN1|, it loads a single DER-encoded CRL. If</span>
<span id="L3730"><span class="lineNum">    3730</span>              : // |type| is |X509_FILETYPE_PEM|, it loads a sequence of PEM-encoded CRLs.</span>
<span id="L3731"><span class="lineNum">    3731</span>              : // |type| may not be |X509_FILETYPE_DEFAULT|.</span>
<span id="L3732"><span class="lineNum">    3732</span>              : OPENSSL_EXPORT int X509_load_crl_file(X509_LOOKUP *lookup, const char *file,</span>
<span id="L3733"><span class="lineNum">    3733</span>              :                                       int type);</span>
<span id="L3734"><span class="lineNum">    3734</span>              : </span>
<span id="L3735"><span class="lineNum">    3735</span>              : // X509_load_cert_crl_file loads CRLs and trusted certificates from |file| and</span>
<span id="L3736"><span class="lineNum">    3736</span>              : // adds them to |lookup|'s |X509_STORE|. It returns one on success and zero on</span>
<span id="L3737"><span class="lineNum">    3737</span>              : // error.</span>
<span id="L3738"><span class="lineNum">    3738</span>              : //</span>
<span id="L3739"><span class="lineNum">    3739</span>              : // If |type| is |X509_FILETYPE_ASN1|, it loads a single DER-encoded certificate.</span>
<span id="L3740"><span class="lineNum">    3740</span>              : // This function cannot be used to load a DER-encoded CRL. If |type| is</span>
<span id="L3741"><span class="lineNum">    3741</span>              : // |X509_FILETYPE_PEM|, it loads a sequence of PEM-encoded certificates and</span>
<span id="L3742"><span class="lineNum">    3742</span>              : // CRLs. |type| may not be |X509_FILETYPE_DEFAULT|.</span>
<span id="L3743"><span class="lineNum">    3743</span>              : OPENSSL_EXPORT int X509_load_cert_crl_file(X509_LOOKUP *lookup,</span>
<span id="L3744"><span class="lineNum">    3744</span>              :                                            const char *file, int type);</span>
<span id="L3745"><span class="lineNum">    3745</span>              : </span>
<span id="L3746"><span class="lineNum">    3746</span>              : // X509_NAME_hash returns a hash of |name|, or zero on error. This is the new</span>
<span id="L3747"><span class="lineNum">    3747</span>              : // hash used by |X509_LOOKUP_add_dir|.</span>
<span id="L3748"><span class="lineNum">    3748</span>              : //</span>
<span id="L3749"><span class="lineNum">    3749</span>              : // This hash is specific to the |X509_LOOKUP_add_dir| filesystem format and is</span>
<span id="L3750"><span class="lineNum">    3750</span>              : // not suitable for general-purpose X.509 name processing. It is very short, so</span>
<span id="L3751"><span class="lineNum">    3751</span>              : // there will be hash collisions. It also depends on an OpenSSL-specific</span>
<span id="L3752"><span class="lineNum">    3752</span>              : // canonicalization process.</span>
<span id="L3753"><span class="lineNum">    3753</span>              : //</span>
<span id="L3754"><span class="lineNum">    3754</span>              : // TODO(https://crbug.com/boringssl/407): This should be const and thread-safe</span>
<span id="L3755"><span class="lineNum">    3755</span>              : // but currently is neither, notably if |name| was modified from its parsed</span>
<span id="L3756"><span class="lineNum">    3756</span>              : // value.</span>
<span id="L3757"><span class="lineNum">    3757</span>              : OPENSSL_EXPORT uint32_t X509_NAME_hash(X509_NAME *name);</span>
<span id="L3758"><span class="lineNum">    3758</span>              : </span>
<span id="L3759"><span class="lineNum">    3759</span>              : // X509_NAME_hash_old returns a hash of |name|, or zero on error. This is the</span>
<span id="L3760"><span class="lineNum">    3760</span>              : // legacy hash used by |X509_LOOKUP_add_dir|, which is still supported for</span>
<span id="L3761"><span class="lineNum">    3761</span>              : // compatibility.</span>
<span id="L3762"><span class="lineNum">    3762</span>              : //</span>
<span id="L3763"><span class="lineNum">    3763</span>              : // This hash is specific to the |X509_LOOKUP_add_dir| filesystem format and is</span>
<span id="L3764"><span class="lineNum">    3764</span>              : // not suitable for general-purpose X.509 name processing. It is very short, so</span>
<span id="L3765"><span class="lineNum">    3765</span>              : // there will be hash collisions.</span>
<span id="L3766"><span class="lineNum">    3766</span>              : //</span>
<span id="L3767"><span class="lineNum">    3767</span>              : // TODO(https://crbug.com/boringssl/407): This should be const and thread-safe</span>
<span id="L3768"><span class="lineNum">    3768</span>              : // but currently is neither, notably if |name| was modified from its parsed</span>
<span id="L3769"><span class="lineNum">    3769</span>              : // value.</span>
<span id="L3770"><span class="lineNum">    3770</span>              : OPENSSL_EXPORT uint32_t X509_NAME_hash_old(X509_NAME *name);</span>
<span id="L3771"><span class="lineNum">    3771</span>              : </span>
<span id="L3772"><span class="lineNum">    3772</span>              : // X509_STORE_set_default_paths configures |store| to read from some &quot;default&quot;</span>
<span id="L3773"><span class="lineNum">    3773</span>              : // filesystem paths. It returns one on success and zero on error. The filesystem</span>
<span id="L3774"><span class="lineNum">    3774</span>              : // paths are determined by a combination of hardcoded paths and the SSL_CERT_DIR</span>
<span id="L3775"><span class="lineNum">    3775</span>              : // and SSL_CERT_FILE environment variables.</span>
<span id="L3776"><span class="lineNum">    3776</span>              : //</span>
<span id="L3777"><span class="lineNum">    3777</span>              : // Using this function is not recommended. In OpenSSL, these defaults are</span>
<span id="L3778"><span class="lineNum">    3778</span>              : // determined by OpenSSL's install prefix. There is no corresponding concept for</span>
<span id="L3779"><span class="lineNum">    3779</span>              : // BoringSSL. Future versions of BoringSSL may change or remove this</span>
<span id="L3780"><span class="lineNum">    3780</span>              : // functionality.</span>
<span id="L3781"><span class="lineNum">    3781</span>              : OPENSSL_EXPORT int X509_STORE_set_default_paths(X509_STORE *store);</span>
<span id="L3782"><span class="lineNum">    3782</span>              : </span>
<span id="L3783"><span class="lineNum">    3783</span>              : // The following functions return filesystem paths used to determine the above</span>
<span id="L3784"><span class="lineNum">    3784</span>              : // &quot;default&quot; paths, when the corresponding environment variables are not set.</span>
<span id="L3785"><span class="lineNum">    3785</span>              : //</span>
<span id="L3786"><span class="lineNum">    3786</span>              : // Using these functions is not recommended. In OpenSSL, these defaults are</span>
<span id="L3787"><span class="lineNum">    3787</span>              : // determined by OpenSSL's install prefix. There is no corresponding concept for</span>
<span id="L3788"><span class="lineNum">    3788</span>              : // BoringSSL. Future versions of BoringSSL may change or remove this</span>
<span id="L3789"><span class="lineNum">    3789</span>              : // functionality.</span>
<span id="L3790"><span class="lineNum">    3790</span>              : OPENSSL_EXPORT const char *X509_get_default_cert_area(void);</span>
<span id="L3791"><span class="lineNum">    3791</span>              : OPENSSL_EXPORT const char *X509_get_default_cert_dir(void);</span>
<span id="L3792"><span class="lineNum">    3792</span>              : OPENSSL_EXPORT const char *X509_get_default_cert_file(void);</span>
<span id="L3793"><span class="lineNum">    3793</span>              : OPENSSL_EXPORT const char *X509_get_default_private_dir(void);</span>
<span id="L3794"><span class="lineNum">    3794</span>              : </span>
<span id="L3795"><span class="lineNum">    3795</span>              : // X509_get_default_cert_dir_env returns &quot;SSL_CERT_DIR&quot;, an environment variable</span>
<span id="L3796"><span class="lineNum">    3796</span>              : // used to determine the above &quot;default&quot; paths.</span>
<span id="L3797"><span class="lineNum">    3797</span>              : OPENSSL_EXPORT const char *X509_get_default_cert_dir_env(void);</span>
<span id="L3798"><span class="lineNum">    3798</span>              : </span>
<span id="L3799"><span class="lineNum">    3799</span>              : // X509_get_default_cert_file_env returns &quot;SSL_CERT_FILE&quot;, an environment</span>
<span id="L3800"><span class="lineNum">    3800</span>              : // variable used to determine the above &quot;default&quot; paths.</span>
<span id="L3801"><span class="lineNum">    3801</span>              : OPENSSL_EXPORT const char *X509_get_default_cert_file_env(void);</span>
<span id="L3802"><span class="lineNum">    3802</span>              : </span>
<span id="L3803"><span class="lineNum">    3803</span>              : </span>
<span id="L3804"><span class="lineNum">    3804</span>              : // SignedPublicKeyAndChallenge structures.</span>
<span id="L3805"><span class="lineNum">    3805</span>              : //</span>
<span id="L3806"><span class="lineNum">    3806</span>              : // The SignedPublicKeyAndChallenge (SPKAC) is a legacy structure to request</span>
<span id="L3807"><span class="lineNum">    3807</span>              : // certificates, primarily in the legacy &lt;keygen&gt; HTML tag. An SPKAC structure</span>
<span id="L3808"><span class="lineNum">    3808</span>              : // is represented by a |NETSCAPE_SPKI| structure.</span>
<span id="L3809"><span class="lineNum">    3809</span>              : //</span>
<span id="L3810"><span class="lineNum">    3810</span>              : // The structure is described in</span>
<span id="L3811"><span class="lineNum">    3811</span>              : // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/keygen</span>
<span id="L3812"><span class="lineNum">    3812</span>              : </span>
<span id="L3813"><span class="lineNum">    3813</span>              : // A Netscape_spki_st, or |NETSCAPE_SPKI|, represents a</span>
<span id="L3814"><span class="lineNum">    3814</span>              : // SignedPublicKeyAndChallenge structure. Although this structure contains a</span>
<span id="L3815"><span class="lineNum">    3815</span>              : // |spkac| field of type |NETSCAPE_SPKAC|, these are misnamed. The SPKAC is the</span>
<span id="L3816"><span class="lineNum">    3816</span>              : // entire structure, not the signed portion.</span>
<span id="L3817"><span class="lineNum">    3817</span>              : struct Netscape_spki_st {</span>
<span id="L3818"><span class="lineNum">    3818</span>              :   NETSCAPE_SPKAC *spkac;</span>
<span id="L3819"><span class="lineNum">    3819</span>              :   X509_ALGOR *sig_algor;</span>
<span id="L3820"><span class="lineNum">    3820</span>              :   ASN1_BIT_STRING *signature;</span>
<span id="L3821"><span class="lineNum">    3821</span>              : } /* NETSCAPE_SPKI */;</span>
<span id="L3822"><span class="lineNum">    3822</span>              : </span>
<span id="L3823"><span class="lineNum">    3823</span>              : // NETSCAPE_SPKI_new returns a newly-allocated, empty |NETSCAPE_SPKI| object, or</span>
<span id="L3824"><span class="lineNum">    3824</span>              : // NULL on error.</span>
<span id="L3825"><span class="lineNum">    3825</span>              : OPENSSL_EXPORT NETSCAPE_SPKI *NETSCAPE_SPKI_new(void);</span>
<span id="L3826"><span class="lineNum">    3826</span>              : </span>
<span id="L3827"><span class="lineNum">    3827</span>              : // NETSCAPE_SPKI_free releases memory associated with |spki|.</span>
<span id="L3828"><span class="lineNum">    3828</span>              : OPENSSL_EXPORT void NETSCAPE_SPKI_free(NETSCAPE_SPKI *spki);</span>
<span id="L3829"><span class="lineNum">    3829</span>              : </span>
<span id="L3830"><span class="lineNum">    3830</span>              : // d2i_NETSCAPE_SPKI parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L3831"><span class="lineNum">    3831</span>              : // SignedPublicKeyAndChallenge structure, as described in |d2i_SAMPLE|.</span>
<span id="L3832"><span class="lineNum">    3832</span>              : OPENSSL_EXPORT NETSCAPE_SPKI *d2i_NETSCAPE_SPKI(NETSCAPE_SPKI **out,</span>
<span id="L3833"><span class="lineNum">    3833</span>              :                                                 const uint8_t **inp, long len);</span>
<span id="L3834"><span class="lineNum">    3834</span>              : </span>
<span id="L3835"><span class="lineNum">    3835</span>              : // i2d_NETSCAPE_SPKI marshals |spki| as a DER-encoded</span>
<span id="L3836"><span class="lineNum">    3836</span>              : // SignedPublicKeyAndChallenge structure, as described in |i2d_SAMPLE|.</span>
<span id="L3837"><span class="lineNum">    3837</span>              : OPENSSL_EXPORT int i2d_NETSCAPE_SPKI(const NETSCAPE_SPKI *spki, uint8_t **outp);</span>
<span id="L3838"><span class="lineNum">    3838</span>              : </span>
<span id="L3839"><span class="lineNum">    3839</span>              : // NETSCAPE_SPKI_verify checks that |spki| has a valid signature by |pkey|. It</span>
<span id="L3840"><span class="lineNum">    3840</span>              : // returns one if the signature is valid and zero otherwise.</span>
<span id="L3841"><span class="lineNum">    3841</span>              : OPENSSL_EXPORT int NETSCAPE_SPKI_verify(NETSCAPE_SPKI *spki, EVP_PKEY *pkey);</span>
<span id="L3842"><span class="lineNum">    3842</span>              : </span>
<span id="L3843"><span class="lineNum">    3843</span>              : // NETSCAPE_SPKI_b64_decode decodes |len| bytes from |str| as a base64-encoded</span>
<span id="L3844"><span class="lineNum">    3844</span>              : // SignedPublicKeyAndChallenge structure. It returns a newly-allocated</span>
<span id="L3845"><span class="lineNum">    3845</span>              : // |NETSCAPE_SPKI| structure with the result, or NULL on error. If |len| is 0 or</span>
<span id="L3846"><span class="lineNum">    3846</span>              : // negative, the length is calculated with |strlen| and |str| must be a</span>
<span id="L3847"><span class="lineNum">    3847</span>              : // NUL-terminated C string.</span>
<span id="L3848"><span class="lineNum">    3848</span>              : OPENSSL_EXPORT NETSCAPE_SPKI *NETSCAPE_SPKI_b64_decode(const char *str,</span>
<span id="L3849"><span class="lineNum">    3849</span>              :                                                        ossl_ssize_t len);</span>
<span id="L3850"><span class="lineNum">    3850</span>              : </span>
<span id="L3851"><span class="lineNum">    3851</span>              : // NETSCAPE_SPKI_b64_encode encodes |spki| as a base64-encoded</span>
<span id="L3852"><span class="lineNum">    3852</span>              : // SignedPublicKeyAndChallenge structure. It returns a newly-allocated</span>
<span id="L3853"><span class="lineNum">    3853</span>              : // NUL-terminated C string with the result, or NULL on error. The caller must</span>
<span id="L3854"><span class="lineNum">    3854</span>              : // release the memory with |OPENSSL_free| when done.</span>
<span id="L3855"><span class="lineNum">    3855</span>              : OPENSSL_EXPORT char *NETSCAPE_SPKI_b64_encode(NETSCAPE_SPKI *spki);</span>
<span id="L3856"><span class="lineNum">    3856</span>              : </span>
<span id="L3857"><span class="lineNum">    3857</span>              : // NETSCAPE_SPKI_get_pubkey decodes and returns the public key in |spki| as an</span>
<span id="L3858"><span class="lineNum">    3858</span>              : // |EVP_PKEY|, or NULL on error. The caller takes ownership of the resulting</span>
<span id="L3859"><span class="lineNum">    3859</span>              : // pointer and must call |EVP_PKEY_free| when done.</span>
<span id="L3860"><span class="lineNum">    3860</span>              : OPENSSL_EXPORT EVP_PKEY *NETSCAPE_SPKI_get_pubkey(const NETSCAPE_SPKI *spki);</span>
<span id="L3861"><span class="lineNum">    3861</span>              : </span>
<span id="L3862"><span class="lineNum">    3862</span>              : // NETSCAPE_SPKI_set_pubkey sets |spki|'s public key to |pkey|. It returns one</span>
<span id="L3863"><span class="lineNum">    3863</span>              : // on success or zero on error. This function does not take ownership of |pkey|,</span>
<span id="L3864"><span class="lineNum">    3864</span>              : // so the caller may continue to manage its lifetime independently of |spki|.</span>
<span id="L3865"><span class="lineNum">    3865</span>              : OPENSSL_EXPORT int NETSCAPE_SPKI_set_pubkey(NETSCAPE_SPKI *spki,</span>
<span id="L3866"><span class="lineNum">    3866</span>              :                                             EVP_PKEY *pkey);</span>
<span id="L3867"><span class="lineNum">    3867</span>              : </span>
<span id="L3868"><span class="lineNum">    3868</span>              : // NETSCAPE_SPKI_sign signs |spki| with |pkey| and replaces the signature</span>
<span id="L3869"><span class="lineNum">    3869</span>              : // algorithm and signature fields. It returns the length of the signature on</span>
<span id="L3870"><span class="lineNum">    3870</span>              : // success and zero on error. This function uses digest algorithm |md|, or</span>
<span id="L3871"><span class="lineNum">    3871</span>              : // |pkey|'s default if NULL. Other signing parameters use |pkey|'s defaults.</span>
<span id="L3872"><span class="lineNum">    3872</span>              : OPENSSL_EXPORT int NETSCAPE_SPKI_sign(NETSCAPE_SPKI *spki, EVP_PKEY *pkey,</span>
<span id="L3873"><span class="lineNum">    3873</span>              :                                       const EVP_MD *md);</span>
<span id="L3874"><span class="lineNum">    3874</span>              : </span>
<span id="L3875"><span class="lineNum">    3875</span>              : // A Netscape_spkac_st, or |NETSCAPE_SPKAC|, represents a PublicKeyAndChallenge</span>
<span id="L3876"><span class="lineNum">    3876</span>              : // structure. This type is misnamed. The full SPKAC includes the signature,</span>
<span id="L3877"><span class="lineNum">    3877</span>              : // which is represented with the |NETSCAPE_SPKI| type.</span>
<span id="L3878"><span class="lineNum">    3878</span>              : struct Netscape_spkac_st {</span>
<span id="L3879"><span class="lineNum">    3879</span>              :   X509_PUBKEY *pubkey;</span>
<span id="L3880"><span class="lineNum">    3880</span>              :   ASN1_IA5STRING *challenge;</span>
<span id="L3881"><span class="lineNum">    3881</span>              : } /* NETSCAPE_SPKAC */;</span>
<span id="L3882"><span class="lineNum">    3882</span>              : </span>
<span id="L3883"><span class="lineNum">    3883</span>              : // NETSCAPE_SPKAC_new returns a newly-allocated, empty |NETSCAPE_SPKAC| object,</span>
<span id="L3884"><span class="lineNum">    3884</span>              : // or NULL on error.</span>
<span id="L3885"><span class="lineNum">    3885</span>              : OPENSSL_EXPORT NETSCAPE_SPKAC *NETSCAPE_SPKAC_new(void);</span>
<span id="L3886"><span class="lineNum">    3886</span>              : </span>
<span id="L3887"><span class="lineNum">    3887</span>              : // NETSCAPE_SPKAC_free releases memory associated with |spkac|.</span>
<span id="L3888"><span class="lineNum">    3888</span>              : OPENSSL_EXPORT void NETSCAPE_SPKAC_free(NETSCAPE_SPKAC *spkac);</span>
<span id="L3889"><span class="lineNum">    3889</span>              : </span>
<span id="L3890"><span class="lineNum">    3890</span>              : // d2i_NETSCAPE_SPKAC parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L3891"><span class="lineNum">    3891</span>              : // PublicKeyAndChallenge structure, as described in |d2i_SAMPLE|.</span>
<span id="L3892"><span class="lineNum">    3892</span>              : OPENSSL_EXPORT NETSCAPE_SPKAC *d2i_NETSCAPE_SPKAC(NETSCAPE_SPKAC **out,</span>
<span id="L3893"><span class="lineNum">    3893</span>              :                                                   const uint8_t **inp,</span>
<span id="L3894"><span class="lineNum">    3894</span>              :                                                   long len);</span>
<span id="L3895"><span class="lineNum">    3895</span>              : </span>
<span id="L3896"><span class="lineNum">    3896</span>              : // i2d_NETSCAPE_SPKAC marshals |spkac| as a DER-encoded PublicKeyAndChallenge</span>
<span id="L3897"><span class="lineNum">    3897</span>              : // structure, as described in |i2d_SAMPLE|.</span>
<span id="L3898"><span class="lineNum">    3898</span>              : OPENSSL_EXPORT int i2d_NETSCAPE_SPKAC(const NETSCAPE_SPKAC *spkac,</span>
<span id="L3899"><span class="lineNum">    3899</span>              :                                       uint8_t **outp);</span>
<span id="L3900"><span class="lineNum">    3900</span>              : </span>
<span id="L3901"><span class="lineNum">    3901</span>              : </span>
<span id="L3902"><span class="lineNum">    3902</span>              : // RSASSA-PSS Parameters.</span>
<span id="L3903"><span class="lineNum">    3903</span>              : //</span>
<span id="L3904"><span class="lineNum">    3904</span>              : // In X.509, RSASSA-PSS signatures and keys use a complex parameter structure,</span>
<span id="L3905"><span class="lineNum">    3905</span>              : // defined in RFC 4055. The following functions are provided for compatibility</span>
<span id="L3906"><span class="lineNum">    3906</span>              : // with some OpenSSL APIs relating to this. Use of RSASSA-PSS in X.509 is</span>
<span id="L3907"><span class="lineNum">    3907</span>              : // discouraged. The parameters structure is very complex, and it takes more</span>
<span id="L3908"><span class="lineNum">    3908</span>              : // bytes to merely encode parameters than an entire P-256 ECDSA signature.</span>
<span id="L3909"><span class="lineNum">    3909</span>              : </span>
<span id="L3910"><span class="lineNum">    3910</span>              : // An rsa_pss_params_st, aka |RSA_PSS_PARAMS|, represents a parsed</span>
<span id="L3911"><span class="lineNum">    3911</span>              : // RSASSA-PSS-params structure, as defined in (RFC 4055).</span>
<span id="L3912"><span class="lineNum">    3912</span>              : struct rsa_pss_params_st {</span>
<span id="L3913"><span class="lineNum">    3913</span>              :   X509_ALGOR *hashAlgorithm;</span>
<span id="L3914"><span class="lineNum">    3914</span>              :   X509_ALGOR *maskGenAlgorithm;</span>
<span id="L3915"><span class="lineNum">    3915</span>              :   ASN1_INTEGER *saltLength;</span>
<span id="L3916"><span class="lineNum">    3916</span>              :   ASN1_INTEGER *trailerField;</span>
<span id="L3917"><span class="lineNum">    3917</span>              :   // OpenSSL caches the MGF hash on |RSA_PSS_PARAMS| in some cases. None of the</span>
<span id="L3918"><span class="lineNum">    3918</span>              :   // cases apply to BoringSSL, so this is always NULL, but Node expects the</span>
<span id="L3919"><span class="lineNum">    3919</span>              :   // field to be present.</span>
<span id="L3920"><span class="lineNum">    3920</span>              :   X509_ALGOR *maskHash;</span>
<span id="L3921"><span class="lineNum">    3921</span>              : } /* RSA_PSS_PARAMS */;</span>
<span id="L3922"><span class="lineNum">    3922</span>              : </span>
<span id="L3923"><span class="lineNum">    3923</span>              : // RSA_PSS_PARAMS is an |ASN1_ITEM| whose ASN.1 type is RSASSA-PSS-params (RFC</span>
<span id="L3924"><span class="lineNum">    3924</span>              : // 4055) and C type is |RSA_PSS_PARAMS*|.</span>
<span id="L3925"><span class="lineNum">    3925</span>              : DECLARE_ASN1_ITEM(RSA_PSS_PARAMS)</span>
<span id="L3926"><span class="lineNum">    3926</span>              : </span>
<span id="L3927"><span class="lineNum">    3927</span>              : // RSA_PSS_PARAMS_new returns a new, empty |RSA_PSS_PARAMS|, or NULL on error.</span>
<span id="L3928"><span class="lineNum">    3928</span>              : OPENSSL_EXPORT RSA_PSS_PARAMS *RSA_PSS_PARAMS_new(void);</span>
<span id="L3929"><span class="lineNum">    3929</span>              : </span>
<span id="L3930"><span class="lineNum">    3930</span>              : // RSA_PSS_PARAMS_free releases memory associated with |params|.</span>
<span id="L3931"><span class="lineNum">    3931</span>              : OPENSSL_EXPORT void RSA_PSS_PARAMS_free(RSA_PSS_PARAMS *params);</span>
<span id="L3932"><span class="lineNum">    3932</span>              : </span>
<span id="L3933"><span class="lineNum">    3933</span>              : // d2i_RSA_PSS_PARAMS parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L3934"><span class="lineNum">    3934</span>              : // RSASSA-PSS-params (RFC 4055), as described in |d2i_SAMPLE|.</span>
<span id="L3935"><span class="lineNum">    3935</span>              : OPENSSL_EXPORT RSA_PSS_PARAMS *d2i_RSA_PSS_PARAMS(RSA_PSS_PARAMS **out,</span>
<span id="L3936"><span class="lineNum">    3936</span>              :                                                   const uint8_t **inp,</span>
<span id="L3937"><span class="lineNum">    3937</span>              :                                                   long len);</span>
<span id="L3938"><span class="lineNum">    3938</span>              : </span>
<span id="L3939"><span class="lineNum">    3939</span>              : // i2d_RSA_PSS_PARAMS marshals |in| as a DER-encoded RSASSA-PSS-params (RFC</span>
<span id="L3940"><span class="lineNum">    3940</span>              : // 4055), as described in |i2d_SAMPLE|.</span>
<span id="L3941"><span class="lineNum">    3941</span>              : OPENSSL_EXPORT int i2d_RSA_PSS_PARAMS(const RSA_PSS_PARAMS *in, uint8_t **outp);</span>
<span id="L3942"><span class="lineNum">    3942</span>              : </span>
<span id="L3943"><span class="lineNum">    3943</span>              : </span>
<span id="L3944"><span class="lineNum">    3944</span>              : // PKCS#8 private keys.</span>
<span id="L3945"><span class="lineNum">    3945</span>              : //</span>
<span id="L3946"><span class="lineNum">    3946</span>              : // The |PKCS8_PRIV_KEY_INFO| type represents a PKCS#8 PrivateKeyInfo (RFC 5208)</span>
<span id="L3947"><span class="lineNum">    3947</span>              : // structure. This is analogous to SubjectPublicKeyInfo and uses the same</span>
<span id="L3948"><span class="lineNum">    3948</span>              : // AlgorithmIdentifiers, but carries private keys and is not part of X.509</span>
<span id="L3949"><span class="lineNum">    3949</span>              : // itself.</span>
<span id="L3950"><span class="lineNum">    3950</span>              : //</span>
<span id="L3951"><span class="lineNum">    3951</span>              : // TODO(davidben): Do these functions really belong in this header?</span>
<span id="L3952"><span class="lineNum">    3952</span>              : </span>
<span id="L3953"><span class="lineNum">    3953</span>              : // PKCS8_PRIV_KEY_INFO_new returns a newly-allocated, empty</span>
<span id="L3954"><span class="lineNum">    3954</span>              : // |PKCS8_PRIV_KEY_INFO| object, or NULL on error.</span>
<span id="L3955"><span class="lineNum">    3955</span>              : OPENSSL_EXPORT PKCS8_PRIV_KEY_INFO *PKCS8_PRIV_KEY_INFO_new(void);</span>
<span id="L3956"><span class="lineNum">    3956</span>              : </span>
<span id="L3957"><span class="lineNum">    3957</span>              : // PKCS8_PRIV_KEY_INFO_free releases memory associated with |key|.</span>
<span id="L3958"><span class="lineNum">    3958</span>              : OPENSSL_EXPORT void PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO *key);</span>
<span id="L3959"><span class="lineNum">    3959</span>              : </span>
<span id="L3960"><span class="lineNum">    3960</span>              : // d2i_PKCS8_PRIV_KEY_INFO parses up to |len| bytes from |*inp| as a DER-encoded</span>
<span id="L3961"><span class="lineNum">    3961</span>              : // PrivateKeyInfo, as described in |d2i_SAMPLE|.</span>
<span id="L3962"><span class="lineNum">    3962</span>              : OPENSSL_EXPORT PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO(</span>
<span id="L3963"><span class="lineNum">    3963</span>              :     PKCS8_PRIV_KEY_INFO **out, const uint8_t **inp, long len);</span>
<span id="L3964"><span class="lineNum">    3964</span>              : </span>
<span id="L3965"><span class="lineNum">    3965</span>              : // i2d_PKCS8_PRIV_KEY_INFO marshals |key| as a DER-encoded PrivateKeyInfo, as</span>
<span id="L3966"><span class="lineNum">    3966</span>              : // described in |i2d_SAMPLE|.</span>
<span id="L3967"><span class="lineNum">    3967</span>              : OPENSSL_EXPORT int i2d_PKCS8_PRIV_KEY_INFO(const PKCS8_PRIV_KEY_INFO *key,</span>
<span id="L3968"><span class="lineNum">    3968</span>              :                                            uint8_t **outp);</span>
<span id="L3969"><span class="lineNum">    3969</span>              : </span>
<span id="L3970"><span class="lineNum">    3970</span>              : // EVP_PKCS82PKEY returns |p8| as a newly-allocated |EVP_PKEY|, or NULL if the</span>
<span id="L3971"><span class="lineNum">    3971</span>              : // key was unsupported or could not be decoded. The caller must release the</span>
<span id="L3972"><span class="lineNum">    3972</span>              : // result with |EVP_PKEY_free| when done.</span>
<span id="L3973"><span class="lineNum">    3973</span>              : //</span>
<span id="L3974"><span class="lineNum">    3974</span>              : // Use |EVP_parse_private_key| instead.</span>
<span id="L3975"><span class="lineNum">    3975</span>              : OPENSSL_EXPORT EVP_PKEY *EVP_PKCS82PKEY(const PKCS8_PRIV_KEY_INFO *p8);</span>
<span id="L3976"><span class="lineNum">    3976</span>              : </span>
<span id="L3977"><span class="lineNum">    3977</span>              : // EVP_PKEY2PKCS8 encodes |pkey| as a PKCS#8 PrivateKeyInfo (RFC 5208),</span>
<span id="L3978"><span class="lineNum">    3978</span>              : // represented as a newly-allocated |PKCS8_PRIV_KEY_INFO|, or NULL on error. The</span>
<span id="L3979"><span class="lineNum">    3979</span>              : // caller must release the result with |PKCS8_PRIV_KEY_INFO_free| when done.</span>
<span id="L3980"><span class="lineNum">    3980</span>              : //</span>
<span id="L3981"><span class="lineNum">    3981</span>              : // Use |EVP_marshal_private_key| instead.</span>
<span id="L3982"><span class="lineNum">    3982</span>              : OPENSSL_EXPORT PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(const EVP_PKEY *pkey);</span>
<span id="L3983"><span class="lineNum">    3983</span>              : </span>
<span id="L3984"><span class="lineNum">    3984</span>              : </span>
<span id="L3985"><span class="lineNum">    3985</span>              : // Algorithm and octet string pairs.</span>
<span id="L3986"><span class="lineNum">    3986</span>              : //</span>
<span id="L3987"><span class="lineNum">    3987</span>              : // The |X509_SIG| type represents an ASN.1 SEQUENCE type of an</span>
<span id="L3988"><span class="lineNum">    3988</span>              : // AlgorithmIdentifier and an OCTET STRING. Although named |X509_SIG|, there is</span>
<span id="L3989"><span class="lineNum">    3989</span>              : // no type in X.509 which matches this format. The two common types which do are</span>
<span id="L3990"><span class="lineNum">    3990</span>              : // DigestInfo (RFC 2315 and RFC 8017), and EncryptedPrivateKeyInfo (RFC 5208).</span>
<span id="L3991"><span class="lineNum">    3991</span>              : </span>
<span id="L3992"><span class="lineNum">    3992</span>              : // X509_SIG_new returns a newly-allocated, empty |X509_SIG| object, or NULL on</span>
<span id="L3993"><span class="lineNum">    3993</span>              : // error.</span>
<span id="L3994"><span class="lineNum">    3994</span>              : OPENSSL_EXPORT X509_SIG *X509_SIG_new(void);</span>
<span id="L3995"><span class="lineNum">    3995</span>              : </span>
<span id="L3996"><span class="lineNum">    3996</span>              : // X509_SIG_free releases memory associated with |key|.</span>
<span id="L3997"><span class="lineNum">    3997</span>              : OPENSSL_EXPORT void X509_SIG_free(X509_SIG *key);</span>
<span id="L3998"><span class="lineNum">    3998</span>              : </span>
<span id="L3999"><span class="lineNum">    3999</span>              : // d2i_X509_SIG parses up to |len| bytes from |*inp| as a DER-encoded algorithm</span>
<span id="L4000"><span class="lineNum">    4000</span>              : // and octet string pair, as described in |d2i_SAMPLE|.</span>
<span id="L4001"><span class="lineNum">    4001</span>              : OPENSSL_EXPORT X509_SIG *d2i_X509_SIG(X509_SIG **out, const uint8_t **inp,</span>
<span id="L4002"><span class="lineNum">    4002</span>              :                                       long len);</span>
<span id="L4003"><span class="lineNum">    4003</span>              : </span>
<span id="L4004"><span class="lineNum">    4004</span>              : // i2d_X509_SIG marshals |sig| as a DER-encoded algorithm</span>
<span id="L4005"><span class="lineNum">    4005</span>              : // and octet string pair, as described in |i2d_SAMPLE|.</span>
<span id="L4006"><span class="lineNum">    4006</span>              : OPENSSL_EXPORT int i2d_X509_SIG(const X509_SIG *sig, uint8_t **outp);</span>
<span id="L4007"><span class="lineNum">    4007</span>              : </span>
<span id="L4008"><span class="lineNum">    4008</span>              : // X509_SIG_get0 sets |*out_alg| and |*out_digest| to non-owning pointers to</span>
<span id="L4009"><span class="lineNum">    4009</span>              : // |sig|'s algorithm and digest fields, respectively. Either |out_alg| and</span>
<span id="L4010"><span class="lineNum">    4010</span>              : // |out_digest| may be NULL to skip those fields.</span>
<span id="L4011"><span class="lineNum">    4011</span>              : OPENSSL_EXPORT void X509_SIG_get0(const X509_SIG *sig,</span>
<span id="L4012"><span class="lineNum">    4012</span>              :                                   const X509_ALGOR **out_alg,</span>
<span id="L4013"><span class="lineNum">    4013</span>              :                                   const ASN1_OCTET_STRING **out_digest);</span>
<span id="L4014"><span class="lineNum">    4014</span>              : </span>
<span id="L4015"><span class="lineNum">    4015</span>              : // X509_SIG_getm behaves like |X509_SIG_get0| but returns mutable pointers.</span>
<span id="L4016"><span class="lineNum">    4016</span>              : OPENSSL_EXPORT void X509_SIG_getm(X509_SIG *sig, X509_ALGOR **out_alg,</span>
<span id="L4017"><span class="lineNum">    4017</span>              :                                   ASN1_OCTET_STRING **out_digest);</span>
<span id="L4018"><span class="lineNum">    4018</span>              : </span>
<span id="L4019"><span class="lineNum">    4019</span>              : </span>
<span id="L4020"><span class="lineNum">    4020</span>              : // Printing functions.</span>
<span id="L4021"><span class="lineNum">    4021</span>              : //</span>
<span id="L4022"><span class="lineNum">    4022</span>              : // The following functions output human-readable representations of</span>
<span id="L4023"><span class="lineNum">    4023</span>              : // X.509-related structures. They should only be used for debugging or logging</span>
<span id="L4024"><span class="lineNum">    4024</span>              : // and not parsed programmatically. In many cases, the outputs are ambiguous, so</span>
<span id="L4025"><span class="lineNum">    4025</span>              : // attempting to parse them can lead to string injection vulnerabilities.</span>
<span id="L4026"><span class="lineNum">    4026</span>              : </span>
<span id="L4027"><span class="lineNum">    4027</span>              : // The following flags control |X509_print_ex| and |X509_REQ_print_ex|. These</span>
<span id="L4028"><span class="lineNum">    4028</span>              : // flags co-exist with |X509V3_EXT_*|, so avoid collisions when adding new ones.</span>
<span id="L4029"><span class="lineNum">    4029</span>              : </span>
<span id="L4030"><span class="lineNum">    4030</span>              : // X509_FLAG_COMPAT disables all flags. It additionally causes names to be</span>
<span id="L4031"><span class="lineNum">    4031</span>              : // printed with a 16-byte indent.</span>
<span id="L4032"><span class="lineNum">    4032</span>              : #define X509_FLAG_COMPAT 0</span>
<span id="L4033"><span class="lineNum">    4033</span>              : </span>
<span id="L4034"><span class="lineNum">    4034</span>              : // X509_FLAG_NO_HEADER skips a header identifying the type of object printed.</span>
<span id="L4035"><span class="lineNum">    4035</span>              : #define X509_FLAG_NO_HEADER 1L</span>
<span id="L4036"><span class="lineNum">    4036</span>              : </span>
<span id="L4037"><span class="lineNum">    4037</span>              : // X509_FLAG_NO_VERSION skips printing the X.509 version number.</span>
<span id="L4038"><span class="lineNum">    4038</span>              : #define X509_FLAG_NO_VERSION (1L &lt;&lt; 1)</span>
<span id="L4039"><span class="lineNum">    4039</span>              : </span>
<span id="L4040"><span class="lineNum">    4040</span>              : // X509_FLAG_NO_SERIAL skips printing the serial number. It is ignored in</span>
<span id="L4041"><span class="lineNum">    4041</span>              : // |X509_REQ_print_fp|.</span>
<span id="L4042"><span class="lineNum">    4042</span>              : #define X509_FLAG_NO_SERIAL (1L &lt;&lt; 2)</span>
<span id="L4043"><span class="lineNum">    4043</span>              : </span>
<span id="L4044"><span class="lineNum">    4044</span>              : // X509_FLAG_NO_SIGNAME skips printing the signature algorithm in the</span>
<span id="L4045"><span class="lineNum">    4045</span>              : // TBSCertificate. It is ignored in |X509_REQ_print_fp|.</span>
<span id="L4046"><span class="lineNum">    4046</span>              : #define X509_FLAG_NO_SIGNAME (1L &lt;&lt; 3)</span>
<span id="L4047"><span class="lineNum">    4047</span>              : </span>
<span id="L4048"><span class="lineNum">    4048</span>              : // X509_FLAG_NO_ISSUER skips printing the issuer.</span>
<span id="L4049"><span class="lineNum">    4049</span>              : #define X509_FLAG_NO_ISSUER (1L &lt;&lt; 4)</span>
<span id="L4050"><span class="lineNum">    4050</span>              : </span>
<span id="L4051"><span class="lineNum">    4051</span>              : // X509_FLAG_NO_VALIDITY skips printing the notBefore and notAfter times. It is</span>
<span id="L4052"><span class="lineNum">    4052</span>              : // ignored in |X509_REQ_print_fp|.</span>
<span id="L4053"><span class="lineNum">    4053</span>              : #define X509_FLAG_NO_VALIDITY (1L &lt;&lt; 5)</span>
<span id="L4054"><span class="lineNum">    4054</span>              : </span>
<span id="L4055"><span class="lineNum">    4055</span>              : // X509_FLAG_NO_SUBJECT skips printing the subject.</span>
<span id="L4056"><span class="lineNum">    4056</span>              : #define X509_FLAG_NO_SUBJECT (1L &lt;&lt; 6)</span>
<span id="L4057"><span class="lineNum">    4057</span>              : </span>
<span id="L4058"><span class="lineNum">    4058</span>              : // X509_FLAG_NO_PUBKEY skips printing the public key.</span>
<span id="L4059"><span class="lineNum">    4059</span>              : #define X509_FLAG_NO_PUBKEY (1L &lt;&lt; 7)</span>
<span id="L4060"><span class="lineNum">    4060</span>              : </span>
<span id="L4061"><span class="lineNum">    4061</span>              : // X509_FLAG_NO_EXTENSIONS skips printing the extension list. It is ignored in</span>
<span id="L4062"><span class="lineNum">    4062</span>              : // |X509_REQ_print_fp|. CSRs instead have attributes, which is controlled by</span>
<span id="L4063"><span class="lineNum">    4063</span>              : // |X509_FLAG_NO_ATTRIBUTES|.</span>
<span id="L4064"><span class="lineNum">    4064</span>              : #define X509_FLAG_NO_EXTENSIONS (1L &lt;&lt; 8)</span>
<span id="L4065"><span class="lineNum">    4065</span>              : </span>
<span id="L4066"><span class="lineNum">    4066</span>              : // X509_FLAG_NO_SIGDUMP skips printing the signature and outer signature</span>
<span id="L4067"><span class="lineNum">    4067</span>              : // algorithm.</span>
<span id="L4068"><span class="lineNum">    4068</span>              : #define X509_FLAG_NO_SIGDUMP (1L &lt;&lt; 9)</span>
<span id="L4069"><span class="lineNum">    4069</span>              : </span>
<span id="L4070"><span class="lineNum">    4070</span>              : // X509_FLAG_NO_AUX skips printing auxiliary properties. (See |d2i_X509_AUX| and</span>
<span id="L4071"><span class="lineNum">    4071</span>              : // related functions.)</span>
<span id="L4072"><span class="lineNum">    4072</span>              : #define X509_FLAG_NO_AUX (1L &lt;&lt; 10)</span>
<span id="L4073"><span class="lineNum">    4073</span>              : </span>
<span id="L4074"><span class="lineNum">    4074</span>              : // X509_FLAG_NO_ATTRIBUTES skips printing CSR attributes. It does nothing for</span>
<span id="L4075"><span class="lineNum">    4075</span>              : // certificates and CRLs.</span>
<span id="L4076"><span class="lineNum">    4076</span>              : #define X509_FLAG_NO_ATTRIBUTES (1L &lt;&lt; 11)</span>
<span id="L4077"><span class="lineNum">    4077</span>              : </span>
<span id="L4078"><span class="lineNum">    4078</span>              : // X509_FLAG_NO_IDS skips printing the issuerUniqueID and subjectUniqueID in a</span>
<span id="L4079"><span class="lineNum">    4079</span>              : // certificate. It is ignored in |X509_REQ_print_fp|.</span>
<span id="L4080"><span class="lineNum">    4080</span>              : #define X509_FLAG_NO_IDS (1L &lt;&lt; 12)</span>
<span id="L4081"><span class="lineNum">    4081</span>              : </span>
<span id="L4082"><span class="lineNum">    4082</span>              : // The following flags control |X509_print_ex|, |X509_REQ_print_ex|,</span>
<span id="L4083"><span class="lineNum">    4083</span>              : // |X509V3_EXT_print|, and |X509V3_extensions_print|. These flags coexist with</span>
<span id="L4084"><span class="lineNum">    4084</span>              : // |X509_FLAG_*|, so avoid collisions when adding new ones.</span>
<span id="L4085"><span class="lineNum">    4085</span>              : </span>
<span id="L4086"><span class="lineNum">    4086</span>              : // X509V3_EXT_UNKNOWN_MASK is a mask that determines how unknown extensions are</span>
<span id="L4087"><span class="lineNum">    4087</span>              : // processed.</span>
<span id="L4088"><span class="lineNum">    4088</span>              : #define X509V3_EXT_UNKNOWN_MASK (0xfL &lt;&lt; 16)</span>
<span id="L4089"><span class="lineNum">    4089</span>              : </span>
<span id="L4090"><span class="lineNum">    4090</span>              : // X509V3_EXT_DEFAULT causes unknown extensions or syntax errors to return</span>
<span id="L4091"><span class="lineNum">    4091</span>              : // failure.</span>
<span id="L4092"><span class="lineNum">    4092</span>              : #define X509V3_EXT_DEFAULT 0</span>
<span id="L4093"><span class="lineNum">    4093</span>              : </span>
<span id="L4094"><span class="lineNum">    4094</span>              : // X509V3_EXT_ERROR_UNKNOWN causes unknown extensions or syntax errors to print</span>
<span id="L4095"><span class="lineNum">    4095</span>              : // as &quot;&lt;Not Supported&gt;&quot; or &quot;&lt;Parse Error&gt;&quot;, respectively.</span>
<span id="L4096"><span class="lineNum">    4096</span>              : #define X509V3_EXT_ERROR_UNKNOWN (1L &lt;&lt; 16)</span>
<span id="L4097"><span class="lineNum">    4097</span>              : </span>
<span id="L4098"><span class="lineNum">    4098</span>              : // X509V3_EXT_PARSE_UNKNOWN is deprecated and behaves like</span>
<span id="L4099"><span class="lineNum">    4099</span>              : // |X509V3_EXT_DUMP_UNKNOWN|.</span>
<span id="L4100"><span class="lineNum">    4100</span>              : #define X509V3_EXT_PARSE_UNKNOWN (2L &lt;&lt; 16)</span>
<span id="L4101"><span class="lineNum">    4101</span>              : </span>
<span id="L4102"><span class="lineNum">    4102</span>              : // X509V3_EXT_DUMP_UNKNOWN causes unknown extensions to be displayed as a</span>
<span id="L4103"><span class="lineNum">    4103</span>              : // hexdump.</span>
<span id="L4104"><span class="lineNum">    4104</span>              : #define X509V3_EXT_DUMP_UNKNOWN (3L &lt;&lt; 16)</span>
<span id="L4105"><span class="lineNum">    4105</span>              : </span>
<span id="L4106"><span class="lineNum">    4106</span>              : // X509_print_ex writes a human-readable representation of |x| to |bp|. It</span>
<span id="L4107"><span class="lineNum">    4107</span>              : // returns one on success and zero on error. |nmflags| is the flags parameter</span>
<span id="L4108"><span class="lineNum">    4108</span>              : // for |X509_NAME_print_ex| when printing the subject and issuer. |cflag| should</span>
<span id="L4109"><span class="lineNum">    4109</span>              : // be some combination of the |X509_FLAG_*| and |X509V3_EXT_*| constants.</span>
<span id="L4110"><span class="lineNum">    4110</span>              : OPENSSL_EXPORT int X509_print_ex(BIO *bp, X509 *x, unsigned long nmflag,</span>
<span id="L4111"><span class="lineNum">    4111</span>              :                                  unsigned long cflag);</span>
<span id="L4112"><span class="lineNum">    4112</span>              : </span>
<span id="L4113"><span class="lineNum">    4113</span>              : // X509_print_ex_fp behaves like |X509_print_ex| but writes to |fp|.</span>
<span id="L4114"><span class="lineNum">    4114</span>              : OPENSSL_EXPORT int X509_print_ex_fp(FILE *fp, X509 *x, unsigned long nmflag,</span>
<span id="L4115"><span class="lineNum">    4115</span>              :                                     unsigned long cflag);</span>
<span id="L4116"><span class="lineNum">    4116</span>              : </span>
<span id="L4117"><span class="lineNum">    4117</span>              : // X509_print calls |X509_print_ex| with |XN_FLAG_COMPAT| and |X509_FLAG_COMPAT|</span>
<span id="L4118"><span class="lineNum">    4118</span>              : // flags.</span>
<span id="L4119"><span class="lineNum">    4119</span>              : OPENSSL_EXPORT int X509_print(BIO *bp, X509 *x);</span>
<span id="L4120"><span class="lineNum">    4120</span>              : </span>
<span id="L4121"><span class="lineNum">    4121</span>              : // X509_print_fp behaves like |X509_print| but writes to |fp|.</span>
<span id="L4122"><span class="lineNum">    4122</span>              : OPENSSL_EXPORT int X509_print_fp(FILE *fp, X509 *x);</span>
<span id="L4123"><span class="lineNum">    4123</span>              : </span>
<span id="L4124"><span class="lineNum">    4124</span>              : // X509_CRL_print writes a human-readable representation of |x| to |bp|. It</span>
<span id="L4125"><span class="lineNum">    4125</span>              : // returns one on success and zero on error.</span>
<span id="L4126"><span class="lineNum">    4126</span>              : OPENSSL_EXPORT int X509_CRL_print(BIO *bp, X509_CRL *x);</span>
<span id="L4127"><span class="lineNum">    4127</span>              : </span>
<span id="L4128"><span class="lineNum">    4128</span>              : // X509_CRL_print_fp behaves like |X509_CRL_print| but writes to |fp|.</span>
<span id="L4129"><span class="lineNum">    4129</span>              : OPENSSL_EXPORT int X509_CRL_print_fp(FILE *fp, X509_CRL *x);</span>
<span id="L4130"><span class="lineNum">    4130</span>              : </span>
<span id="L4131"><span class="lineNum">    4131</span>              : // X509_REQ_print_ex writes a human-readable representation of |x| to |bp|. It</span>
<span id="L4132"><span class="lineNum">    4132</span>              : // returns one on success and zero on error. |nmflags| is the flags parameter</span>
<span id="L4133"><span class="lineNum">    4133</span>              : // for |X509_NAME_print_ex|, when printing the subject. |cflag| should be some</span>
<span id="L4134"><span class="lineNum">    4134</span>              : // combination of the |X509_FLAG_*| and |X509V3_EXT_*| constants.</span>
<span id="L4135"><span class="lineNum">    4135</span>              : OPENSSL_EXPORT int X509_REQ_print_ex(BIO *bp, X509_REQ *x, unsigned long nmflag,</span>
<span id="L4136"><span class="lineNum">    4136</span>              :                                      unsigned long cflag);</span>
<span id="L4137"><span class="lineNum">    4137</span>              : </span>
<span id="L4138"><span class="lineNum">    4138</span>              : // X509_REQ_print calls |X509_REQ_print_ex| with |XN_FLAG_COMPAT| and</span>
<span id="L4139"><span class="lineNum">    4139</span>              : // |X509_FLAG_COMPAT| flags.</span>
<span id="L4140"><span class="lineNum">    4140</span>              : OPENSSL_EXPORT int X509_REQ_print(BIO *bp, X509_REQ *req);</span>
<span id="L4141"><span class="lineNum">    4141</span>              : </span>
<span id="L4142"><span class="lineNum">    4142</span>              : // X509_REQ_print_fp behaves like |X509_REQ_print| but writes to |fp|.</span>
<span id="L4143"><span class="lineNum">    4143</span>              : OPENSSL_EXPORT int X509_REQ_print_fp(FILE *fp, X509_REQ *req);</span>
<span id="L4144"><span class="lineNum">    4144</span>              : </span>
<span id="L4145"><span class="lineNum">    4145</span>              : // The following flags are control |X509_NAME_print_ex|. They must not collide</span>
<span id="L4146"><span class="lineNum">    4146</span>              : // with |ASN1_STRFLGS_*|.</span>
<span id="L4147"><span class="lineNum">    4147</span>              : //</span>
<span id="L4148"><span class="lineNum">    4148</span>              : // TODO(davidben): This is far, far too many options and most of them are</span>
<span id="L4149"><span class="lineNum">    4149</span>              : // useless. Trim this down.</span>
<span id="L4150"><span class="lineNum">    4150</span>              : </span>
<span id="L4151"><span class="lineNum">    4151</span>              : // XN_FLAG_COMPAT prints with |X509_NAME_print|'s format and return value</span>
<span id="L4152"><span class="lineNum">    4152</span>              : // convention.</span>
<span id="L4153"><span class="lineNum">    4153</span>              : #define XN_FLAG_COMPAT 0ul</span>
<span id="L4154"><span class="lineNum">    4154</span>              : </span>
<span id="L4155"><span class="lineNum">    4155</span>              : // XN_FLAG_SEP_MASK determines the separators to use between attributes.</span>
<span id="L4156"><span class="lineNum">    4156</span>              : #define XN_FLAG_SEP_MASK (0xful &lt;&lt; 16)</span>
<span id="L4157"><span class="lineNum">    4157</span>              : </span>
<span id="L4158"><span class="lineNum">    4158</span>              : // XN_FLAG_SEP_COMMA_PLUS separates RDNs with &quot;,&quot; and attributes within an RDN</span>
<span id="L4159"><span class="lineNum">    4159</span>              : // with &quot;+&quot;, as in RFC 2253.</span>
<span id="L4160"><span class="lineNum">    4160</span>              : #define XN_FLAG_SEP_COMMA_PLUS (1ul &lt;&lt; 16)</span>
<span id="L4161"><span class="lineNum">    4161</span>              : </span>
<span id="L4162"><span class="lineNum">    4162</span>              : // XN_FLAG_SEP_CPLUS_SPC behaves like |XN_FLAG_SEP_COMMA_PLUS| but adds spaces</span>
<span id="L4163"><span class="lineNum">    4163</span>              : // between the separators.</span>
<span id="L4164"><span class="lineNum">    4164</span>              : #define XN_FLAG_SEP_CPLUS_SPC (2ul &lt;&lt; 16)</span>
<span id="L4165"><span class="lineNum">    4165</span>              : </span>
<span id="L4166"><span class="lineNum">    4166</span>              : // XN_FLAG_SEP_SPLUS_SPC separates RDNs with &quot;; &quot; and attributes within an RDN</span>
<span id="L4167"><span class="lineNum">    4167</span>              : // with &quot; + &quot;.</span>
<span id="L4168"><span class="lineNum">    4168</span>              : #define XN_FLAG_SEP_SPLUS_SPC (3ul &lt;&lt; 16)</span>
<span id="L4169"><span class="lineNum">    4169</span>              : </span>
<span id="L4170"><span class="lineNum">    4170</span>              : // XN_FLAG_SEP_MULTILINE prints each attribute on one line.</span>
<span id="L4171"><span class="lineNum">    4171</span>              : #define XN_FLAG_SEP_MULTILINE (4ul &lt;&lt; 16)</span>
<span id="L4172"><span class="lineNum">    4172</span>              : </span>
<span id="L4173"><span class="lineNum">    4173</span>              : // XN_FLAG_DN_REV prints RDNs in reverse, from least significant to most</span>
<span id="L4174"><span class="lineNum">    4174</span>              : // significant, as RFC 2253.</span>
<span id="L4175"><span class="lineNum">    4175</span>              : #define XN_FLAG_DN_REV (1ul &lt;&lt; 20)</span>
<span id="L4176"><span class="lineNum">    4176</span>              : </span>
<span id="L4177"><span class="lineNum">    4177</span>              : // XN_FLAG_FN_MASK determines how attribute types are displayed.</span>
<span id="L4178"><span class="lineNum">    4178</span>              : #define XN_FLAG_FN_MASK (0x3ul &lt;&lt; 21)</span>
<span id="L4179"><span class="lineNum">    4179</span>              : </span>
<span id="L4180"><span class="lineNum">    4180</span>              : // XN_FLAG_FN_SN uses the attribute type's short name, when available.</span>
<span id="L4181"><span class="lineNum">    4181</span>              : #define XN_FLAG_FN_SN 0ul</span>
<span id="L4182"><span class="lineNum">    4182</span>              : </span>
<span id="L4183"><span class="lineNum">    4183</span>              : // XN_FLAG_SPC_EQ wraps the &quot;=&quot; operator with spaces when printing attributes.</span>
<span id="L4184"><span class="lineNum">    4184</span>              : #define XN_FLAG_SPC_EQ (1ul &lt;&lt; 23)</span>
<span id="L4185"><span class="lineNum">    4185</span>              : </span>
<span id="L4186"><span class="lineNum">    4186</span>              : // XN_FLAG_DUMP_UNKNOWN_FIELDS causes unknown attribute types to be printed in</span>
<span id="L4187"><span class="lineNum">    4187</span>              : // hex, as in RFC 2253.</span>
<span id="L4188"><span class="lineNum">    4188</span>              : #define XN_FLAG_DUMP_UNKNOWN_FIELDS (1ul &lt;&lt; 24)</span>
<span id="L4189"><span class="lineNum">    4189</span>              : </span>
<span id="L4190"><span class="lineNum">    4190</span>              : // XN_FLAG_RFC2253 prints like RFC 2253.</span>
<span id="L4191"><span class="lineNum">    4191</span>              : #define XN_FLAG_RFC2253                                             \</span>
<span id="L4192"><span class="lineNum">    4192</span>              :   (ASN1_STRFLGS_RFC2253 | XN_FLAG_SEP_COMMA_PLUS | XN_FLAG_DN_REV | \</span>
<span id="L4193"><span class="lineNum">    4193</span>              :    XN_FLAG_FN_SN | XN_FLAG_DUMP_UNKNOWN_FIELDS)</span>
<span id="L4194"><span class="lineNum">    4194</span>              : </span>
<span id="L4195"><span class="lineNum">    4195</span>              : // XN_FLAG_ONELINE prints a one-line representation of the name.</span>
<span id="L4196"><span class="lineNum">    4196</span>              : #define XN_FLAG_ONELINE                                                    \</span>
<span id="L4197"><span class="lineNum">    4197</span>              :   (ASN1_STRFLGS_RFC2253 | ASN1_STRFLGS_ESC_QUOTE | XN_FLAG_SEP_CPLUS_SPC | \</span>
<span id="L4198"><span class="lineNum">    4198</span>              :    XN_FLAG_SPC_EQ | XN_FLAG_FN_SN)</span>
<span id="L4199"><span class="lineNum">    4199</span>              : </span>
<span id="L4200"><span class="lineNum">    4200</span>              : // X509_NAME_print_ex writes a human-readable representation of |nm| to |out|.</span>
<span id="L4201"><span class="lineNum">    4201</span>              : // Each line of output is indented by |indent| spaces. It returns the number of</span>
<span id="L4202"><span class="lineNum">    4202</span>              : // bytes written on success, and -1 on error. If |out| is NULL, it returns the</span>
<span id="L4203"><span class="lineNum">    4203</span>              : // number of bytes it would have written but does not write anything. |flags|</span>
<span id="L4204"><span class="lineNum">    4204</span>              : // should be some combination of |XN_FLAG_*| and |ASN1_STRFLGS_*| values and</span>
<span id="L4205"><span class="lineNum">    4205</span>              : // determines the output. If unsure, use |XN_FLAG_RFC2253|.</span>
<span id="L4206"><span class="lineNum">    4206</span>              : //</span>
<span id="L4207"><span class="lineNum">    4207</span>              : // If |flags| is |XN_FLAG_COMPAT|, or zero, this function calls</span>
<span id="L4208"><span class="lineNum">    4208</span>              : // |X509_NAME_print| instead. In that case, it returns one on success, rather</span>
<span id="L4209"><span class="lineNum">    4209</span>              : // than the output length.</span>
<span id="L4210"><span class="lineNum">    4210</span>              : OPENSSL_EXPORT int X509_NAME_print_ex(BIO *out, const X509_NAME *nm, int indent,</span>
<span id="L4211"><span class="lineNum">    4211</span>              :                                       unsigned long flags);</span>
<span id="L4212"><span class="lineNum">    4212</span>              : </span>
<span id="L4213"><span class="lineNum">    4213</span>              : // X509_NAME_print prints a human-readable representation of |name| to |bp|. It</span>
<span id="L4214"><span class="lineNum">    4214</span>              : // returns one on success and zero on error. |obase| is ignored.</span>
<span id="L4215"><span class="lineNum">    4215</span>              : //</span>
<span id="L4216"><span class="lineNum">    4216</span>              : // This function outputs a legacy format that does not correctly handle string</span>
<span id="L4217"><span class="lineNum">    4217</span>              : // encodings and other cases. Prefer |X509_NAME_print_ex| if printing a name for</span>
<span id="L4218"><span class="lineNum">    4218</span>              : // debugging purposes.</span>
<span id="L4219"><span class="lineNum">    4219</span>              : OPENSSL_EXPORT int X509_NAME_print(BIO *bp, const X509_NAME *name, int obase);</span>
<span id="L4220"><span class="lineNum">    4220</span>              : </span>
<span id="L4221"><span class="lineNum">    4221</span>              : // X509_NAME_oneline writes a human-readable representation to |name| to a</span>
<span id="L4222"><span class="lineNum">    4222</span>              : // buffer as a NUL-terminated C string.</span>
<span id="L4223"><span class="lineNum">    4223</span>              : //</span>
<span id="L4224"><span class="lineNum">    4224</span>              : // If |buf| is NULL, returns a newly-allocated buffer containing the result on</span>
<span id="L4225"><span class="lineNum">    4225</span>              : // success, or NULL on error. The buffer must be released with |OPENSSL_free|</span>
<span id="L4226"><span class="lineNum">    4226</span>              : // when done.</span>
<span id="L4227"><span class="lineNum">    4227</span>              : //</span>
<span id="L4228"><span class="lineNum">    4228</span>              : // If |buf| is non-NULL, at most |size| bytes of output are written to |buf|</span>
<span id="L4229"><span class="lineNum">    4229</span>              : // instead. |size| includes the trailing NUL. The function then returns |buf| on</span>
<span id="L4230"><span class="lineNum">    4230</span>              : // success or NULL on error. If the output does not fit in |size| bytes, the</span>
<span id="L4231"><span class="lineNum">    4231</span>              : // output is silently truncated at an attribute boundary.</span>
<span id="L4232"><span class="lineNum">    4232</span>              : //</span>
<span id="L4233"><span class="lineNum">    4233</span>              : // This function outputs a legacy format that does not correctly handle string</span>
<span id="L4234"><span class="lineNum">    4234</span>              : // encodings and other cases. Prefer |X509_NAME_print_ex| if printing a name for</span>
<span id="L4235"><span class="lineNum">    4235</span>              : // debugging purposes.</span>
<span id="L4236"><span class="lineNum">    4236</span>              : OPENSSL_EXPORT char *X509_NAME_oneline(const X509_NAME *name, char *buf, int size);</span>
<span id="L4237"><span class="lineNum">    4237</span>              : </span>
<span id="L4238"><span class="lineNum">    4238</span>              : // X509_NAME_print_ex_fp behaves like |X509_NAME_print_ex| but writes to |fp|.</span>
<span id="L4239"><span class="lineNum">    4239</span>              : OPENSSL_EXPORT int X509_NAME_print_ex_fp(FILE *fp, const X509_NAME *nm,</span>
<span id="L4240"><span class="lineNum">    4240</span>              :                                          int indent, unsigned long flags);</span>
<span id="L4241"><span class="lineNum">    4241</span>              : </span>
<span id="L4242"><span class="lineNum">    4242</span>              : // X509_signature_dump writes a human-readable representation of |sig| to |bio|,</span>
<span id="L4243"><span class="lineNum">    4243</span>              : // indented with |indent| spaces. It returns one on success and zero on error.</span>
<span id="L4244"><span class="lineNum">    4244</span>              : OPENSSL_EXPORT int X509_signature_dump(BIO *bio, const ASN1_STRING *sig,</span>
<span id="L4245"><span class="lineNum">    4245</span>              :                                        int indent);</span>
<span id="L4246"><span class="lineNum">    4246</span>              : </span>
<span id="L4247"><span class="lineNum">    4247</span>              : // X509_signature_print writes a human-readable representation of |alg| and</span>
<span id="L4248"><span class="lineNum">    4248</span>              : // |sig| to |bio|. It returns one on success and zero on error.</span>
<span id="L4249"><span class="lineNum">    4249</span>              : OPENSSL_EXPORT int X509_signature_print(BIO *bio, const X509_ALGOR *alg,</span>
<span id="L4250"><span class="lineNum">    4250</span>              :                                         const ASN1_STRING *sig);</span>
<span id="L4251"><span class="lineNum">    4251</span>              : </span>
<span id="L4252"><span class="lineNum">    4252</span>              : // X509V3_EXT_print prints a human-readable representation of |ext| to out. It</span>
<span id="L4253"><span class="lineNum">    4253</span>              : // returns one on success and zero on error. The output is indented by |indent|</span>
<span id="L4254"><span class="lineNum">    4254</span>              : // spaces. |flag| is one of the |X509V3_EXT_*| constants and controls printing</span>
<span id="L4255"><span class="lineNum">    4255</span>              : // of unknown extensions and syntax errors.</span>
<span id="L4256"><span class="lineNum">    4256</span>              : //</span>
<span id="L4257"><span class="lineNum">    4257</span>              : // WARNING: Although some applications programmatically parse the output of this</span>
<span id="L4258"><span class="lineNum">    4258</span>              : // function to process X.509 extensions, this is not safe. In many cases, the</span>
<span id="L4259"><span class="lineNum">    4259</span>              : // outputs are ambiguous to attempting to parse them can lead to string</span>
<span id="L4260"><span class="lineNum">    4260</span>              : // injection vulnerabilities. These functions should only be used for debugging</span>
<span id="L4261"><span class="lineNum">    4261</span>              : // or logging.</span>
<span id="L4262"><span class="lineNum">    4262</span>              : OPENSSL_EXPORT int X509V3_EXT_print(BIO *out, const X509_EXTENSION *ext,</span>
<span id="L4263"><span class="lineNum">    4263</span>              :                                     unsigned long flag, int indent);</span>
<span id="L4264"><span class="lineNum">    4264</span>              : </span>
<span id="L4265"><span class="lineNum">    4265</span>              : // X509V3_EXT_print_fp behaves like |X509V3_EXT_print| but writes to a |FILE|</span>
<span id="L4266"><span class="lineNum">    4266</span>              : // instead of a |BIO|.</span>
<span id="L4267"><span class="lineNum">    4267</span>              : OPENSSL_EXPORT int X509V3_EXT_print_fp(FILE *out, const X509_EXTENSION *ext,</span>
<span id="L4268"><span class="lineNum">    4268</span>              :                                        int flag, int indent);</span>
<span id="L4269"><span class="lineNum">    4269</span>              : </span>
<span id="L4270"><span class="lineNum">    4270</span>              : // X509V3_extensions_print prints |title|, followed by a human-readable</span>
<span id="L4271"><span class="lineNum">    4271</span>              : // representation of |exts| to |out|. It returns one on success and zero on</span>
<span id="L4272"><span class="lineNum">    4272</span>              : // error. The output is indented by |indent| spaces. |flag| is one of the</span>
<span id="L4273"><span class="lineNum">    4273</span>              : // |X509V3_EXT_*| constants and controls printing of unknown extensions and</span>
<span id="L4274"><span class="lineNum">    4274</span>              : // syntax errors.</span>
<span id="L4275"><span class="lineNum">    4275</span>              : OPENSSL_EXPORT int X509V3_extensions_print(BIO *out, const char *title,</span>
<span id="L4276"><span class="lineNum">    4276</span>              :                                            const STACK_OF(X509_EXTENSION) *exts,</span>
<span id="L4277"><span class="lineNum">    4277</span>              :                                            unsigned long flag, int indent);</span>
<span id="L4278"><span class="lineNum">    4278</span>              : </span>
<span id="L4279"><span class="lineNum">    4279</span>              : // GENERAL_NAME_print prints a human-readable representation of |gen| to |out|.</span>
<span id="L4280"><span class="lineNum">    4280</span>              : // It returns one on success and zero on error.</span>
<span id="L4281"><span class="lineNum">    4281</span>              : //</span>
<span id="L4282"><span class="lineNum">    4282</span>              : // TODO(davidben): Actually, it just returns one and doesn't check for I/O or</span>
<span id="L4283"><span class="lineNum">    4283</span>              : // allocation errors. But it should return zero on error.</span>
<span id="L4284"><span class="lineNum">    4284</span>              : OPENSSL_EXPORT int GENERAL_NAME_print(BIO *out, const GENERAL_NAME *gen);</span>
<span id="L4285"><span class="lineNum">    4285</span>              : </span>
<span id="L4286"><span class="lineNum">    4286</span>              : </span>
<span id="L4287"><span class="lineNum">    4287</span>              : // Convenience functions.</span>
<span id="L4288"><span class="lineNum">    4288</span>              : </span>
<span id="L4289"><span class="lineNum">    4289</span>              : // X509_pubkey_digest hashes the contents of the BIT STRING in |x509|'s</span>
<span id="L4290"><span class="lineNum">    4290</span>              : // subjectPublicKeyInfo field with |md| and writes the result to |out|.</span>
<span id="L4291"><span class="lineNum">    4291</span>              : // |EVP_MD_CTX_size| bytes are written, which is at most |EVP_MAX_MD_SIZE|. If</span>
<span id="L4292"><span class="lineNum">    4292</span>              : // |out_len| is not NULL, |*out_len| is set to the number of bytes written. This</span>
<span id="L4293"><span class="lineNum">    4293</span>              : // function returns one on success and zero on error.</span>
<span id="L4294"><span class="lineNum">    4294</span>              : //</span>
<span id="L4295"><span class="lineNum">    4295</span>              : // This hash omits the BIT STRING tag, length, and number of unused bits. It</span>
<span id="L4296"><span class="lineNum">    4296</span>              : // also omits the AlgorithmIdentifier which describes the key type. It</span>
<span id="L4297"><span class="lineNum">    4297</span>              : // corresponds to the OCSP KeyHash definition and is not suitable for other</span>
<span id="L4298"><span class="lineNum">    4298</span>              : // purposes.</span>
<span id="L4299"><span class="lineNum">    4299</span>              : OPENSSL_EXPORT int X509_pubkey_digest(const X509 *x509, const EVP_MD *md,</span>
<span id="L4300"><span class="lineNum">    4300</span>              :                                       uint8_t *out, unsigned *out_len);</span>
<span id="L4301"><span class="lineNum">    4301</span>              : </span>
<span id="L4302"><span class="lineNum">    4302</span>              : // X509_digest hashes |x509|'s DER encoding with |md| and writes the result to</span>
<span id="L4303"><span class="lineNum">    4303</span>              : // |out|. |EVP_MD_CTX_size| bytes are written, which is at most</span>
<span id="L4304"><span class="lineNum">    4304</span>              : // |EVP_MAX_MD_SIZE|. If |out_len| is not NULL, |*out_len| is set to the number</span>
<span id="L4305"><span class="lineNum">    4305</span>              : // of bytes written. This function returns one on success and zero on error.</span>
<span id="L4306"><span class="lineNum">    4306</span>              : // Note this digest covers the entire certificate, not just the signed portion.</span>
<span id="L4307"><span class="lineNum">    4307</span>              : OPENSSL_EXPORT int X509_digest(const X509 *x509, const EVP_MD *md, uint8_t *out,</span>
<span id="L4308"><span class="lineNum">    4308</span>              :                                unsigned *out_len);</span>
<span id="L4309"><span class="lineNum">    4309</span>              : </span>
<span id="L4310"><span class="lineNum">    4310</span>              : // X509_CRL_digest hashes |crl|'s DER encoding with |md| and writes the result</span>
<span id="L4311"><span class="lineNum">    4311</span>              : // to |out|. |EVP_MD_CTX_size| bytes are written, which is at most</span>
<span id="L4312"><span class="lineNum">    4312</span>              : // |EVP_MAX_MD_SIZE|. If |out_len| is not NULL, |*out_len| is set to the number</span>
<span id="L4313"><span class="lineNum">    4313</span>              : // of bytes written. This function returns one on success and zero on error.</span>
<span id="L4314"><span class="lineNum">    4314</span>              : // Note this digest covers the entire CRL, not just the signed portion.</span>
<span id="L4315"><span class="lineNum">    4315</span>              : OPENSSL_EXPORT int X509_CRL_digest(const X509_CRL *crl, const EVP_MD *md,</span>
<span id="L4316"><span class="lineNum">    4316</span>              :                                    uint8_t *out, unsigned *out_len);</span>
<span id="L4317"><span class="lineNum">    4317</span>              : </span>
<span id="L4318"><span class="lineNum">    4318</span>              : // X509_REQ_digest hashes |req|'s DER encoding with |md| and writes the result</span>
<span id="L4319"><span class="lineNum">    4319</span>              : // to |out|. |EVP_MD_CTX_size| bytes are written, which is at most</span>
<span id="L4320"><span class="lineNum">    4320</span>              : // |EVP_MAX_MD_SIZE|. If |out_len| is not NULL, |*out_len| is set to the number</span>
<span id="L4321"><span class="lineNum">    4321</span>              : // of bytes written. This function returns one on success and zero on error.</span>
<span id="L4322"><span class="lineNum">    4322</span>              : // Note this digest covers the entire certificate request, not just the signed</span>
<span id="L4323"><span class="lineNum">    4323</span>              : // portion.</span>
<span id="L4324"><span class="lineNum">    4324</span>              : OPENSSL_EXPORT int X509_REQ_digest(const X509_REQ *req, const EVP_MD *md,</span>
<span id="L4325"><span class="lineNum">    4325</span>              :                                    uint8_t *out, unsigned *out_len);</span>
<span id="L4326"><span class="lineNum">    4326</span>              : </span>
<span id="L4327"><span class="lineNum">    4327</span>              : // X509_NAME_digest hashes |name|'s DER encoding with |md| and writes the result</span>
<span id="L4328"><span class="lineNum">    4328</span>              : // to |out|. |EVP_MD_CTX_size| bytes are written, which is at most</span>
<span id="L4329"><span class="lineNum">    4329</span>              : // |EVP_MAX_MD_SIZE|. If |out_len| is not NULL, |*out_len| is set to the number</span>
<span id="L4330"><span class="lineNum">    4330</span>              : // of bytes written. This function returns one on success and zero on error.</span>
<span id="L4331"><span class="lineNum">    4331</span>              : OPENSSL_EXPORT int X509_NAME_digest(const X509_NAME *name, const EVP_MD *md,</span>
<span id="L4332"><span class="lineNum">    4332</span>              :                                     uint8_t *out, unsigned *out_len);</span>
<span id="L4333"><span class="lineNum">    4333</span>              : </span>
<span id="L4334"><span class="lineNum">    4334</span>              : // The following functions behave like the corresponding unsuffixed |d2i_*|</span>
<span id="L4335"><span class="lineNum">    4335</span>              : // functions, but read the result from |bp| instead. Callers using these</span>
<span id="L4336"><span class="lineNum">    4336</span>              : // functions with memory |BIO|s to parse structures already in memory should use</span>
<span id="L4337"><span class="lineNum">    4337</span>              : // |d2i_*| instead.</span>
<span id="L4338"><span class="lineNum">    4338</span>              : OPENSSL_EXPORT X509 *d2i_X509_bio(BIO *bp, X509 **x509);</span>
<span id="L4339"><span class="lineNum">    4339</span>              : OPENSSL_EXPORT X509_CRL *d2i_X509_CRL_bio(BIO *bp, X509_CRL **crl);</span>
<span id="L4340"><span class="lineNum">    4340</span>              : OPENSSL_EXPORT X509_REQ *d2i_X509_REQ_bio(BIO *bp, X509_REQ **req);</span>
<span id="L4341"><span class="lineNum">    4341</span>              : OPENSSL_EXPORT RSA *d2i_RSAPrivateKey_bio(BIO *bp, RSA **rsa);</span>
<span id="L4342"><span class="lineNum">    4342</span>              : OPENSSL_EXPORT RSA *d2i_RSAPublicKey_bio(BIO *bp, RSA **rsa);</span>
<span id="L4343"><span class="lineNum">    4343</span>              : OPENSSL_EXPORT RSA *d2i_RSA_PUBKEY_bio(BIO *bp, RSA **rsa);</span>
<span id="L4344"><span class="lineNum">    4344</span>              : OPENSSL_EXPORT DSA *d2i_DSA_PUBKEY_bio(BIO *bp, DSA **dsa);</span>
<span id="L4345"><span class="lineNum">    4345</span>              : OPENSSL_EXPORT DSA *d2i_DSAPrivateKey_bio(BIO *bp, DSA **dsa);</span>
<span id="L4346"><span class="lineNum">    4346</span>              : OPENSSL_EXPORT EC_KEY *d2i_EC_PUBKEY_bio(BIO *bp, EC_KEY **eckey);</span>
<span id="L4347"><span class="lineNum">    4347</span>              : OPENSSL_EXPORT EC_KEY *d2i_ECPrivateKey_bio(BIO *bp, EC_KEY **eckey);</span>
<span id="L4348"><span class="lineNum">    4348</span>              : OPENSSL_EXPORT X509_SIG *d2i_PKCS8_bio(BIO *bp, X509_SIG **p8);</span>
<span id="L4349"><span class="lineNum">    4349</span>              : OPENSSL_EXPORT PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_bio(</span>
<span id="L4350"><span class="lineNum">    4350</span>              :     BIO *bp, PKCS8_PRIV_KEY_INFO **p8inf);</span>
<span id="L4351"><span class="lineNum">    4351</span>              : OPENSSL_EXPORT EVP_PKEY *d2i_PUBKEY_bio(BIO *bp, EVP_PKEY **a);</span>
<span id="L4352"><span class="lineNum">    4352</span>              : OPENSSL_EXPORT DH *d2i_DHparams_bio(BIO *bp, DH **dh);</span>
<span id="L4353"><span class="lineNum">    4353</span>              : </span>
<span id="L4354"><span class="lineNum">    4354</span>              : // d2i_PrivateKey_bio behaves like |d2i_AutoPrivateKey|, but reads from |bp|</span>
<span id="L4355"><span class="lineNum">    4355</span>              : // instead.</span>
<span id="L4356"><span class="lineNum">    4356</span>              : OPENSSL_EXPORT EVP_PKEY *d2i_PrivateKey_bio(BIO *bp, EVP_PKEY **a);</span>
<span id="L4357"><span class="lineNum">    4357</span>              : </span>
<span id="L4358"><span class="lineNum">    4358</span>              : // The following functions behave like the corresponding unsuffixed |i2d_*|</span>
<span id="L4359"><span class="lineNum">    4359</span>              : // functions, but write the result to |bp|. They return one on success and zero</span>
<span id="L4360"><span class="lineNum">    4360</span>              : // on error. Callers using them with memory |BIO|s to encode structures to</span>
<span id="L4361"><span class="lineNum">    4361</span>              : // memory should use |i2d_*| directly instead.</span>
<span id="L4362"><span class="lineNum">    4362</span>              : OPENSSL_EXPORT int i2d_X509_bio(BIO *bp, X509 *x509);</span>
<span id="L4363"><span class="lineNum">    4363</span>              : OPENSSL_EXPORT int i2d_X509_CRL_bio(BIO *bp, X509_CRL *crl);</span>
<span id="L4364"><span class="lineNum">    4364</span>              : OPENSSL_EXPORT int i2d_X509_REQ_bio(BIO *bp, X509_REQ *req);</span>
<span id="L4365"><span class="lineNum">    4365</span>              : OPENSSL_EXPORT int i2d_RSAPrivateKey_bio(BIO *bp, RSA *rsa);</span>
<span id="L4366"><span class="lineNum">    4366</span>              : OPENSSL_EXPORT int i2d_RSAPublicKey_bio(BIO *bp, RSA *rsa);</span>
<span id="L4367"><span class="lineNum">    4367</span>              : OPENSSL_EXPORT int i2d_RSA_PUBKEY_bio(BIO *bp, RSA *rsa);</span>
<span id="L4368"><span class="lineNum">    4368</span>              : OPENSSL_EXPORT int i2d_DSA_PUBKEY_bio(BIO *bp, DSA *dsa);</span>
<span id="L4369"><span class="lineNum">    4369</span>              : OPENSSL_EXPORT int i2d_DSAPrivateKey_bio(BIO *bp, DSA *dsa);</span>
<span id="L4370"><span class="lineNum">    4370</span>              : OPENSSL_EXPORT int i2d_EC_PUBKEY_bio(BIO *bp, EC_KEY *eckey);</span>
<span id="L4371"><span class="lineNum">    4371</span>              : OPENSSL_EXPORT int i2d_ECPrivateKey_bio(BIO *bp, EC_KEY *eckey);</span>
<span id="L4372"><span class="lineNum">    4372</span>              : OPENSSL_EXPORT int i2d_PKCS8_bio(BIO *bp, X509_SIG *p8);</span>
<span id="L4373"><span class="lineNum">    4373</span>              : OPENSSL_EXPORT int i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp,</span>
<span id="L4374"><span class="lineNum">    4374</span>              :                                                PKCS8_PRIV_KEY_INFO *p8inf);</span>
<span id="L4375"><span class="lineNum">    4375</span>              : OPENSSL_EXPORT int i2d_PrivateKey_bio(BIO *bp, EVP_PKEY *pkey);</span>
<span id="L4376"><span class="lineNum">    4376</span>              : OPENSSL_EXPORT int i2d_PUBKEY_bio(BIO *bp, EVP_PKEY *pkey);</span>
<span id="L4377"><span class="lineNum">    4377</span>              : OPENSSL_EXPORT int i2d_DHparams_bio(BIO *bp, const DH *dh);</span>
<span id="L4378"><span class="lineNum">    4378</span>              : </span>
<span id="L4379"><span class="lineNum">    4379</span>              : // i2d_PKCS8PrivateKeyInfo_bio encodes |key| as a PKCS#8 PrivateKeyInfo</span>
<span id="L4380"><span class="lineNum">    4380</span>              : // structure (see |EVP_marshal_private_key|) and writes the result to |bp|. It</span>
<span id="L4381"><span class="lineNum">    4381</span>              : // returns one on success and zero on error.</span>
<span id="L4382"><span class="lineNum">    4382</span>              : OPENSSL_EXPORT int i2d_PKCS8PrivateKeyInfo_bio(BIO *bp, EVP_PKEY *key);</span>
<span id="L4383"><span class="lineNum">    4383</span>              : </span>
<span id="L4384"><span class="lineNum">    4384</span>              : // The following functions behave like the corresponding |d2i_*_bio| functions,</span>
<span id="L4385"><span class="lineNum">    4385</span>              : // but read from |fp| instead.</span>
<span id="L4386"><span class="lineNum">    4386</span>              : OPENSSL_EXPORT X509 *d2i_X509_fp(FILE *fp, X509 **x509);</span>
<span id="L4387"><span class="lineNum">    4387</span>              : OPENSSL_EXPORT X509_CRL *d2i_X509_CRL_fp(FILE *fp, X509_CRL **crl);</span>
<span id="L4388"><span class="lineNum">    4388</span>              : OPENSSL_EXPORT X509_REQ *d2i_X509_REQ_fp(FILE *fp, X509_REQ **req);</span>
<span id="L4389"><span class="lineNum">    4389</span>              : OPENSSL_EXPORT RSA *d2i_RSAPrivateKey_fp(FILE *fp, RSA **rsa);</span>
<span id="L4390"><span class="lineNum">    4390</span>              : OPENSSL_EXPORT RSA *d2i_RSAPublicKey_fp(FILE *fp, RSA **rsa);</span>
<span id="L4391"><span class="lineNum">    4391</span>              : OPENSSL_EXPORT RSA *d2i_RSA_PUBKEY_fp(FILE *fp, RSA **rsa);</span>
<span id="L4392"><span class="lineNum">    4392</span>              : OPENSSL_EXPORT DSA *d2i_DSA_PUBKEY_fp(FILE *fp, DSA **dsa);</span>
<span id="L4393"><span class="lineNum">    4393</span>              : OPENSSL_EXPORT DSA *d2i_DSAPrivateKey_fp(FILE *fp, DSA **dsa);</span>
<span id="L4394"><span class="lineNum">    4394</span>              : OPENSSL_EXPORT EC_KEY *d2i_EC_PUBKEY_fp(FILE *fp, EC_KEY **eckey);</span>
<span id="L4395"><span class="lineNum">    4395</span>              : OPENSSL_EXPORT EC_KEY *d2i_ECPrivateKey_fp(FILE *fp, EC_KEY **eckey);</span>
<span id="L4396"><span class="lineNum">    4396</span>              : OPENSSL_EXPORT X509_SIG *d2i_PKCS8_fp(FILE *fp, X509_SIG **p8);</span>
<span id="L4397"><span class="lineNum">    4397</span>              : OPENSSL_EXPORT PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_fp(</span>
<span id="L4398"><span class="lineNum">    4398</span>              :     FILE *fp, PKCS8_PRIV_KEY_INFO **p8inf);</span>
<span id="L4399"><span class="lineNum">    4399</span>              : OPENSSL_EXPORT EVP_PKEY *d2i_PrivateKey_fp(FILE *fp, EVP_PKEY **a);</span>
<span id="L4400"><span class="lineNum">    4400</span>              : OPENSSL_EXPORT EVP_PKEY *d2i_PUBKEY_fp(FILE *fp, EVP_PKEY **a);</span>
<span id="L4401"><span class="lineNum">    4401</span>              : </span>
<span id="L4402"><span class="lineNum">    4402</span>              : // The following functions behave like the corresponding |i2d_*_bio| functions,</span>
<span id="L4403"><span class="lineNum">    4403</span>              : // but write to |fp| instead.</span>
<span id="L4404"><span class="lineNum">    4404</span>              : OPENSSL_EXPORT int i2d_X509_fp(FILE *fp, X509 *x509);</span>
<span id="L4405"><span class="lineNum">    4405</span>              : OPENSSL_EXPORT int i2d_X509_CRL_fp(FILE *fp, X509_CRL *crl);</span>
<span id="L4406"><span class="lineNum">    4406</span>              : OPENSSL_EXPORT int i2d_X509_REQ_fp(FILE *fp, X509_REQ *req);</span>
<span id="L4407"><span class="lineNum">    4407</span>              : OPENSSL_EXPORT int i2d_RSAPrivateKey_fp(FILE *fp, RSA *rsa);</span>
<span id="L4408"><span class="lineNum">    4408</span>              : OPENSSL_EXPORT int i2d_RSAPublicKey_fp(FILE *fp, RSA *rsa);</span>
<span id="L4409"><span class="lineNum">    4409</span>              : OPENSSL_EXPORT int i2d_RSA_PUBKEY_fp(FILE *fp, RSA *rsa);</span>
<span id="L4410"><span class="lineNum">    4410</span>              : OPENSSL_EXPORT int i2d_DSA_PUBKEY_fp(FILE *fp, DSA *dsa);</span>
<span id="L4411"><span class="lineNum">    4411</span>              : OPENSSL_EXPORT int i2d_DSAPrivateKey_fp(FILE *fp, DSA *dsa);</span>
<span id="L4412"><span class="lineNum">    4412</span>              : OPENSSL_EXPORT int i2d_EC_PUBKEY_fp(FILE *fp, EC_KEY *eckey);</span>
<span id="L4413"><span class="lineNum">    4413</span>              : OPENSSL_EXPORT int i2d_ECPrivateKey_fp(FILE *fp, EC_KEY *eckey);</span>
<span id="L4414"><span class="lineNum">    4414</span>              : OPENSSL_EXPORT int i2d_PKCS8_fp(FILE *fp, X509_SIG *p8);</span>
<span id="L4415"><span class="lineNum">    4415</span>              : OPENSSL_EXPORT int i2d_PKCS8_PRIV_KEY_INFO_fp(FILE *fp,</span>
<span id="L4416"><span class="lineNum">    4416</span>              :                                               PKCS8_PRIV_KEY_INFO *p8inf);</span>
<span id="L4417"><span class="lineNum">    4417</span>              : OPENSSL_EXPORT int i2d_PKCS8PrivateKeyInfo_fp(FILE *fp, EVP_PKEY *key);</span>
<span id="L4418"><span class="lineNum">    4418</span>              : OPENSSL_EXPORT int i2d_PrivateKey_fp(FILE *fp, EVP_PKEY *pkey);</span>
<span id="L4419"><span class="lineNum">    4419</span>              : OPENSSL_EXPORT int i2d_PUBKEY_fp(FILE *fp, EVP_PKEY *pkey);</span>
<span id="L4420"><span class="lineNum">    4420</span>              : </span>
<span id="L4421"><span class="lineNum">    4421</span>              : // X509_find_by_issuer_and_serial returns the first |X509| in |sk| whose issuer</span>
<span id="L4422"><span class="lineNum">    4422</span>              : // and serial are |name| and |serial|, respectively. If no match is found, it</span>
<span id="L4423"><span class="lineNum">    4423</span>              : // returns NULL.</span>
<span id="L4424"><span class="lineNum">    4424</span>              : OPENSSL_EXPORT X509 *X509_find_by_issuer_and_serial(const STACK_OF(X509) *sk,</span>
<span id="L4425"><span class="lineNum">    4425</span>              :                                                     X509_NAME *name,</span>
<span id="L4426"><span class="lineNum">    4426</span>              :                                                     const ASN1_INTEGER *serial);</span>
<span id="L4427"><span class="lineNum">    4427</span>              : </span>
<span id="L4428"><span class="lineNum">    4428</span>              : // X509_find_by_subject returns the first |X509| in |sk| whose subject is</span>
<span id="L4429"><span class="lineNum">    4429</span>              : // |name|. If no match is found, it returns NULL.</span>
<span id="L4430"><span class="lineNum">    4430</span>              : OPENSSL_EXPORT X509 *X509_find_by_subject(const STACK_OF(X509) *sk,</span>
<span id="L4431"><span class="lineNum">    4431</span>              :                                           X509_NAME *name);</span>
<span id="L4432"><span class="lineNum">    4432</span>              : </span>
<span id="L4433"><span class="lineNum">    4433</span>              : // X509_cmp_time compares |s| against |*t|. On success, it returns a negative</span>
<span id="L4434"><span class="lineNum">    4434</span>              : // number if |s| &lt;= |*t| and a positive number if |s| &gt; |*t|. On error, it</span>
<span id="L4435"><span class="lineNum">    4435</span>              : // returns zero. If |t| is NULL, it uses the current time instead of |*t|.</span>
<span id="L4436"><span class="lineNum">    4436</span>              : //</span>
<span id="L4437"><span class="lineNum">    4437</span>              : // WARNING: Unlike most comparison functions, this function returns zero on</span>
<span id="L4438"><span class="lineNum">    4438</span>              : // error, not equality.</span>
<span id="L4439"><span class="lineNum">    4439</span>              : OPENSSL_EXPORT int X509_cmp_time(const ASN1_TIME *s, const time_t *t);</span>
<span id="L4440"><span class="lineNum">    4440</span>              : </span>
<span id="L4441"><span class="lineNum">    4441</span>              : // X509_cmp_time_posix compares |s| against |t|. On success, it returns a</span>
<span id="L4442"><span class="lineNum">    4442</span>              : // negative number if |s| &lt;= |t| and a positive number if |s| &gt; |t|. On error,</span>
<span id="L4443"><span class="lineNum">    4443</span>              : // it returns zero.</span>
<span id="L4444"><span class="lineNum">    4444</span>              : //</span>
<span id="L4445"><span class="lineNum">    4445</span>              : // WARNING: Unlike most comparison functions, this function returns zero on</span>
<span id="L4446"><span class="lineNum">    4446</span>              : // error, not equality.</span>
<span id="L4447"><span class="lineNum">    4447</span>              : OPENSSL_EXPORT int X509_cmp_time_posix(const ASN1_TIME *s, int64_t t);</span>
<span id="L4448"><span class="lineNum">    4448</span>              : </span>
<span id="L4449"><span class="lineNum">    4449</span>              : // X509_cmp_current_time behaves like |X509_cmp_time| but compares |s| against</span>
<span id="L4450"><span class="lineNum">    4450</span>              : // the current time.</span>
<span id="L4451"><span class="lineNum">    4451</span>              : OPENSSL_EXPORT int X509_cmp_current_time(const ASN1_TIME *s);</span>
<span id="L4452"><span class="lineNum">    4452</span>              : </span>
<span id="L4453"><span class="lineNum">    4453</span>              : // X509_time_adj calls |X509_time_adj_ex| with |offset_day| equal to zero.</span>
<span id="L4454"><span class="lineNum">    4454</span>              : OPENSSL_EXPORT ASN1_TIME *X509_time_adj(ASN1_TIME *s, long offset_sec,</span>
<span id="L4455"><span class="lineNum">    4455</span>              :                                         const time_t *t);</span>
<span id="L4456"><span class="lineNum">    4456</span>              : </span>
<span id="L4457"><span class="lineNum">    4457</span>              : // X509_time_adj_ex behaves like |ASN1_TIME_adj|, but adds an offset to |*t|. If</span>
<span id="L4458"><span class="lineNum">    4458</span>              : // |t| is NULL, it uses the current time instead of |*t|.</span>
<span id="L4459"><span class="lineNum">    4459</span>              : OPENSSL_EXPORT ASN1_TIME *X509_time_adj_ex(ASN1_TIME *s, int offset_day,</span>
<span id="L4460"><span class="lineNum">    4460</span>              :                                            long offset_sec, const time_t *t);</span>
<span id="L4461"><span class="lineNum">    4461</span>              : </span>
<span id="L4462"><span class="lineNum">    4462</span>              : // X509_gmtime_adj behaves like |X509_time_adj_ex| but adds |offset_sec| to the</span>
<span id="L4463"><span class="lineNum">    4463</span>              : // current time.</span>
<span id="L4464"><span class="lineNum">    4464</span>              : OPENSSL_EXPORT ASN1_TIME *X509_gmtime_adj(ASN1_TIME *s, long offset_sec);</span>
<span id="L4465"><span class="lineNum">    4465</span>              : </span>
<span id="L4466"><span class="lineNum">    4466</span>              : // X509_issuer_name_cmp behaves like |X509_NAME_cmp|, but compares |a| and |b|'s</span>
<span id="L4467"><span class="lineNum">    4467</span>              : // issuer names.</span>
<span id="L4468"><span class="lineNum">    4468</span>              : OPENSSL_EXPORT int X509_issuer_name_cmp(const X509 *a, const X509 *b);</span>
<span id="L4469"><span class="lineNum">    4469</span>              : </span>
<span id="L4470"><span class="lineNum">    4470</span>              : // X509_subject_name_cmp behaves like |X509_NAME_cmp|, but compares |a| and</span>
<span id="L4471"><span class="lineNum">    4471</span>              : // |b|'s subject names.</span>
<span id="L4472"><span class="lineNum">    4472</span>              : OPENSSL_EXPORT int X509_subject_name_cmp(const X509 *a, const X509 *b);</span>
<span id="L4473"><span class="lineNum">    4473</span>              : </span>
<span id="L4474"><span class="lineNum">    4474</span>              : // X509_CRL_cmp behaves like |X509_NAME_cmp|, but compares |a| and |b|'s</span>
<span id="L4475"><span class="lineNum">    4475</span>              : // issuer names.</span>
<span id="L4476"><span class="lineNum">    4476</span>              : //</span>
<span id="L4477"><span class="lineNum">    4477</span>              : // WARNING: This function is misnamed. It does not compare other parts of the</span>
<span id="L4478"><span class="lineNum">    4478</span>              : // CRL, only the issuer fields using |X509_NAME_cmp|.</span>
<span id="L4479"><span class="lineNum">    4479</span>              : OPENSSL_EXPORT int X509_CRL_cmp(const X509_CRL *a, const X509_CRL *b);</span>
<span id="L4480"><span class="lineNum">    4480</span>              : </span>
<span id="L4481"><span class="lineNum">    4481</span>              : // X509_issuer_name_hash returns the hash of |x509|'s issuer name with</span>
<span id="L4482"><span class="lineNum">    4482</span>              : // |X509_NAME_hash|.</span>
<span id="L4483"><span class="lineNum">    4483</span>              : //</span>
<span id="L4484"><span class="lineNum">    4484</span>              : // This hash is specific to the |X509_LOOKUP_add_dir| filesystem format and is</span>
<span id="L4485"><span class="lineNum">    4485</span>              : // not suitable for general-purpose X.509 name processing. It is very short, so</span>
<span id="L4486"><span class="lineNum">    4486</span>              : // there will be hash collisions. It also depends on an OpenSSL-specific</span>
<span id="L4487"><span class="lineNum">    4487</span>              : // canonicalization process.</span>
<span id="L4488"><span class="lineNum">    4488</span>              : OPENSSL_EXPORT uint32_t X509_issuer_name_hash(X509 *x509);</span>
<span id="L4489"><span class="lineNum">    4489</span>              : </span>
<span id="L4490"><span class="lineNum">    4490</span>              : // X509_subject_name_hash returns the hash of |x509|'s subject name with</span>
<span id="L4491"><span class="lineNum">    4491</span>              : // |X509_NAME_hash|.</span>
<span id="L4492"><span class="lineNum">    4492</span>              : //</span>
<span id="L4493"><span class="lineNum">    4493</span>              : // This hash is specific to the |X509_LOOKUP_add_dir| filesystem format and is</span>
<span id="L4494"><span class="lineNum">    4494</span>              : // not suitable for general-purpose X.509 name processing. It is very short, so</span>
<span id="L4495"><span class="lineNum">    4495</span>              : // there will be hash collisions. It also depends on an OpenSSL-specific</span>
<span id="L4496"><span class="lineNum">    4496</span>              : // canonicalization process.</span>
<span id="L4497"><span class="lineNum">    4497</span>              : OPENSSL_EXPORT uint32_t X509_subject_name_hash(X509 *x509);</span>
<span id="L4498"><span class="lineNum">    4498</span>              : </span>
<span id="L4499"><span class="lineNum">    4499</span>              : // X509_issuer_name_hash_old returns the hash of |x509|'s issuer name with</span>
<span id="L4500"><span class="lineNum">    4500</span>              : // |X509_NAME_hash_old|.</span>
<span id="L4501"><span class="lineNum">    4501</span>              : //</span>
<span id="L4502"><span class="lineNum">    4502</span>              : // This hash is specific to the |X509_LOOKUP_add_dir| filesystem format and is</span>
<span id="L4503"><span class="lineNum">    4503</span>              : // not suitable for general-purpose X.509 name processing. It is very short, so</span>
<span id="L4504"><span class="lineNum">    4504</span>              : // there will be hash collisions.</span>
<span id="L4505"><span class="lineNum">    4505</span>              : OPENSSL_EXPORT uint32_t X509_issuer_name_hash_old(X509 *x509);</span>
<span id="L4506"><span class="lineNum">    4506</span>              : </span>
<span id="L4507"><span class="lineNum">    4507</span>              : // X509_subject_name_hash_old returns the hash of |x509|'s usjbect name with</span>
<span id="L4508"><span class="lineNum">    4508</span>              : // |X509_NAME_hash_old|.</span>
<span id="L4509"><span class="lineNum">    4509</span>              : //</span>
<span id="L4510"><span class="lineNum">    4510</span>              : // This hash is specific to the |X509_LOOKUP_add_dir| filesystem format and is</span>
<span id="L4511"><span class="lineNum">    4511</span>              : // not suitable for general-purpose X.509 name processing. It is very short, so</span>
<span id="L4512"><span class="lineNum">    4512</span>              : // there will be hash collisions.</span>
<span id="L4513"><span class="lineNum">    4513</span>              : OPENSSL_EXPORT uint32_t X509_subject_name_hash_old(X509 *x509);</span>
<span id="L4514"><span class="lineNum">    4514</span>              : </span>
<span id="L4515"><span class="lineNum">    4515</span>              : </span>
<span id="L4516"><span class="lineNum">    4516</span>              : // ex_data functions.</span>
<span id="L4517"><span class="lineNum">    4517</span>              : //</span>
<span id="L4518"><span class="lineNum">    4518</span>              : // See |ex_data.h| for details.</span>
<span id="L4519"><span class="lineNum">    4519</span>              : </span>
<span id="L4520"><span class="lineNum">    4520</span>              : OPENSSL_EXPORT int X509_get_ex_new_index(long argl, void *argp,</span>
<span id="L4521"><span class="lineNum">    4521</span>              :                                          CRYPTO_EX_unused *unused,</span>
<span id="L4522"><span class="lineNum">    4522</span>              :                                          CRYPTO_EX_dup *dup_unused,</span>
<span id="L4523"><span class="lineNum">    4523</span>              :                                          CRYPTO_EX_free *free_func);</span>
<span id="L4524"><span class="lineNum">    4524</span>              : OPENSSL_EXPORT int X509_set_ex_data(X509 *r, int idx, void *arg);</span>
<span id="L4525"><span class="lineNum">    4525</span>              : OPENSSL_EXPORT void *X509_get_ex_data(X509 *r, int idx);</span>
<span id="L4526"><span class="lineNum">    4526</span>              : </span>
<span id="L4527"><span class="lineNum">    4527</span>              : OPENSSL_EXPORT int X509_STORE_CTX_get_ex_new_index(long argl, void *argp,</span>
<span id="L4528"><span class="lineNum">    4528</span>              :                                                    CRYPTO_EX_unused *unused,</span>
<span id="L4529"><span class="lineNum">    4529</span>              :                                                    CRYPTO_EX_dup *dup_unused,</span>
<span id="L4530"><span class="lineNum">    4530</span>              :                                                    CRYPTO_EX_free *free_func);</span>
<span id="L4531"><span class="lineNum">    4531</span>              : OPENSSL_EXPORT int X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx,</span>
<span id="L4532"><span class="lineNum">    4532</span>              :                                               void *data);</span>
<span id="L4533"><span class="lineNum">    4533</span>              : OPENSSL_EXPORT void *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx, int idx);</span>
<span id="L4534"><span class="lineNum">    4534</span>              : </span>
<span id="L4535"><span class="lineNum">    4535</span>              : #define X509_STORE_CTX_set_app_data(ctx, data) \</span>
<span id="L4536"><span class="lineNum">    4536</span>              :   X509_STORE_CTX_set_ex_data(ctx, 0, data)</span>
<span id="L4537"><span class="lineNum">    4537</span>              : #define X509_STORE_CTX_get_app_data(ctx) X509_STORE_CTX_get_ex_data(ctx, 0)</span>
<span id="L4538"><span class="lineNum">    4538</span>              : </span>
<span id="L4539"><span class="lineNum">    4539</span>              : </span>
<span id="L4540"><span class="lineNum">    4540</span>              : // Hashing and signing ASN.1 structures.</span>
<span id="L4541"><span class="lineNum">    4541</span>              : </span>
<span id="L4542"><span class="lineNum">    4542</span>              : // ASN1_digest serializes |data| with |i2d| and then hashes the result with</span>
<span id="L4543"><span class="lineNum">    4543</span>              : // |type|. On success, it returns one, writes the digest to |md|, and sets</span>
<span id="L4544"><span class="lineNum">    4544</span>              : // |*len| to the digest length if non-NULL. On error, it returns zero.</span>
<span id="L4545"><span class="lineNum">    4545</span>              : //</span>
<span id="L4546"><span class="lineNum">    4546</span>              : // |EVP_MD_CTX_size| bytes are written, which is at most |EVP_MAX_MD_SIZE|. The</span>
<span id="L4547"><span class="lineNum">    4547</span>              : // buffer must have sufficient space for this output.</span>
<span id="L4548"><span class="lineNum">    4548</span>              : OPENSSL_EXPORT int ASN1_digest(i2d_of_void *i2d, const EVP_MD *type, char *data,</span>
<span id="L4549"><span class="lineNum">    4549</span>              :                                unsigned char *md, unsigned int *len);</span>
<span id="L4550"><span class="lineNum">    4550</span>              : </span>
<span id="L4551"><span class="lineNum">    4551</span>              : // ASN1_item_digest serializes |data| with |it| and then hashes the result with</span>
<span id="L4552"><span class="lineNum">    4552</span>              : // |type|. On success, it returns one, writes the digest to |md|, and sets</span>
<span id="L4553"><span class="lineNum">    4553</span>              : // |*len| to the digest length if non-NULL. On error, it returns zero.</span>
<span id="L4554"><span class="lineNum">    4554</span>              : //</span>
<span id="L4555"><span class="lineNum">    4555</span>              : // |EVP_MD_CTX_size| bytes are written, which is at most |EVP_MAX_MD_SIZE|. The</span>
<span id="L4556"><span class="lineNum">    4556</span>              : // buffer must have sufficient space for this output.</span>
<span id="L4557"><span class="lineNum">    4557</span>              : //</span>
<span id="L4558"><span class="lineNum">    4558</span>              : // WARNING: |data| must be a pointer with the same type as |it|'s corresponding</span>
<span id="L4559"><span class="lineNum">    4559</span>              : // C type. Using the wrong type is a potentially exploitable memory error.</span>
<span id="L4560"><span class="lineNum">    4560</span>              : OPENSSL_EXPORT int ASN1_item_digest(const ASN1_ITEM *it, const EVP_MD *type,</span>
<span id="L4561"><span class="lineNum">    4561</span>              :                                     void *data, unsigned char *md,</span>
<span id="L4562"><span class="lineNum">    4562</span>              :                                     unsigned int *len);</span>
<span id="L4563"><span class="lineNum">    4563</span>              : </span>
<span id="L4564"><span class="lineNum">    4564</span>              : // ASN1_item_verify serializes |data| with |it| and then verifies |signature| is</span>
<span id="L4565"><span class="lineNum">    4565</span>              : // a valid signature for the result with |algor1| and |pkey|. It returns one on</span>
<span id="L4566"><span class="lineNum">    4566</span>              : // success and zero on error. The signature and algorithm are interpreted as in</span>
<span id="L4567"><span class="lineNum">    4567</span>              : // X.509.</span>
<span id="L4568"><span class="lineNum">    4568</span>              : //</span>
<span id="L4569"><span class="lineNum">    4569</span>              : // WARNING: |data| must be a pointer with the same type as |it|'s corresponding</span>
<span id="L4570"><span class="lineNum">    4570</span>              : // C type. Using the wrong type is a potentially exploitable memory error.</span>
<span id="L4571"><span class="lineNum">    4571</span>              : OPENSSL_EXPORT int ASN1_item_verify(const ASN1_ITEM *it,</span>
<span id="L4572"><span class="lineNum">    4572</span>              :                                     const X509_ALGOR *algor1,</span>
<span id="L4573"><span class="lineNum">    4573</span>              :                                     const ASN1_BIT_STRING *signature,</span>
<span id="L4574"><span class="lineNum">    4574</span>              :                                     void *data, EVP_PKEY *pkey);</span>
<span id="L4575"><span class="lineNum">    4575</span>              : </span>
<span id="L4576"><span class="lineNum">    4576</span>              : // ASN1_item_sign serializes |data| with |it| and then signs the result with</span>
<span id="L4577"><span class="lineNum">    4577</span>              : // the private key |pkey|. It returns the length of the signature on success and</span>
<span id="L4578"><span class="lineNum">    4578</span>              : // zero on error. On success, it writes the signature to |signature| and the</span>
<span id="L4579"><span class="lineNum">    4579</span>              : // signature algorithm to each of |algor1| and |algor2|. Either of |algor1| or</span>
<span id="L4580"><span class="lineNum">    4580</span>              : // |algor2| may be NULL to ignore them. This function uses digest algorithm</span>
<span id="L4581"><span class="lineNum">    4581</span>              : // |md|, or |pkey|'s default if NULL. Other signing parameters use |pkey|'s</span>
<span id="L4582"><span class="lineNum">    4582</span>              : // defaults. To customize them, use |ASN1_item_sign_ctx|.</span>
<span id="L4583"><span class="lineNum">    4583</span>              : //</span>
<span id="L4584"><span class="lineNum">    4584</span>              : // WARNING: |data| must be a pointer with the same type as |it|'s corresponding</span>
<span id="L4585"><span class="lineNum">    4585</span>              : // C type. Using the wrong type is a potentially exploitable memory error.</span>
<span id="L4586"><span class="lineNum">    4586</span>              : OPENSSL_EXPORT int ASN1_item_sign(const ASN1_ITEM *it, X509_ALGOR *algor1,</span>
<span id="L4587"><span class="lineNum">    4587</span>              :                                   X509_ALGOR *algor2,</span>
<span id="L4588"><span class="lineNum">    4588</span>              :                                   ASN1_BIT_STRING *signature, void *data,</span>
<span id="L4589"><span class="lineNum">    4589</span>              :                                   EVP_PKEY *pkey, const EVP_MD *type);</span>
<span id="L4590"><span class="lineNum">    4590</span>              : </span>
<span id="L4591"><span class="lineNum">    4591</span>              : // ASN1_item_sign_ctx behaves like |ASN1_item_sign| except the signature is</span>
<span id="L4592"><span class="lineNum">    4592</span>              : // signed with |ctx|, |ctx|, which must have been initialized with</span>
<span id="L4593"><span class="lineNum">    4593</span>              : // |EVP_DigestSignInit|. The caller should configure the corresponding</span>
<span id="L4594"><span class="lineNum">    4594</span>              : // |EVP_PKEY_CTX| with any additional parameters before calling this function.</span>
<span id="L4595"><span class="lineNum">    4595</span>              : //</span>
<span id="L4596"><span class="lineNum">    4596</span>              : // On success or failure, this function mutates |ctx| and resets it to the empty</span>
<span id="L4597"><span class="lineNum">    4597</span>              : // state. Caller should not rely on its contents after the function returns.</span>
<span id="L4598"><span class="lineNum">    4598</span>              : //</span>
<span id="L4599"><span class="lineNum">    4599</span>              : // WARNING: |data| must be a pointer with the same type as |it|'s corresponding</span>
<span id="L4600"><span class="lineNum">    4600</span>              : // C type. Using the wrong type is a potentially exploitable memory error.</span>
<span id="L4601"><span class="lineNum">    4601</span>              : OPENSSL_EXPORT int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,</span>
<span id="L4602"><span class="lineNum">    4602</span>              :                                       X509_ALGOR *algor2,</span>
<span id="L4603"><span class="lineNum">    4603</span>              :                                       ASN1_BIT_STRING *signature, void *asn,</span>
<span id="L4604"><span class="lineNum">    4604</span>              :                                       EVP_MD_CTX *ctx);</span>
<span id="L4605"><span class="lineNum">    4605</span>              : </span>
<span id="L4606"><span class="lineNum">    4606</span>              : </span>
<span id="L4607"><span class="lineNum">    4607</span>              : // Verification internals.</span>
<span id="L4608"><span class="lineNum">    4608</span>              : //</span>
<span id="L4609"><span class="lineNum">    4609</span>              : // The following functions expose portions of certificate validation. They are</span>
<span id="L4610"><span class="lineNum">    4610</span>              : // exported for compatibility with existing callers, or to support some obscure</span>
<span id="L4611"><span class="lineNum">    4611</span>              : // use cases. Most callers, however, will not need these functions and should</span>
<span id="L4612"><span class="lineNum">    4612</span>              : // instead use |X509_STORE_CTX| APIs.</span>
<span id="L4613"><span class="lineNum">    4613</span>              : </span>
<span id="L4614"><span class="lineNum">    4614</span>              : // X509_supported_extension returns one if |ex| is a critical X.509 certificate</span>
<span id="L4615"><span class="lineNum">    4615</span>              : // extension, supported by |X509_verify_cert|, and zero otherwise.</span>
<span id="L4616"><span class="lineNum">    4616</span>              : //</span>
<span id="L4617"><span class="lineNum">    4617</span>              : // Note this function only reports certificate extensions (as opposed to CRL or</span>
<span id="L4618"><span class="lineNum">    4618</span>              : // CRL extensions), and only extensions that are expected to be marked critical.</span>
<span id="L4619"><span class="lineNum">    4619</span>              : // Additionally, |X509_verify_cert| checks for unsupported critical extensions</span>
<span id="L4620"><span class="lineNum">    4620</span>              : // internally, so most callers will not need to call this function separately.</span>
<span id="L4621"><span class="lineNum">    4621</span>              : OPENSSL_EXPORT int X509_supported_extension(const X509_EXTENSION *ex);</span>
<span id="L4622"><span class="lineNum">    4622</span>              : </span>
<span id="L4623"><span class="lineNum">    4623</span>              : // X509_check_ca returns one if |x509| may be considered a CA certificate,</span>
<span id="L4624"><span class="lineNum">    4624</span>              : // according to basic constraints and key usage extensions. Otherwise, it</span>
<span id="L4625"><span class="lineNum">    4625</span>              : // returns zero. If |x509| is an X509v1 certificate, and thus has no extensions,</span>
<span id="L4626"><span class="lineNum">    4626</span>              : // it is considered eligible.</span>
<span id="L4627"><span class="lineNum">    4627</span>              : //</span>
<span id="L4628"><span class="lineNum">    4628</span>              : // This function returning one does not indicate that |x509| is trusted, only</span>
<span id="L4629"><span class="lineNum">    4629</span>              : // that it is eligible to be a CA.</span>
<span id="L4630"><span class="lineNum">    4630</span>              : //</span>
<span id="L4631"><span class="lineNum">    4631</span>              : // TODO(crbug.com/boringssl/407): |x509| should be const.</span>
<span id="L4632"><span class="lineNum">    4632</span>              : OPENSSL_EXPORT int X509_check_ca(X509 *x509);</span>
<span id="L4633"><span class="lineNum">    4633</span>              : </span>
<span id="L4634"><span class="lineNum">    4634</span>              : // X509_check_issued checks if |issuer| and |subject|'s name, authority key</span>
<span id="L4635"><span class="lineNum">    4635</span>              : // identifier, and key usage fields allow |issuer| to have issued |subject|. It</span>
<span id="L4636"><span class="lineNum">    4636</span>              : // returns |X509_V_OK| on success and an |X509_V_ERR_*| value otherwise.</span>
<span id="L4637"><span class="lineNum">    4637</span>              : //</span>
<span id="L4638"><span class="lineNum">    4638</span>              : // This function does not check the signature on |subject|. Rather, it is</span>
<span id="L4639"><span class="lineNum">    4639</span>              : // intended to prune the set of possible issuer certificates during</span>
<span id="L4640"><span class="lineNum">    4640</span>              : // path-building.</span>
<span id="L4641"><span class="lineNum">    4641</span>              : //</span>
<span id="L4642"><span class="lineNum">    4642</span>              : // TODO(crbug.com/boringssl/407): Both parameters should be const.</span>
<span id="L4643"><span class="lineNum">    4643</span>              : OPENSSL_EXPORT int X509_check_issued(X509 *issuer, X509 *subject);</span>
<span id="L4644"><span class="lineNum">    4644</span>              : </span>
<span id="L4645"><span class="lineNum">    4645</span>              : // NAME_CONSTRAINTS_check checks if |x509| satisfies name constraints in |nc|.</span>
<span id="L4646"><span class="lineNum">    4646</span>              : // It returns |X509_V_OK| on success and some |X509_V_ERR_*| constant on error.</span>
<span id="L4647"><span class="lineNum">    4647</span>              : //</span>
<span id="L4648"><span class="lineNum">    4648</span>              : // TODO(crbug.com/boringssl/407): Both parameters should be const.</span>
<span id="L4649"><span class="lineNum">    4649</span>              : OPENSSL_EXPORT int NAME_CONSTRAINTS_check(X509 *x509, NAME_CONSTRAINTS *nc);</span>
<span id="L4650"><span class="lineNum">    4650</span>              : </span>
<span id="L4651"><span class="lineNum">    4651</span>              : // X509_check_host checks if |x509| matches the DNS name |chk|. It returns one</span>
<span id="L4652"><span class="lineNum">    4652</span>              : // on match, zero on mismatch, or a negative number on error. |flags| should be</span>
<span id="L4653"><span class="lineNum">    4653</span>              : // some combination of |X509_CHECK_FLAG_*| and modifies the behavior. On match,</span>
<span id="L4654"><span class="lineNum">    4654</span>              : // if |out_peername| is non-NULL, it additionally sets |*out_peername| to a</span>
<span id="L4655"><span class="lineNum">    4655</span>              : // newly-allocated, NUL-terminated string containing the DNS name or wildcard in</span>
<span id="L4656"><span class="lineNum">    4656</span>              : // the certificate which matched. The caller must then free |*out_peername| with</span>
<span id="L4657"><span class="lineNum">    4657</span>              : // |OPENSSL_free| when done.</span>
<span id="L4658"><span class="lineNum">    4658</span>              : //</span>
<span id="L4659"><span class="lineNum">    4659</span>              : // By default, both subject alternative names and the subject's common name</span>
<span id="L4660"><span class="lineNum">    4660</span>              : // attribute are checked. The latter has long been deprecated, so callers should</span>
<span id="L4661"><span class="lineNum">    4661</span>              : // include |X509_CHECK_FLAG_NEVER_CHECK_SUBJECT| in |flags| to use the standard</span>
<span id="L4662"><span class="lineNum">    4662</span>              : // behavior. https://crbug.com/boringssl/464 tracks fixing the default.</span>
<span id="L4663"><span class="lineNum">    4663</span>              : //</span>
<span id="L4664"><span class="lineNum">    4664</span>              : // This function does not check if |x509| is a trusted certificate, only if,</span>
<span id="L4665"><span class="lineNum">    4665</span>              : // were it trusted, it would match |chk|.</span>
<span id="L4666"><span class="lineNum">    4666</span>              : //</span>
<span id="L4667"><span class="lineNum">    4667</span>              : // WARNING: This function differs from the usual calling convention and may</span>
<span id="L4668"><span class="lineNum">    4668</span>              : // return either 0 or a negative number on error.</span>
<span id="L4669"><span class="lineNum">    4669</span>              : //</span>
<span id="L4670"><span class="lineNum">    4670</span>              : // TODO(davidben): Make the error case also return zero.</span>
<span id="L4671"><span class="lineNum">    4671</span>              : OPENSSL_EXPORT int X509_check_host(const X509 *x509, const char *chk,</span>
<span id="L4672"><span class="lineNum">    4672</span>              :                                    size_t chklen, unsigned int flags,</span>
<span id="L4673"><span class="lineNum">    4673</span>              :                                    char **out_peername);</span>
<span id="L4674"><span class="lineNum">    4674</span>              : </span>
<span id="L4675"><span class="lineNum">    4675</span>              : // X509_check_email checks if |x509| matches the email address |chk|. It returns</span>
<span id="L4676"><span class="lineNum">    4676</span>              : // one on match, zero on mismatch, or a negative number on error. |flags| should</span>
<span id="L4677"><span class="lineNum">    4677</span>              : // be some combination of |X509_CHECK_FLAG_*| and modifies the behavior.</span>
<span id="L4678"><span class="lineNum">    4678</span>              : //</span>
<span id="L4679"><span class="lineNum">    4679</span>              : // By default, both subject alternative names and the subject's email address</span>
<span id="L4680"><span class="lineNum">    4680</span>              : // attribute are checked. The |X509_CHECK_FLAG_NEVER_CHECK_SUBJECT| flag may be</span>
<span id="L4681"><span class="lineNum">    4681</span>              : // used to change this behavior.</span>
<span id="L4682"><span class="lineNum">    4682</span>              : //</span>
<span id="L4683"><span class="lineNum">    4683</span>              : // This function does not check if |x509| is a trusted certificate, only if,</span>
<span id="L4684"><span class="lineNum">    4684</span>              : // were it trusted, it would match |chk|.</span>
<span id="L4685"><span class="lineNum">    4685</span>              : //</span>
<span id="L4686"><span class="lineNum">    4686</span>              : // WARNING: This function differs from the usual calling convention and may</span>
<span id="L4687"><span class="lineNum">    4687</span>              : // return either 0 or a negative number on error.</span>
<span id="L4688"><span class="lineNum">    4688</span>              : //</span>
<span id="L4689"><span class="lineNum">    4689</span>              : // TODO(davidben): Make the error case also return zero.</span>
<span id="L4690"><span class="lineNum">    4690</span>              : OPENSSL_EXPORT int X509_check_email(const X509 *x509, const char *chk,</span>
<span id="L4691"><span class="lineNum">    4691</span>              :                                     size_t chklen, unsigned int flags);</span>
<span id="L4692"><span class="lineNum">    4692</span>              : </span>
<span id="L4693"><span class="lineNum">    4693</span>              : // X509_check_ip checks if |x509| matches the IP address |chk|. The IP address</span>
<span id="L4694"><span class="lineNum">    4694</span>              : // is represented in byte form and should be 4 bytes for an IPv4 address and 16</span>
<span id="L4695"><span class="lineNum">    4695</span>              : // bytes for an IPv6 address. It returns one on match, zero on mismatch, or a</span>
<span id="L4696"><span class="lineNum">    4696</span>              : // negative number on error. |flags| should be some combination of</span>
<span id="L4697"><span class="lineNum">    4697</span>              : // |X509_CHECK_FLAG_*| and modifies the behavior.</span>
<span id="L4698"><span class="lineNum">    4698</span>              : //</span>
<span id="L4699"><span class="lineNum">    4699</span>              : // This function does not check if |x509| is a trusted certificate, only if,</span>
<span id="L4700"><span class="lineNum">    4700</span>              : // were it trusted, it would match |chk|.</span>
<span id="L4701"><span class="lineNum">    4701</span>              : //</span>
<span id="L4702"><span class="lineNum">    4702</span>              : // WARNING: This function differs from the usual calling convention and may</span>
<span id="L4703"><span class="lineNum">    4703</span>              : // return either 0 or a negative number on error.</span>
<span id="L4704"><span class="lineNum">    4704</span>              : //</span>
<span id="L4705"><span class="lineNum">    4705</span>              : // TODO(davidben): Make the error case also return zero.</span>
<span id="L4706"><span class="lineNum">    4706</span>              : OPENSSL_EXPORT int X509_check_ip(const X509 *x509, const uint8_t *chk,</span>
<span id="L4707"><span class="lineNum">    4707</span>              :                                  size_t chklen, unsigned int flags);</span>
<span id="L4708"><span class="lineNum">    4708</span>              : </span>
<span id="L4709"><span class="lineNum">    4709</span>              : // X509_check_ip_asc behaves like |X509_check_ip| except the IP address is</span>
<span id="L4710"><span class="lineNum">    4710</span>              : // specified in textual form in |ipasc|.</span>
<span id="L4711"><span class="lineNum">    4711</span>              : //</span>
<span id="L4712"><span class="lineNum">    4712</span>              : // WARNING: This function differs from the usual calling convention and may</span>
<span id="L4713"><span class="lineNum">    4713</span>              : // return either 0 or a negative number on error.</span>
<span id="L4714"><span class="lineNum">    4714</span>              : //</span>
<span id="L4715"><span class="lineNum">    4715</span>              : // TODO(davidben): Make the error case also return zero.</span>
<span id="L4716"><span class="lineNum">    4716</span>              : OPENSSL_EXPORT int X509_check_ip_asc(const X509 *x509, const char *ipasc,</span>
<span id="L4717"><span class="lineNum">    4717</span>              :                                      unsigned int flags);</span>
<span id="L4718"><span class="lineNum">    4718</span>              : </span>
<span id="L4719"><span class="lineNum">    4719</span>              : // X509_STORE_CTX_get1_issuer looks up a candidate trusted issuer for |x509| out</span>
<span id="L4720"><span class="lineNum">    4720</span>              : // of |ctx|'s |X509_STORE|, based on the criteria in |X509_check_issued|. If one</span>
<span id="L4721"><span class="lineNum">    4721</span>              : // was found, it returns one and sets |*out_issuer| to the issuer. The caller</span>
<span id="L4722"><span class="lineNum">    4722</span>              : // must release |*out_issuer| with |X509_free| when done. If none was found, it</span>
<span id="L4723"><span class="lineNum">    4723</span>              : // returns zero and leaves |*out_issuer| unchanged.</span>
<span id="L4724"><span class="lineNum">    4724</span>              : //</span>
<span id="L4725"><span class="lineNum">    4725</span>              : // This function only searches for trusted issuers. It does not consider</span>
<span id="L4726"><span class="lineNum">    4726</span>              : // untrusted intermediates passed in to |X509_STORE_CTX_init|.</span>
<span id="L4727"><span class="lineNum">    4727</span>              : //</span>
<span id="L4728"><span class="lineNum">    4728</span>              : // TODO(crbug.com/boringssl/407): |x509| should be const.</span>
<span id="L4729"><span class="lineNum">    4729</span>              : OPENSSL_EXPORT int X509_STORE_CTX_get1_issuer(X509 **out_issuer,</span>
<span id="L4730"><span class="lineNum">    4730</span>              :                                               X509_STORE_CTX *ctx, X509 *x509);</span>
<span id="L4731"><span class="lineNum">    4731</span>              : </span>
<span id="L4732"><span class="lineNum">    4732</span>              : // X509_check_purpose performs checks if |x509|'s basic constraints, key usage,</span>
<span id="L4733"><span class="lineNum">    4733</span>              : // and extended key usage extensions for the specified purpose. |purpose| should</span>
<span id="L4734"><span class="lineNum">    4734</span>              : // be one of |X509_PURPOSE_*| constants. See |X509_VERIFY_PARAM_set_purpose| for</span>
<span id="L4735"><span class="lineNum">    4735</span>              : // details. It returns one if |x509|'s extensions are consistent with |purpose|</span>
<span id="L4736"><span class="lineNum">    4736</span>              : // and zero otherwise. If |ca| is non-zero, |x509| is checked as a CA</span>
<span id="L4737"><span class="lineNum">    4737</span>              : // certificate. Otherwise, it is checked as an end-entity certificate.</span>
<span id="L4738"><span class="lineNum">    4738</span>              : //</span>
<span id="L4739"><span class="lineNum">    4739</span>              : // If |purpose| is -1, this function performs no purpose checks, but it parses</span>
<span id="L4740"><span class="lineNum">    4740</span>              : // some extensions in |x509| and may return zero on syntax error. Historically,</span>
<span id="L4741"><span class="lineNum">    4741</span>              : // callers primarily used this function to trigger this parsing, but this is no</span>
<span id="L4742"><span class="lineNum">    4742</span>              : // longer necessary. Functions acting on |X509| will internally parse as needed.</span>
<span id="L4743"><span class="lineNum">    4743</span>              : OPENSSL_EXPORT int X509_check_purpose(X509 *x509, int purpose, int ca);</span>
<span id="L4744"><span class="lineNum">    4744</span>              : </span>
<span id="L4745"><span class="lineNum">    4745</span>              : #define X509_TRUST_TRUSTED 1</span>
<span id="L4746"><span class="lineNum">    4746</span>              : #define X509_TRUST_REJECTED 2</span>
<span id="L4747"><span class="lineNum">    4747</span>              : #define X509_TRUST_UNTRUSTED 3</span>
<span id="L4748"><span class="lineNum">    4748</span>              : </span>
<span id="L4749"><span class="lineNum">    4749</span>              : // X509_check_trust checks if |x509| is a valid trust anchor for trust type</span>
<span id="L4750"><span class="lineNum">    4750</span>              : // |id|. See |X509_VERIFY_PARAM_set_trust| for details. It returns</span>
<span id="L4751"><span class="lineNum">    4751</span>              : // |X509_TRUST_TRUSTED| if |x509| is a trust anchor, |X509_TRUST_REJECTED| if it</span>
<span id="L4752"><span class="lineNum">    4752</span>              : // was distrusted, and |X509_TRUST_UNTRUSTED| otherwise. |id| should be one of</span>
<span id="L4753"><span class="lineNum">    4753</span>              : // the |X509_TRUST_*| constants, or zero to indicate the default behavior.</span>
<span id="L4754"><span class="lineNum">    4754</span>              : // |flags| should be zero and is ignored.</span>
<span id="L4755"><span class="lineNum">    4755</span>              : OPENSSL_EXPORT int X509_check_trust(X509 *x509, int id, int flags);</span>
<span id="L4756"><span class="lineNum">    4756</span>              : </span>
<span id="L4757"><span class="lineNum">    4757</span>              : // X509_STORE_CTX_get1_certs returns a newly-allocated stack containing all</span>
<span id="L4758"><span class="lineNum">    4758</span>              : // trusted certificates in |ctx|'s |X509_STORE| whose subject matches |name|, or</span>
<span id="L4759"><span class="lineNum">    4759</span>              : // NULL on error. The caller must release the result with |sk_X509_pop_free| and</span>
<span id="L4760"><span class="lineNum">    4760</span>              : // |X509_free| when done.</span>
<span id="L4761"><span class="lineNum">    4761</span>              : //</span>
<span id="L4762"><span class="lineNum">    4762</span>              : // TODO(crbug.com/boringssl/407): |name| should be const.</span>
<span id="L4763"><span class="lineNum">    4763</span>              : OPENSSL_EXPORT STACK_OF(X509) *X509_STORE_CTX_get1_certs(X509_STORE_CTX *ctx,</span>
<span id="L4764"><span class="lineNum">    4764</span>              :                                                          X509_NAME *name);</span>
<span id="L4765"><span class="lineNum">    4765</span>              : </span>
<span id="L4766"><span class="lineNum">    4766</span>              : // X509_STORE_CTX_get1_crls returns a newly-allocated stack containing all</span>
<span id="L4767"><span class="lineNum">    4767</span>              : // CRLs in |ctx|'s |X509_STORE| whose subject matches |name|, or NULL on error.</span>
<span id="L4768"><span class="lineNum">    4768</span>              : // The caller must release the result with |sk_X509_CRL_pop_free| and</span>
<span id="L4769"><span class="lineNum">    4769</span>              : // |X509_CRL_free| when done.</span>
<span id="L4770"><span class="lineNum">    4770</span>              : //</span>
<span id="L4771"><span class="lineNum">    4771</span>              : // TODO(crbug.com/boringssl/407): |name| should be const.</span>
<span id="L4772"><span class="lineNum">    4772</span>              : OPENSSL_EXPORT STACK_OF(X509_CRL) *X509_STORE_CTX_get1_crls(X509_STORE_CTX *ctx,</span>
<span id="L4773"><span class="lineNum">    4773</span>              :                                                             X509_NAME *name);</span>
<span id="L4774"><span class="lineNum">    4774</span>              : </span>
<span id="L4775"><span class="lineNum">    4775</span>              : // X509_STORE_CTX_get_by_subject looks up an object of type |type| in |ctx|'s</span>
<span id="L4776"><span class="lineNum">    4776</span>              : // |X509_STORE| that matches |name|. |type| should be one of the |X509_LU_*|</span>
<span id="L4777"><span class="lineNum">    4777</span>              : // constants to indicate the type of object. If a match was found, it stores the</span>
<span id="L4778"><span class="lineNum">    4778</span>              : // result in |ret| and returns one. Otherwise, it returns zero. If multiple</span>
<span id="L4779"><span class="lineNum">    4779</span>              : // objects match, this function outputs an arbitray one.</span>
<span id="L4780"><span class="lineNum">    4780</span>              : //</span>
<span id="L4781"><span class="lineNum">    4781</span>              : // WARNING: |ret| must be in the empty state, as returned by |X509_OBJECT_new|.</span>
<span id="L4782"><span class="lineNum">    4782</span>              : // Otherwise, the object currently in |ret| will be leaked when overwritten.</span>
<span id="L4783"><span class="lineNum">    4783</span>              : // https://crbug.com/boringssl/685 tracks fixing this.</span>
<span id="L4784"><span class="lineNum">    4784</span>              : //</span>
<span id="L4785"><span class="lineNum">    4785</span>              : // WARNING: Multiple trusted certificates or CRLs may share a name. In this</span>
<span id="L4786"><span class="lineNum">    4786</span>              : // case, this function returns an arbitrary match. Use</span>
<span id="L4787"><span class="lineNum">    4787</span>              : // |X509_STORE_CTX_get1_certs| or |X509_STORE_CTX_get1_crls| instead.</span>
<span id="L4788"><span class="lineNum">    4788</span>              : //</span>
<span id="L4789"><span class="lineNum">    4789</span>              : // TODO(crbug.com/boringssl/407): |name| should be const.</span>
<span id="L4790"><span class="lineNum">    4790</span>              : OPENSSL_EXPORT int X509_STORE_CTX_get_by_subject(X509_STORE_CTX *ctx, int type,</span>
<span id="L4791"><span class="lineNum">    4791</span>              :                                                  X509_NAME *name,</span>
<span id="L4792"><span class="lineNum">    4792</span>              :                                                  X509_OBJECT *ret);</span>
<span id="L4793"><span class="lineNum">    4793</span>              : </span>
<span id="L4794"><span class="lineNum">    4794</span>              : </span>
<span id="L4795"><span class="lineNum">    4795</span>              : // X.509 information.</span>
<span id="L4796"><span class="lineNum">    4796</span>              : //</span>
<span id="L4797"><span class="lineNum">    4797</span>              : // |X509_INFO| is the return type for |PEM_X509_INFO_read_bio|, defined in</span>
<span id="L4798"><span class="lineNum">    4798</span>              : // &lt;openssl/pem.h&gt;. It is used to store a certificate, CRL, or private key. This</span>
<span id="L4799"><span class="lineNum">    4799</span>              : // type is defined in this header for OpenSSL compatibility.</span>
<span id="L4800"><span class="lineNum">    4800</span>              : </span>
<span id="L4801"><span class="lineNum">    4801</span>              : struct private_key_st {</span>
<span id="L4802"><span class="lineNum">    4802</span>              :   EVP_PKEY *dec_pkey;</span>
<span id="L4803"><span class="lineNum">    4803</span>              : } /* X509_PKEY */;</span>
<span id="L4804"><span class="lineNum">    4804</span>              : </span>
<span id="L4805"><span class="lineNum">    4805</span>              : struct X509_info_st {</span>
<span id="L4806"><span class="lineNum">    4806</span>              :   X509 *x509;</span>
<span id="L4807"><span class="lineNum">    4807</span>              :   X509_CRL *crl;</span>
<span id="L4808"><span class="lineNum">    4808</span>              :   X509_PKEY *x_pkey;</span>
<span id="L4809"><span class="lineNum">    4809</span>              : </span>
<span id="L4810"><span class="lineNum">    4810</span>              :   EVP_CIPHER_INFO enc_cipher;</span>
<span id="L4811"><span class="lineNum">    4811</span>              :   int enc_len;</span>
<span id="L4812"><span class="lineNum">    4812</span>              :   char *enc_data;</span>
<span id="L4813"><span class="lineNum">    4813</span>              : } /* X509_INFO */;</span>
<span id="L4814"><span class="lineNum">    4814</span>              : </span>
<span id="L4815"><span class="lineNum">    4815</span>              : DEFINE_STACK_OF(X509_INFO)</span>
<span id="L4816"><span class="lineNum">    4816</span>              : </span>
<span id="L4817"><span class="lineNum">    4817</span>              : // X509_INFO_free releases memory associated with |info|.</span>
<span id="L4818"><span class="lineNum">    4818</span>              : OPENSSL_EXPORT void X509_INFO_free(X509_INFO *info);</span>
<span id="L4819"><span class="lineNum">    4819</span>              : </span>
<span id="L4820"><span class="lineNum">    4820</span>              : </span>
<span id="L4821"><span class="lineNum">    4821</span>              : // Deprecated custom extension registration.</span>
<span id="L4822"><span class="lineNum">    4822</span>              : //</span>
<span id="L4823"><span class="lineNum">    4823</span>              : // The following functions allow callers to register custom extensions for use</span>
<span id="L4824"><span class="lineNum">    4824</span>              : // with |X509V3_EXT_d2i| and related functions. This mechanism is deprecated and</span>
<span id="L4825"><span class="lineNum">    4825</span>              : // will be removed in the future. As discussed in |X509V3_EXT_add|, it is not</span>
<span id="L4826"><span class="lineNum">    4826</span>              : // possible to safely register a custom extension without risking race</span>
<span id="L4827"><span class="lineNum">    4827</span>              : // conditions and memory errors when linked with other users of BoringSSL.</span>
<span id="L4828"><span class="lineNum">    4828</span>              : //</span>
<span id="L4829"><span class="lineNum">    4829</span>              : // Moreover, it is not necessary to register a custom extension to process</span>
<span id="L4830"><span class="lineNum">    4830</span>              : // extensions unknown to BoringSSL. Registration does not impact certificate</span>
<span id="L4831"><span class="lineNum">    4831</span>              : // verification. Caller should instead use functions such as</span>
<span id="L4832"><span class="lineNum">    4832</span>              : // |ASN1_OBJECT_create|, |X509_get_ext_by_OBJ|, |X509_EXTENSION_get_data|, and</span>
<span id="L4833"><span class="lineNum">    4833</span>              : // |X509_EXTENSION_create_by_OBJ| to inspect or create extensions directly.</span>
<span id="L4834"><span class="lineNum">    4834</span>              : </span>
<span id="L4835"><span class="lineNum">    4835</span>              : // The following function pointer types are used in |X509V3_EXT_METHOD|.</span>
<span id="L4836"><span class="lineNum">    4836</span>              : typedef void *(*X509V3_EXT_NEW)(void);</span>
<span id="L4837"><span class="lineNum">    4837</span>              : typedef void (*X509V3_EXT_FREE)(void *ext);</span>
<span id="L4838"><span class="lineNum">    4838</span>              : typedef void *(*X509V3_EXT_D2I)(void *ext, const uint8_t **inp, long len);</span>
<span id="L4839"><span class="lineNum">    4839</span>              : typedef int (*X509V3_EXT_I2D)(void *ext, uint8_t **outp);</span>
<span id="L4840"><span class="lineNum">    4840</span>              : typedef STACK_OF(CONF_VALUE) *(*X509V3_EXT_I2V)(const X509V3_EXT_METHOD *method,</span>
<span id="L4841"><span class="lineNum">    4841</span>              :                                                 void *ext,</span>
<span id="L4842"><span class="lineNum">    4842</span>              :                                                 STACK_OF(CONF_VALUE) *extlist);</span>
<span id="L4843"><span class="lineNum">    4843</span>              : typedef void *(*X509V3_EXT_V2I)(const X509V3_EXT_METHOD *method,</span>
<span id="L4844"><span class="lineNum">    4844</span>              :                                 const X509V3_CTX *ctx,</span>
<span id="L4845"><span class="lineNum">    4845</span>              :                                 const STACK_OF(CONF_VALUE) *values);</span>
<span id="L4846"><span class="lineNum">    4846</span>              : typedef char *(*X509V3_EXT_I2S)(const X509V3_EXT_METHOD *method, void *ext);</span>
<span id="L4847"><span class="lineNum">    4847</span>              : typedef void *(*X509V3_EXT_S2I)(const X509V3_EXT_METHOD *method,</span>
<span id="L4848"><span class="lineNum">    4848</span>              :                                 const X509V3_CTX *ctx, const char *str);</span>
<span id="L4849"><span class="lineNum">    4849</span>              : typedef int (*X509V3_EXT_I2R)(const X509V3_EXT_METHOD *method, void *ext,</span>
<span id="L4850"><span class="lineNum">    4850</span>              :                               BIO *out, int indent);</span>
<span id="L4851"><span class="lineNum">    4851</span>              : typedef void *(*X509V3_EXT_R2I)(const X509V3_EXT_METHOD *method,</span>
<span id="L4852"><span class="lineNum">    4852</span>              :                                 const X509V3_CTX *ctx, const char *str);</span>
<span id="L4853"><span class="lineNum">    4853</span>              : </span>
<span id="L4854"><span class="lineNum">    4854</span>              : // A v3_ext_method, aka |X509V3_EXT_METHOD|, is a deprecated type which defines</span>
<span id="L4855"><span class="lineNum">    4855</span>              : // a custom extension.</span>
<span id="L4856"><span class="lineNum">    4856</span>              : struct v3_ext_method {</span>
<span id="L4857"><span class="lineNum">    4857</span>              :   // ext_nid is the NID of the extension.</span>
<span id="L4858"><span class="lineNum">    4858</span>              :   int ext_nid;</span>
<span id="L4859"><span class="lineNum">    4859</span>              : </span>
<span id="L4860"><span class="lineNum">    4860</span>              :   // ext_flags is a combination of |X509V3_EXT_*| constants.</span>
<span id="L4861"><span class="lineNum">    4861</span>              :   int ext_flags;</span>
<span id="L4862"><span class="lineNum">    4862</span>              : </span>
<span id="L4863"><span class="lineNum">    4863</span>              :   // it determines how values of this extension are allocated, released, parsed,</span>
<span id="L4864"><span class="lineNum">    4864</span>              :   // and marshalled. This must be non-NULL.</span>
<span id="L4865"><span class="lineNum">    4865</span>              :   ASN1_ITEM_EXP *it;</span>
<span id="L4866"><span class="lineNum">    4866</span>              : </span>
<span id="L4867"><span class="lineNum">    4867</span>              :   // The following functions are ignored in favor of |it|. They are retained in</span>
<span id="L4868"><span class="lineNum">    4868</span>              :   // the struct only for source compatibility with existing struct definitions.</span>
<span id="L4869"><span class="lineNum">    4869</span>              :   X509V3_EXT_NEW ext_new;</span>
<span id="L4870"><span class="lineNum">    4870</span>              :   X509V3_EXT_FREE ext_free;</span>
<span id="L4871"><span class="lineNum">    4871</span>              :   X509V3_EXT_D2I d2i;</span>
<span id="L4872"><span class="lineNum">    4872</span>              :   X509V3_EXT_I2D i2d;</span>
<span id="L4873"><span class="lineNum">    4873</span>              : </span>
<span id="L4874"><span class="lineNum">    4874</span>              :   // The following functions are used for string extensions.</span>
<span id="L4875"><span class="lineNum">    4875</span>              :   X509V3_EXT_I2S i2s;</span>
<span id="L4876"><span class="lineNum">    4876</span>              :   X509V3_EXT_S2I s2i;</span>
<span id="L4877"><span class="lineNum">    4877</span>              : </span>
<span id="L4878"><span class="lineNum">    4878</span>              :   // The following functions are used for multi-valued extensions.</span>
<span id="L4879"><span class="lineNum">    4879</span>              :   X509V3_EXT_I2V i2v;</span>
<span id="L4880"><span class="lineNum">    4880</span>              :   X509V3_EXT_V2I v2i;</span>
<span id="L4881"><span class="lineNum">    4881</span>              : </span>
<span id="L4882"><span class="lineNum">    4882</span>              :   // The following functions are used for &quot;raw&quot; extensions, which implement</span>
<span id="L4883"><span class="lineNum">    4883</span>              :   // custom printing behavior.</span>
<span id="L4884"><span class="lineNum">    4884</span>              :   X509V3_EXT_I2R i2r;</span>
<span id="L4885"><span class="lineNum">    4885</span>              :   X509V3_EXT_R2I r2i;</span>
<span id="L4886"><span class="lineNum">    4886</span>              : </span>
<span id="L4887"><span class="lineNum">    4887</span>              :   void *usr_data;  // Any extension specific data</span>
<span id="L4888"><span class="lineNum">    4888</span>              : } /* X509V3_EXT_METHOD */;</span>
<span id="L4889"><span class="lineNum">    4889</span>              : </span>
<span id="L4890"><span class="lineNum">    4890</span>              : // X509V3_EXT_MULTILINE causes the result of an |X509V3_EXT_METHOD|'s |i2v|</span>
<span id="L4891"><span class="lineNum">    4891</span>              : // function to be printed on separate lines, rather than separated by commas.</span>
<span id="L4892"><span class="lineNum">    4892</span>              : #define X509V3_EXT_MULTILINE 0x4</span>
<span id="L4893"><span class="lineNum">    4893</span>              : </span>
<span id="L4894"><span class="lineNum">    4894</span>              : // X509V3_EXT_get returns the |X509V3_EXT_METHOD| corresponding to |ext|'s</span>
<span id="L4895"><span class="lineNum">    4895</span>              : // extension type, or NULL if none was registered.</span>
<span id="L4896"><span class="lineNum">    4896</span>              : OPENSSL_EXPORT const X509V3_EXT_METHOD *X509V3_EXT_get(</span>
<span id="L4897"><span class="lineNum">    4897</span>              :     const X509_EXTENSION *ext);</span>
<span id="L4898"><span class="lineNum">    4898</span>              : </span>
<span id="L4899"><span class="lineNum">    4899</span>              : // X509V3_EXT_get_nid returns the |X509V3_EXT_METHOD| corresponding to |nid|, or</span>
<span id="L4900"><span class="lineNum">    4900</span>              : // NULL if none was registered.</span>
<span id="L4901"><span class="lineNum">    4901</span>              : OPENSSL_EXPORT const X509V3_EXT_METHOD *X509V3_EXT_get_nid(int nid);</span>
<span id="L4902"><span class="lineNum">    4902</span>              : </span>
<span id="L4903"><span class="lineNum">    4903</span>              : // X509V3_EXT_add registers |ext| as a custom extension for the extension type</span>
<span id="L4904"><span class="lineNum">    4904</span>              : // |ext-&gt;ext_nid|. |ext| must be valid for the remainder of the address space's</span>
<span id="L4905"><span class="lineNum">    4905</span>              : // lifetime. It returns one on success and zero on error.</span>
<span id="L4906"><span class="lineNum">    4906</span>              : //</span>
<span id="L4907"><span class="lineNum">    4907</span>              : // WARNING: This function modifies global state. If other code in the same</span>
<span id="L4908"><span class="lineNum">    4908</span>              : // address space also registers an extension with type |ext-&gt;ext_nid|, the two</span>
<span id="L4909"><span class="lineNum">    4909</span>              : // registrations will conflict. Which registration takes effect is undefined. If</span>
<span id="L4910"><span class="lineNum">    4910</span>              : // the two registrations use incompatible in-memory representations, code</span>
<span id="L4911"><span class="lineNum">    4911</span>              : // expecting the other registration will then cast a type to the wrong type,</span>
<span id="L4912"><span class="lineNum">    4912</span>              : // resulting in a potentially exploitable memory error. This conflict can also</span>
<span id="L4913"><span class="lineNum">    4913</span>              : // occur if BoringSSL later adds support for |ext-&gt;ext_nid|, with a different</span>
<span id="L4914"><span class="lineNum">    4914</span>              : // in-memory representation than the one expected by |ext|.</span>
<span id="L4915"><span class="lineNum">    4915</span>              : //</span>
<span id="L4916"><span class="lineNum">    4916</span>              : // This function, additionally, is not thread-safe and cannot be called</span>
<span id="L4917"><span class="lineNum">    4917</span>              : // concurrently with any other BoringSSL function.</span>
<span id="L4918"><span class="lineNum">    4918</span>              : //</span>
<span id="L4919"><span class="lineNum">    4919</span>              : // As a result, it is impossible to safely use this function. Registering a</span>
<span id="L4920"><span class="lineNum">    4920</span>              : // custom extension has no impact on certificate verification so, instead,</span>
<span id="L4921"><span class="lineNum">    4921</span>              : // callers should simply handle the custom extension with the byte-based</span>
<span id="L4922"><span class="lineNum">    4922</span>              : // |X509_EXTENSION| APIs directly. Registering |ext| with the library has little</span>
<span id="L4923"><span class="lineNum">    4923</span>              : // practical value.</span>
<span id="L4924"><span class="lineNum">    4924</span>              : OPENSSL_EXPORT OPENSSL_DEPRECATED int X509V3_EXT_add(X509V3_EXT_METHOD *ext);</span>
<span id="L4925"><span class="lineNum">    4925</span>              : </span>
<span id="L4926"><span class="lineNum">    4926</span>              : // X509V3_EXT_add_alias registers a custom extension with NID |nid_to|. The</span>
<span id="L4927"><span class="lineNum">    4927</span>              : // corresponding ASN.1 type is copied from |nid_from|. It returns one on success</span>
<span id="L4928"><span class="lineNum">    4928</span>              : // and zero on error.</span>
<span id="L4929"><span class="lineNum">    4929</span>              : //</span>
<span id="L4930"><span class="lineNum">    4930</span>              : // WARNING: Do not use this function. See |X509V3_EXT_add|.</span>
<span id="L4931"><span class="lineNum">    4931</span>              : OPENSSL_EXPORT OPENSSL_DEPRECATED int X509V3_EXT_add_alias(int nid_to,</span>
<span id="L4932"><span class="lineNum">    4932</span>              :                                                            int nid_from);</span>
<span id="L4933"><span class="lineNum">    4933</span>              : </span>
<span id="L4934"><span class="lineNum">    4934</span>              : </span>
<span id="L4935"><span class="lineNum">    4935</span>              : // Deprecated config-based extension creation.</span>
<span id="L4936"><span class="lineNum">    4936</span>              : //</span>
<span id="L4937"><span class="lineNum">    4937</span>              : // The following functions allow specifying X.509 extensions using OpenSSL's</span>
<span id="L4938"><span class="lineNum">    4938</span>              : // config file syntax, from the OpenSSL command-line tool. They are retained,</span>
<span id="L4939"><span class="lineNum">    4939</span>              : // for now, for compatibility with legacy software but may be removed in the</span>
<span id="L4940"><span class="lineNum">    4940</span>              : // future. Construct the extensions using the typed C APIs instead.</span>
<span id="L4941"><span class="lineNum">    4941</span>              : //</span>
<span id="L4942"><span class="lineNum">    4942</span>              : // Callers should especially avoid these functions if passing in non-constant</span>
<span id="L4943"><span class="lineNum">    4943</span>              : // values. They use ad-hoc, string-based formats which are prone to injection</span>
<span id="L4944"><span class="lineNum">    4944</span>              : // vulnerabilities. For a CA, this means using them risks misissuance.</span>
<span id="L4945"><span class="lineNum">    4945</span>              : //</span>
<span id="L4946"><span class="lineNum">    4946</span>              : // These functions are not safe to use with untrusted inputs. The string formats</span>
<span id="L4947"><span class="lineNum">    4947</span>              : // may implicitly reference context information and, in OpenSSL (though not</span>
<span id="L4948"><span class="lineNum">    4948</span>              : // BoringSSL), one even allows reading arbitrary files. Many formats can also</span>
<span id="L4949"><span class="lineNum">    4949</span>              : // produce far larger outputs than their inputs, so untrusted inputs may lead to</span>
<span id="L4950"><span class="lineNum">    4950</span>              : // denial-of-service attacks. Finally, the parsers see much less testing and</span>
<span id="L4951"><span class="lineNum">    4951</span>              : // review than most of the library and may have bugs including memory leaks or</span>
<span id="L4952"><span class="lineNum">    4952</span>              : // crashes.</span>
<span id="L4953"><span class="lineNum">    4953</span>              : </span>
<span id="L4954"><span class="lineNum">    4954</span>              : // v3_ext_ctx, aka |X509V3_CTX|, contains additional context information for</span>
<span id="L4955"><span class="lineNum">    4955</span>              : // constructing extensions. Some string formats reference additional values in</span>
<span id="L4956"><span class="lineNum">    4956</span>              : // these objects. It must be initialized with |X509V3_set_ctx| or</span>
<span id="L4957"><span class="lineNum">    4957</span>              : // |X509V3_set_ctx_test| before use.</span>
<span id="L4958"><span class="lineNum">    4958</span>              : struct v3_ext_ctx {</span>
<span id="L4959"><span class="lineNum">    4959</span>              :   int flags;</span>
<span id="L4960"><span class="lineNum">    4960</span>              :   const X509 *issuer_cert;</span>
<span id="L4961"><span class="lineNum">    4961</span>              :   const X509 *subject_cert;</span>
<span id="L4962"><span class="lineNum">    4962</span>              :   const X509_REQ *subject_req;</span>
<span id="L4963"><span class="lineNum">    4963</span>              :   const X509_CRL *crl;</span>
<span id="L4964"><span class="lineNum">    4964</span>              :   const CONF *db;</span>
<span id="L4965"><span class="lineNum">    4965</span>              : };</span>
<span id="L4966"><span class="lineNum">    4966</span>              : </span>
<span id="L4967"><span class="lineNum">    4967</span>              : #define X509V3_CTX_TEST 0x1</span>
<span id="L4968"><span class="lineNum">    4968</span>              : </span>
<span id="L4969"><span class="lineNum">    4969</span>              : // X509V3_set_ctx initializes |ctx| with the specified objects. Some string</span>
<span id="L4970"><span class="lineNum">    4970</span>              : // formats will reference fields in these objects. Each object may be NULL to</span>
<span id="L4971"><span class="lineNum">    4971</span>              : // omit it, in which case those formats cannot be used. |flags| should be zero,</span>
<span id="L4972"><span class="lineNum">    4972</span>              : // unless called via |X509V3_set_ctx_test|.</span>
<span id="L4973"><span class="lineNum">    4973</span>              : //</span>
<span id="L4974"><span class="lineNum">    4974</span>              : // |issuer|, |subject|, |req|, and |crl|, if non-NULL, must outlive |ctx|.</span>
<span id="L4975"><span class="lineNum">    4975</span>              : OPENSSL_EXPORT void X509V3_set_ctx(X509V3_CTX *ctx, const X509 *issuer,</span>
<span id="L4976"><span class="lineNum">    4976</span>              :                                    const X509 *subject, const X509_REQ *req,</span>
<span id="L4977"><span class="lineNum">    4977</span>              :                                    const X509_CRL *crl, int flags);</span>
<span id="L4978"><span class="lineNum">    4978</span>              : </span>
<span id="L4979"><span class="lineNum">    4979</span>              : // X509V3_set_ctx_test calls |X509V3_set_ctx| without any reference objects and</span>
<span id="L4980"><span class="lineNum">    4980</span>              : // mocks out some features that use them. The resulting extensions may be</span>
<span id="L4981"><span class="lineNum">    4981</span>              : // incomplete and should be discarded. This can be used to partially validate</span>
<span id="L4982"><span class="lineNum">    4982</span>              : // syntax.</span>
<span id="L4983"><span class="lineNum">    4983</span>              : //</span>
<span id="L4984"><span class="lineNum">    4984</span>              : // TODO(davidben): Can we remove this?</span>
<span id="L4985"><span class="lineNum">    4985</span>              : #define X509V3_set_ctx_test(ctx) \</span>
<span id="L4986"><span class="lineNum">    4986</span>              :   X509V3_set_ctx(ctx, NULL, NULL, NULL, NULL, X509V3_CTX_TEST)</span>
<span id="L4987"><span class="lineNum">    4987</span>              : </span>
<span id="L4988"><span class="lineNum">    4988</span>              : // X509V3_set_nconf sets |ctx| to use |conf| as the config database. |ctx| must</span>
<span id="L4989"><span class="lineNum">    4989</span>              : // have previously been initialized by |X509V3_set_ctx| or</span>
<span id="L4990"><span class="lineNum">    4990</span>              : // |X509V3_set_ctx_test|. Some string formats will reference sections in |conf|.</span>
<span id="L4991"><span class="lineNum">    4991</span>              : // |conf| may be NULL, in which case these formats cannot be used. If non-NULL,</span>
<span id="L4992"><span class="lineNum">    4992</span>              : // |conf| must outlive |ctx|.</span>
<span id="L4993"><span class="lineNum">    4993</span>              : OPENSSL_EXPORT void X509V3_set_nconf(X509V3_CTX *ctx, const CONF *conf);</span>
<span id="L4994"><span class="lineNum">    4994</span>              : </span>
<span id="L4995"><span class="lineNum">    4995</span>              : // X509V3_set_ctx_nodb calls |X509V3_set_nconf| with no config database.</span>
<span id="L4996"><span class="lineNum">    4996</span>              : #define X509V3_set_ctx_nodb(ctx) X509V3_set_nconf(ctx, NULL)</span>
<span id="L4997"><span class="lineNum">    4997</span>              : </span>
<span id="L4998"><span class="lineNum">    4998</span>              : // X509V3_EXT_nconf constructs an extension of type specified by |name|, and</span>
<span id="L4999"><span class="lineNum">    4999</span>              : // value specified by |value|. It returns a newly-allocated |X509_EXTENSION|</span>
<span id="L5000"><span class="lineNum">    5000</span>              : // object on success, or NULL on error. |conf| and |ctx| specify additional</span>
<span id="L5001"><span class="lineNum">    5001</span>              : // information referenced by some formats. Either |conf| or |ctx| may be NULL,</span>
<span id="L5002"><span class="lineNum">    5002</span>              : // in which case features which use it will be disabled.</span>
<span id="L5003"><span class="lineNum">    5003</span>              : //</span>
<span id="L5004"><span class="lineNum">    5004</span>              : // If non-NULL, |ctx| must be initialized with |X509V3_set_ctx| or</span>
<span id="L5005"><span class="lineNum">    5005</span>              : // |X509V3_set_ctx_test|.</span>
<span id="L5006"><span class="lineNum">    5006</span>              : //</span>
<span id="L5007"><span class="lineNum">    5007</span>              : // Both |conf| and |ctx| provide a |CONF| object. When |ctx| is non-NULL, most</span>
<span id="L5008"><span class="lineNum">    5008</span>              : // features use the |ctx| copy, configured with |X509V3_set_ctx|, but some use</span>
<span id="L5009"><span class="lineNum">    5009</span>              : // |conf|. Callers should ensure the two match to avoid surprisingly behavior.</span>
<span id="L5010"><span class="lineNum">    5010</span>              : OPENSSL_EXPORT X509_EXTENSION *X509V3_EXT_nconf(const CONF *conf,</span>
<span id="L5011"><span class="lineNum">    5011</span>              :                                                 const X509V3_CTX *ctx,</span>
<span id="L5012"><span class="lineNum">    5012</span>              :                                                 const char *name,</span>
<span id="L5013"><span class="lineNum">    5013</span>              :                                                 const char *value);</span>
<span id="L5014"><span class="lineNum">    5014</span>              : </span>
<span id="L5015"><span class="lineNum">    5015</span>              : // X509V3_EXT_nconf_nid behaves like |X509V3_EXT_nconf|, except the extension</span>
<span id="L5016"><span class="lineNum">    5016</span>              : // type is specified as a NID.</span>
<span id="L5017"><span class="lineNum">    5017</span>              : OPENSSL_EXPORT X509_EXTENSION *X509V3_EXT_nconf_nid(const CONF *conf,</span>
<span id="L5018"><span class="lineNum">    5018</span>              :                                                     const X509V3_CTX *ctx,</span>
<span id="L5019"><span class="lineNum">    5019</span>              :                                                     int ext_nid,</span>
<span id="L5020"><span class="lineNum">    5020</span>              :                                                     const char *value);</span>
<span id="L5021"><span class="lineNum">    5021</span>              : </span>
<span id="L5022"><span class="lineNum">    5022</span>              : // X509V3_EXT_conf_nid calls |X509V3_EXT_nconf_nid|. |conf| must be NULL.</span>
<span id="L5023"><span class="lineNum">    5023</span>              : //</span>
<span id="L5024"><span class="lineNum">    5024</span>              : // TODO(davidben): This is the only exposed instance of an LHASH in our public</span>
<span id="L5025"><span class="lineNum">    5025</span>              : // headers. cryptography.io wraps this function so we cannot, yet, replace the</span>
<span id="L5026"><span class="lineNum">    5026</span>              : // type with a dummy struct.</span>
<span id="L5027"><span class="lineNum">    5027</span>              : OPENSSL_EXPORT X509_EXTENSION *X509V3_EXT_conf_nid(LHASH_OF(CONF_VALUE) *conf,</span>
<span id="L5028"><span class="lineNum">    5028</span>              :                                                    const X509V3_CTX *ctx,</span>
<span id="L5029"><span class="lineNum">    5029</span>              :                                                    int ext_nid,</span>
<span id="L5030"><span class="lineNum">    5030</span>              :                                                    const char *value);</span>
<span id="L5031"><span class="lineNum">    5031</span>              : </span>
<span id="L5032"><span class="lineNum">    5032</span>              : // X509V3_EXT_add_nconf_sk looks up the section named |section| in |conf|. For</span>
<span id="L5033"><span class="lineNum">    5033</span>              : // each |CONF_VALUE| in the section, it constructs an extension as in</span>
<span id="L5034"><span class="lineNum">    5034</span>              : // |X509V3_EXT_nconf|, taking |name| and |value| from the |CONF_VALUE|. Each new</span>
<span id="L5035"><span class="lineNum">    5035</span>              : // extension is appended to |*sk|. If |*sk| is non-NULL, and at least one</span>
<span id="L5036"><span class="lineNum">    5036</span>              : // extension is added, it sets |*sk| to a newly-allocated</span>
<span id="L5037"><span class="lineNum">    5037</span>              : // |STACK_OF(X509_EXTENSION)|. It returns one on success and zero on error.</span>
<span id="L5038"><span class="lineNum">    5038</span>              : OPENSSL_EXPORT int X509V3_EXT_add_nconf_sk(const CONF *conf,</span>
<span id="L5039"><span class="lineNum">    5039</span>              :                                            const X509V3_CTX *ctx,</span>
<span id="L5040"><span class="lineNum">    5040</span>              :                                            const char *section,</span>
<span id="L5041"><span class="lineNum">    5041</span>              :                                            STACK_OF(X509_EXTENSION) **sk);</span>
<span id="L5042"><span class="lineNum">    5042</span>              : </span>
<span id="L5043"><span class="lineNum">    5043</span>              : // X509V3_EXT_add_nconf adds extensions to |cert| as in</span>
<span id="L5044"><span class="lineNum">    5044</span>              : // |X509V3_EXT_add_nconf_sk|. It returns one on success and zero on error.</span>
<span id="L5045"><span class="lineNum">    5045</span>              : OPENSSL_EXPORT int X509V3_EXT_add_nconf(const CONF *conf, const X509V3_CTX *ctx,</span>
<span id="L5046"><span class="lineNum">    5046</span>              :                                         const char *section, X509 *cert);</span>
<span id="L5047"><span class="lineNum">    5047</span>              : </span>
<span id="L5048"><span class="lineNum">    5048</span>              : // X509V3_EXT_REQ_add_nconf adds extensions to |req| as in</span>
<span id="L5049"><span class="lineNum">    5049</span>              : // |X509V3_EXT_add_nconf_sk|. It returns one on success and zero on error.</span>
<span id="L5050"><span class="lineNum">    5050</span>              : OPENSSL_EXPORT int X509V3_EXT_REQ_add_nconf(const CONF *conf,</span>
<span id="L5051"><span class="lineNum">    5051</span>              :                                             const X509V3_CTX *ctx,</span>
<span id="L5052"><span class="lineNum">    5052</span>              :                                             const char *section, X509_REQ *req);</span>
<span id="L5053"><span class="lineNum">    5053</span>              : </span>
<span id="L5054"><span class="lineNum">    5054</span>              : // X509V3_EXT_CRL_add_nconf adds extensions to |crl| as in</span>
<span id="L5055"><span class="lineNum">    5055</span>              : // |X509V3_EXT_add_nconf_sk|. It returns one on success and zero on error.</span>
<span id="L5056"><span class="lineNum">    5056</span>              : OPENSSL_EXPORT int X509V3_EXT_CRL_add_nconf(const CONF *conf,</span>
<span id="L5057"><span class="lineNum">    5057</span>              :                                             const X509V3_CTX *ctx,</span>
<span id="L5058"><span class="lineNum">    5058</span>              :                                             const char *section, X509_CRL *crl);</span>
<span id="L5059"><span class="lineNum">    5059</span>              : </span>
<span id="L5060"><span class="lineNum">    5060</span>              : // i2s_ASN1_OCTET_STRING returns a human-readable representation of |oct| as a</span>
<span id="L5061"><span class="lineNum">    5061</span>              : // newly-allocated, NUL-terminated string, or NULL on error. |method| is</span>
<span id="L5062"><span class="lineNum">    5062</span>              : // ignored. The caller must release the result with |OPENSSL_free| when done.</span>
<span id="L5063"><span class="lineNum">    5063</span>              : OPENSSL_EXPORT char *i2s_ASN1_OCTET_STRING(const X509V3_EXT_METHOD *method,</span>
<span id="L5064"><span class="lineNum">    5064</span>              :                                            const ASN1_OCTET_STRING *oct);</span>
<span id="L5065"><span class="lineNum">    5065</span>              : </span>
<span id="L5066"><span class="lineNum">    5066</span>              : // s2i_ASN1_OCTET_STRING decodes |str| as a hexdecimal byte string, with</span>
<span id="L5067"><span class="lineNum">    5067</span>              : // optional colon separators between bytes. It returns a newly-allocated</span>
<span id="L5068"><span class="lineNum">    5068</span>              : // |ASN1_OCTET_STRING| with the result on success, or NULL on error. |method|</span>
<span id="L5069"><span class="lineNum">    5069</span>              : // and |ctx| are ignored.</span>
<span id="L5070"><span class="lineNum">    5070</span>              : OPENSSL_EXPORT ASN1_OCTET_STRING *s2i_ASN1_OCTET_STRING(</span>
<span id="L5071"><span class="lineNum">    5071</span>              :     const X509V3_EXT_METHOD *method, const X509V3_CTX *ctx, const char *str);</span>
<span id="L5072"><span class="lineNum">    5072</span>              : </span>
<span id="L5073"><span class="lineNum">    5073</span>              : // i2s_ASN1_INTEGER returns a human-readable representation of |aint| as a</span>
<span id="L5074"><span class="lineNum">    5074</span>              : // newly-allocated, NUL-terminated string, or NULL on error. |method| is</span>
<span id="L5075"><span class="lineNum">    5075</span>              : // ignored. The caller must release the result with |OPENSSL_free| when done.</span>
<span id="L5076"><span class="lineNum">    5076</span>              : OPENSSL_EXPORT char *i2s_ASN1_INTEGER(const X509V3_EXT_METHOD *method,</span>
<span id="L5077"><span class="lineNum">    5077</span>              :                                       const ASN1_INTEGER *aint);</span>
<span id="L5078"><span class="lineNum">    5078</span>              : </span>
<span id="L5079"><span class="lineNum">    5079</span>              : // s2i_ASN1_INTEGER decodes |value| as the ASCII representation of an integer,</span>
<span id="L5080"><span class="lineNum">    5080</span>              : // and returns a newly-allocated |ASN1_INTEGER| containing the result, or NULL</span>
<span id="L5081"><span class="lineNum">    5081</span>              : // on error. |method| is ignored. If |value| begins with &quot;0x&quot; or &quot;0X&quot;, the input</span>
<span id="L5082"><span class="lineNum">    5082</span>              : // is decoded in hexadecimal, otherwise decimal.</span>
<span id="L5083"><span class="lineNum">    5083</span>              : OPENSSL_EXPORT ASN1_INTEGER *s2i_ASN1_INTEGER(const X509V3_EXT_METHOD *method,</span>
<span id="L5084"><span class="lineNum">    5084</span>              :                                               const char *value);</span>
<span id="L5085"><span class="lineNum">    5085</span>              : </span>
<span id="L5086"><span class="lineNum">    5086</span>              : // i2s_ASN1_ENUMERATED returns a human-readable representation of |aint| as a</span>
<span id="L5087"><span class="lineNum">    5087</span>              : // newly-allocated, NUL-terminated string, or NULL on error. |method| is</span>
<span id="L5088"><span class="lineNum">    5088</span>              : // ignored. The caller must release the result with |OPENSSL_free| when done.</span>
<span id="L5089"><span class="lineNum">    5089</span>              : OPENSSL_EXPORT char *i2s_ASN1_ENUMERATED(const X509V3_EXT_METHOD *method,</span>
<span id="L5090"><span class="lineNum">    5090</span>              :                                          const ASN1_ENUMERATED *aint);</span>
<span id="L5091"><span class="lineNum">    5091</span>              : </span>
<span id="L5092"><span class="lineNum">    5092</span>              : // X509V3_conf_free releases memory associated with |CONF_VALUE|.</span>
<span id="L5093"><span class="lineNum">    5093</span>              : OPENSSL_EXPORT void X509V3_conf_free(CONF_VALUE *val);</span>
<span id="L5094"><span class="lineNum">    5094</span>              : </span>
<span id="L5095"><span class="lineNum">    5095</span>              : // i2v_GENERAL_NAME serializes |gen| as a |CONF_VALUE|. If |ret| is non-NULL, it</span>
<span id="L5096"><span class="lineNum">    5096</span>              : // appends the value to |ret| and returns |ret| on success or NULL on error. If</span>
<span id="L5097"><span class="lineNum">    5097</span>              : // it returns NULL, the caller is still responsible for freeing |ret|. If |ret|</span>
<span id="L5098"><span class="lineNum">    5098</span>              : // is NULL, it returns a newly-allocated |STACK_OF(CONF_VALUE)| containing the</span>
<span id="L5099"><span class="lineNum">    5099</span>              : // result. |method| is ignored. When done, the caller should release the result</span>
<span id="L5100"><span class="lineNum">    5100</span>              : // with |sk_CONF_VALUE_pop_free| and |X509V3_conf_free|.</span>
<span id="L5101"><span class="lineNum">    5101</span>              : //</span>
<span id="L5102"><span class="lineNum">    5102</span>              : // Do not use this function. This is an internal implementation detail of the</span>
<span id="L5103"><span class="lineNum">    5103</span>              : // human-readable print functions. If extracting a SAN list from a certificate,</span>
<span id="L5104"><span class="lineNum">    5104</span>              : // look at |gen| directly.</span>
<span id="L5105"><span class="lineNum">    5105</span>              : OPENSSL_EXPORT STACK_OF(CONF_VALUE) *i2v_GENERAL_NAME(</span>
<span id="L5106"><span class="lineNum">    5106</span>              :     const X509V3_EXT_METHOD *method, const GENERAL_NAME *gen,</span>
<span id="L5107"><span class="lineNum">    5107</span>              :     STACK_OF(CONF_VALUE) *ret);</span>
<span id="L5108"><span class="lineNum">    5108</span>              : </span>
<span id="L5109"><span class="lineNum">    5109</span>              : // i2v_GENERAL_NAMES serializes |gen| as a list of |CONF_VALUE|s. If |ret| is</span>
<span id="L5110"><span class="lineNum">    5110</span>              : // non-NULL, it appends the values to |ret| and returns |ret| on success or NULL</span>
<span id="L5111"><span class="lineNum">    5111</span>              : // on error. If it returns NULL, the caller is still responsible for freeing</span>
<span id="L5112"><span class="lineNum">    5112</span>              : // |ret|. If |ret| is NULL, it returns a newly-allocated |STACK_OF(CONF_VALUE)|</span>
<span id="L5113"><span class="lineNum">    5113</span>              : // containing the results. |method| is ignored.</span>
<span id="L5114"><span class="lineNum">    5114</span>              : //</span>
<span id="L5115"><span class="lineNum">    5115</span>              : // Do not use this function. This is an internal implementation detail of the</span>
<span id="L5116"><span class="lineNum">    5116</span>              : // human-readable print functions. If extracting a SAN list from a certificate,</span>
<span id="L5117"><span class="lineNum">    5117</span>              : // look at |gen| directly.</span>
<span id="L5118"><span class="lineNum">    5118</span>              : OPENSSL_EXPORT STACK_OF(CONF_VALUE) *i2v_GENERAL_NAMES(</span>
<span id="L5119"><span class="lineNum">    5119</span>              :     const X509V3_EXT_METHOD *method, const GENERAL_NAMES *gen,</span>
<span id="L5120"><span class="lineNum">    5120</span>              :     STACK_OF(CONF_VALUE) *extlist);</span>
<span id="L5121"><span class="lineNum">    5121</span>              : </span>
<span id="L5122"><span class="lineNum">    5122</span>              : // a2i_IPADDRESS decodes |ipasc| as the textual representation of an IPv4 or</span>
<span id="L5123"><span class="lineNum">    5123</span>              : // IPv6 address. On success, it returns a newly-allocated |ASN1_OCTET_STRING|</span>
<span id="L5124"><span class="lineNum">    5124</span>              : // containing the decoded IP address. IPv4 addresses are represented as 4-byte</span>
<span id="L5125"><span class="lineNum">    5125</span>              : // strings and IPv6 addresses as 16-byte strings. On failure, it returns NULL.</span>
<span id="L5126"><span class="lineNum">    5126</span>              : OPENSSL_EXPORT ASN1_OCTET_STRING *a2i_IPADDRESS(const char *ipasc);</span>
<span id="L5127"><span class="lineNum">    5127</span>              : </span>
<span id="L5128"><span class="lineNum">    5128</span>              : // a2i_IPADDRESS_NC decodes |ipasc| as the textual representation of an IPv4 or</span>
<span id="L5129"><span class="lineNum">    5129</span>              : // IPv6 address range. On success, it returns a newly-allocated</span>
<span id="L5130"><span class="lineNum">    5130</span>              : // |ASN1_OCTET_STRING| containing the decoded IP address, followed by the</span>
<span id="L5131"><span class="lineNum">    5131</span>              : // decoded mask. IPv4 ranges are represented as 8-byte strings and IPv6 ranges</span>
<span id="L5132"><span class="lineNum">    5132</span>              : // as 32-byte strings. On failure, it returns NULL.</span>
<span id="L5133"><span class="lineNum">    5133</span>              : //</span>
<span id="L5134"><span class="lineNum">    5134</span>              : // The text format decoded by this function is not the standard CIDR notiation.</span>
<span id="L5135"><span class="lineNum">    5135</span>              : // Instead, the mask after the &quot;/&quot; is represented as another IP address. For</span>
<span id="L5136"><span class="lineNum">    5136</span>              : // example, &quot;192.168.0.0/16&quot; would be written &quot;192.168.0.0/255.255.0.0&quot;.</span>
<span id="L5137"><span class="lineNum">    5137</span>              : OPENSSL_EXPORT ASN1_OCTET_STRING *a2i_IPADDRESS_NC(const char *ipasc);</span>
<span id="L5138"><span class="lineNum">    5138</span>              : </span>
<span id="L5139"><span class="lineNum">    5139</span>              : </span>
<span id="L5140"><span class="lineNum">    5140</span>              : // Deprecated functions.</span>
<span id="L5141"><span class="lineNum">    5141</span>              : </span>
<span id="L5142"><span class="lineNum">    5142</span>              : // X509_get_notBefore returns |x509|'s notBefore time. Note this function is not</span>
<span id="L5143"><span class="lineNum">    5143</span>              : // const-correct for legacy reasons. Use |X509_get0_notBefore| or</span>
<span id="L5144"><span class="lineNum">    5144</span>              : // |X509_getm_notBefore| instead.</span>
<span id="L5145"><span class="lineNum">    5145</span>              : OPENSSL_EXPORT ASN1_TIME *X509_get_notBefore(const X509 *x509);</span>
<span id="L5146"><span class="lineNum">    5146</span>              : </span>
<span id="L5147"><span class="lineNum">    5147</span>              : // X509_get_notAfter returns |x509|'s notAfter time. Note this function is not</span>
<span id="L5148"><span class="lineNum">    5148</span>              : // const-correct for legacy reasons. Use |X509_get0_notAfter| or</span>
<span id="L5149"><span class="lineNum">    5149</span>              : // |X509_getm_notAfter| instead.</span>
<span id="L5150"><span class="lineNum">    5150</span>              : OPENSSL_EXPORT ASN1_TIME *X509_get_notAfter(const X509 *x509);</span>
<span id="L5151"><span class="lineNum">    5151</span>              : </span>
<span id="L5152"><span class="lineNum">    5152</span>              : // X509_set_notBefore calls |X509_set1_notBefore|. Use |X509_set1_notBefore|</span>
<span id="L5153"><span class="lineNum">    5153</span>              : // instead.</span>
<span id="L5154"><span class="lineNum">    5154</span>              : OPENSSL_EXPORT int X509_set_notBefore(X509 *x509, const ASN1_TIME *tm);</span>
<span id="L5155"><span class="lineNum">    5155</span>              : </span>
<span id="L5156"><span class="lineNum">    5156</span>              : // X509_set_notAfter calls |X509_set1_notAfter|. Use |X509_set1_notAfter|</span>
<span id="L5157"><span class="lineNum">    5157</span>              : // instead.</span>
<span id="L5158"><span class="lineNum">    5158</span>              : OPENSSL_EXPORT int X509_set_notAfter(X509 *x509, const ASN1_TIME *tm);</span>
<span id="L5159"><span class="lineNum">    5159</span>              : </span>
<span id="L5160"><span class="lineNum">    5160</span>              : // X509_CRL_get_lastUpdate returns a mutable pointer to |crl|'s thisUpdate time.</span>
<span id="L5161"><span class="lineNum">    5161</span>              : // The OpenSSL API refers to this field as lastUpdate.</span>
<span id="L5162"><span class="lineNum">    5162</span>              : //</span>
<span id="L5163"><span class="lineNum">    5163</span>              : // Use |X509_CRL_get0_lastUpdate| or |X509_CRL_set1_lastUpdate| instead.</span>
<span id="L5164"><span class="lineNum">    5164</span>              : OPENSSL_EXPORT ASN1_TIME *X509_CRL_get_lastUpdate(X509_CRL *crl);</span>
<span id="L5165"><span class="lineNum">    5165</span>              : </span>
<span id="L5166"><span class="lineNum">    5166</span>              : // X509_CRL_get_nextUpdate returns a mutable pointer to |crl|'s nextUpdate time,</span>
<span id="L5167"><span class="lineNum">    5167</span>              : // or NULL if |crl| has none. Use |X509_CRL_get0_nextUpdate| or</span>
<span id="L5168"><span class="lineNum">    5168</span>              : // |X509_CRL_set1_nextUpdate| instead.</span>
<span id="L5169"><span class="lineNum">    5169</span>              : OPENSSL_EXPORT ASN1_TIME *X509_CRL_get_nextUpdate(X509_CRL *crl);</span>
<span id="L5170"><span class="lineNum">    5170</span>              : </span>
<span id="L5171"><span class="lineNum">    5171</span>              : // X509_extract_key is a legacy alias to |X509_get_pubkey|. Use</span>
<span id="L5172"><span class="lineNum">    5172</span>              : // |X509_get_pubkey| instead.</span>
<span id="L5173"><span class="lineNum">    5173</span>              : #define X509_extract_key(x) X509_get_pubkey(x)</span>
<span id="L5174"><span class="lineNum">    5174</span>              : </span>
<span id="L5175"><span class="lineNum">    5175</span>              : // X509_REQ_extract_key is a legacy alias for |X509_REQ_get_pubkey|.</span>
<span id="L5176"><span class="lineNum">    5176</span>              : #define X509_REQ_extract_key(a) X509_REQ_get_pubkey(a)</span>
<span id="L5177"><span class="lineNum">    5177</span>              : </span>
<span id="L5178"><span class="lineNum">    5178</span>              : // X509_name_cmp is a legacy alias for |X509_NAME_cmp|.</span>
<span id="L5179"><span class="lineNum">    5179</span>              : #define X509_name_cmp(a, b) X509_NAME_cmp((a), (b))</span>
<span id="L5180"><span class="lineNum">    5180</span>              : </span>
<span id="L5181"><span class="lineNum">    5181</span>              : // The following symbols are deprecated aliases to |X509_CRL_set1_*|.</span>
<span id="L5182"><span class="lineNum">    5182</span>              : #define X509_CRL_set_lastUpdate X509_CRL_set1_lastUpdate</span>
<span id="L5183"><span class="lineNum">    5183</span>              : #define X509_CRL_set_nextUpdate X509_CRL_set1_nextUpdate</span>
<span id="L5184"><span class="lineNum">    5184</span>              : </span>
<span id="L5185"><span class="lineNum">    5185</span>              : // X509_get_serialNumber returns a mutable pointer to |x509|'s serial number.</span>
<span id="L5186"><span class="lineNum">    5186</span>              : // Prefer |X509_get0_serialNumber|.</span>
<span id="L5187"><span class="lineNum">    5187</span>              : OPENSSL_EXPORT ASN1_INTEGER *X509_get_serialNumber(X509 *x509);</span>
<span id="L5188"><span class="lineNum">    5188</span>              : </span>
<span id="L5189"><span class="lineNum">    5189</span>              : // X509_NAME_get_text_by_OBJ finds the first attribute with type |obj| in</span>
<span id="L5190"><span class="lineNum">    5190</span>              : // |name|. If found, it writes the value's UTF-8 representation to |buf|.</span>
<span id="L5191"><span class="lineNum">    5191</span>              : // followed by a NUL byte, and returns the number of bytes in the output,</span>
<span id="L5192"><span class="lineNum">    5192</span>              : // excluding the NUL byte. This is unlike OpenSSL which returns the raw</span>
<span id="L5193"><span class="lineNum">    5193</span>              : // ASN1_STRING data. The UTF-8 encoding of the |ASN1_STRING| may not contain a 0</span>
<span id="L5194"><span class="lineNum">    5194</span>              : // codepoint.</span>
<span id="L5195"><span class="lineNum">    5195</span>              : //</span>
<span id="L5196"><span class="lineNum">    5196</span>              : // This function writes at most |len| bytes, including the NUL byte.  If |buf|</span>
<span id="L5197"><span class="lineNum">    5197</span>              : // is NULL, it writes nothing and returns the number of bytes in the</span>
<span id="L5198"><span class="lineNum">    5198</span>              : // output, excluding the NUL byte that would be required for the full UTF-8</span>
<span id="L5199"><span class="lineNum">    5199</span>              : // output.</span>
<span id="L5200"><span class="lineNum">    5200</span>              : //</span>
<span id="L5201"><span class="lineNum">    5201</span>              : // This function may return -1 if an error occurs for any reason, including the</span>
<span id="L5202"><span class="lineNum">    5202</span>              : // value not being a recognized string type, |len| being of insufficient size to</span>
<span id="L5203"><span class="lineNum">    5203</span>              : // hold the full UTF-8 encoding and NUL byte, memory allocation failures, an</span>
<span id="L5204"><span class="lineNum">    5204</span>              : // object with type |obj| not existing in |name|, or if the UTF-8 encoding of</span>
<span id="L5205"><span class="lineNum">    5205</span>              : // the string contains a zero byte.</span>
<span id="L5206"><span class="lineNum">    5206</span>              : OPENSSL_EXPORT int X509_NAME_get_text_by_OBJ(const X509_NAME *name,</span>
<span id="L5207"><span class="lineNum">    5207</span>              :                                              const ASN1_OBJECT *obj, char *buf,</span>
<span id="L5208"><span class="lineNum">    5208</span>              :                                              int len);</span>
<span id="L5209"><span class="lineNum">    5209</span>              : </span>
<span id="L5210"><span class="lineNum">    5210</span>              : // X509_NAME_get_text_by_NID behaves like |X509_NAME_get_text_by_OBJ| except it</span>
<span id="L5211"><span class="lineNum">    5211</span>              : // finds an attribute of type |nid|, which should be one of the |NID_*|</span>
<span id="L5212"><span class="lineNum">    5212</span>              : // constants.</span>
<span id="L5213"><span class="lineNum">    5213</span>              : OPENSSL_EXPORT int X509_NAME_get_text_by_NID(const X509_NAME *name, int nid,</span>
<span id="L5214"><span class="lineNum">    5214</span>              :                                              char *buf, int len);</span>
<span id="L5215"><span class="lineNum">    5215</span>              : </span>
<span id="L5216"><span class="lineNum">    5216</span>              : // X509_STORE_CTX_get0_parent_ctx returns NULL.</span>
<span id="L5217"><span class="lineNum">    5217</span>              : OPENSSL_EXPORT X509_STORE_CTX *X509_STORE_CTX_get0_parent_ctx(</span>
<span id="L5218"><span class="lineNum">    5218</span>              :     const X509_STORE_CTX *ctx);</span>
<span id="L5219"><span class="lineNum">    5219</span>              : </span>
<span id="L5220"><span class="lineNum">    5220</span>              : // X509_OBJECT_free_contents sets |obj| to the empty object, freeing any values</span>
<span id="L5221"><span class="lineNum">    5221</span>              : // that were previously there.</span>
<span id="L5222"><span class="lineNum">    5222</span>              : //</span>
<span id="L5223"><span class="lineNum">    5223</span>              : // TODO(davidben): Unexport this function after rust-openssl is fixed to no</span>
<span id="L5224"><span class="lineNum">    5224</span>              : // longer call it.</span>
<span id="L5225"><span class="lineNum">    5225</span>              : OPENSSL_EXPORT void X509_OBJECT_free_contents(X509_OBJECT *obj);</span>
<span id="L5226"><span class="lineNum">    5226</span>              : </span>
<span id="L5227"><span class="lineNum">    5227</span>              : // X509_LOOKUP_free releases memory associated with |ctx|. This function should</span>
<span id="L5228"><span class="lineNum">    5228</span>              : // never be used outside the library. No function in the public API hands</span>
<span id="L5229"><span class="lineNum">    5229</span>              : // ownership of an |X509_LOOKUP| to the caller.</span>
<span id="L5230"><span class="lineNum">    5230</span>              : //</span>
<span id="L5231"><span class="lineNum">    5231</span>              : // TODO(davidben): Unexport this function after rust-openssl is fixed to no</span>
<span id="L5232"><span class="lineNum">    5232</span>              : // longer call it.</span>
<span id="L5233"><span class="lineNum">    5233</span>              : OPENSSL_EXPORT void X509_LOOKUP_free(X509_LOOKUP *ctx);</span>
<span id="L5234"><span class="lineNum">    5234</span>              : </span>
<span id="L5235"><span class="lineNum">    5235</span>              : // X509_STORE_CTX_cleanup resets |ctx| to the empty state.</span>
<span id="L5236"><span class="lineNum">    5236</span>              : //</span>
<span id="L5237"><span class="lineNum">    5237</span>              : // This function is a remnant of when |X509_STORE_CTX| was stack-allocated and</span>
<span id="L5238"><span class="lineNum">    5238</span>              : // should not be used. If releasing |ctx|, call |X509_STORE_CTX_free|. If</span>
<span id="L5239"><span class="lineNum">    5239</span>              : // reusing |ctx| for a new verification, release the old one and create a new</span>
<span id="L5240"><span class="lineNum">    5240</span>              : // one.</span>
<span id="L5241"><span class="lineNum">    5241</span>              : OPENSSL_EXPORT void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx);</span>
<span id="L5242"><span class="lineNum">    5242</span>              : </span>
<span id="L5243"><span class="lineNum">    5243</span>              : // X509V3_add_standard_extensions returns one.</span>
<span id="L5244"><span class="lineNum">    5244</span>              : OPENSSL_EXPORT int X509V3_add_standard_extensions(void);</span>
<span id="L5245"><span class="lineNum">    5245</span>              : </span>
<span id="L5246"><span class="lineNum">    5246</span>              : // The following symbols are legacy aliases for |X509_STORE_CTX| functions.</span>
<span id="L5247"><span class="lineNum">    5247</span>              : #define X509_STORE_get_by_subject X509_STORE_CTX_get_by_subject</span>
<span id="L5248"><span class="lineNum">    5248</span>              : #define X509_STORE_get1_certs X509_STORE_CTX_get1_certs</span>
<span id="L5249"><span class="lineNum">    5249</span>              : #define X509_STORE_get1_crls X509_STORE_CTX_get1_crls</span>
<span id="L5250"><span class="lineNum">    5250</span>              : </span>
<span id="L5251"><span class="lineNum">    5251</span>              : // X509_STORE_CTX_get_chain is a legacy alias for |X509_STORE_CTX_get0_chain|.</span>
<span id="L5252"><span class="lineNum">    5252</span>              : OPENSSL_EXPORT STACK_OF(X509) *X509_STORE_CTX_get_chain(</span>
<span id="L5253"><span class="lineNum">    5253</span>              :     const X509_STORE_CTX *ctx);</span>
<span id="L5254"><span class="lineNum">    5254</span>              : </span>
<span id="L5255"><span class="lineNum">    5255</span>              : // X509_STORE_CTX_trusted_stack is a deprecated alias for</span>
<span id="L5256"><span class="lineNum">    5256</span>              : // |X509_STORE_CTX_set0_trusted_stack|.</span>
<span id="L5257"><span class="lineNum">    5257</span>              : OPENSSL_EXPORT void X509_STORE_CTX_trusted_stack(X509_STORE_CTX *ctx,</span>
<span id="L5258"><span class="lineNum">    5258</span>              :                                                  STACK_OF(X509) *sk);</span>
<span id="L5259"><span class="lineNum">    5259</span>              : </span>
<span id="L5260"><span class="lineNum">    5260</span>              : typedef int (*X509_STORE_CTX_verify_cb)(int, X509_STORE_CTX *);</span>
<span id="L5261"><span class="lineNum">    5261</span>              : </span>
<span id="L5262"><span class="lineNum">    5262</span>              : // X509_STORE_CTX_set_verify_cb configures a callback function for |ctx| that is</span>
<span id="L5263"><span class="lineNum">    5263</span>              : // called multiple times during |X509_verify_cert|. The callback returns zero to</span>
<span id="L5264"><span class="lineNum">    5264</span>              : // fail verification and one to proceed. Typically, it will return |ok|, which</span>
<span id="L5265"><span class="lineNum">    5265</span>              : // preserves the default behavior. Returning one when |ok| is zero will proceed</span>
<span id="L5266"><span class="lineNum">    5266</span>              : // past some error. The callback may inspect |ctx| and the error queue to</span>
<span id="L5267"><span class="lineNum">    5267</span>              : // attempt to determine the current stage of certificate verification, but this</span>
<span id="L5268"><span class="lineNum">    5268</span>              : // is often unreliable. When synthesizing an error, callbacks should use</span>
<span id="L5269"><span class="lineNum">    5269</span>              : // |X509_STORE_CTX_set_error| to set a corresponding error.</span>
<span id="L5270"><span class="lineNum">    5270</span>              : //</span>
<span id="L5271"><span class="lineNum">    5271</span>              : // WARNING: Do not use this function. It is extremely fragile and unpredictable.</span>
<span id="L5272"><span class="lineNum">    5272</span>              : // This callback exposes implementation details of certificate verification,</span>
<span id="L5273"><span class="lineNum">    5273</span>              : // which change as the library evolves. Attempting to use it for security checks</span>
<span id="L5274"><span class="lineNum">    5274</span>              : // can introduce vulnerabilities if making incorrect assumptions about when the</span>
<span id="L5275"><span class="lineNum">    5275</span>              : // callback is called. Some errors, when suppressed, may implicitly suppress</span>
<span id="L5276"><span class="lineNum">    5276</span>              : // other errors due to internal implementation details. Additionally, overriding</span>
<span id="L5277"><span class="lineNum">    5277</span>              : // |ok| may leave |ctx| in an inconsistent state and break invariants.</span>
<span id="L5278"><span class="lineNum">    5278</span>              : //</span>
<span id="L5279"><span class="lineNum">    5279</span>              : // Instead, customize certificate verification by configuring options on the</span>
<span id="L5280"><span class="lineNum">    5280</span>              : // |X509_STORE_CTX| before verification, or applying additional checks after</span>
<span id="L5281"><span class="lineNum">    5281</span>              : // |X509_verify_cert| completes successfully.</span>
<span id="L5282"><span class="lineNum">    5282</span>              : OPENSSL_EXPORT void X509_STORE_CTX_set_verify_cb(</span>
<span id="L5283"><span class="lineNum">    5283</span>              :     X509_STORE_CTX *ctx, int (*verify_cb)(int ok, X509_STORE_CTX *ctx));</span>
<span id="L5284"><span class="lineNum">    5284</span>              : </span>
<span id="L5285"><span class="lineNum">    5285</span>              : // X509_STORE_set_verify_cb acts like |X509_STORE_CTX_set_verify_cb| but sets</span>
<span id="L5286"><span class="lineNum">    5286</span>              : // the verify callback for any |X509_STORE_CTX| created from this |X509_STORE|</span>
<span id="L5287"><span class="lineNum">    5287</span>              : //</span>
<span id="L5288"><span class="lineNum">    5288</span>              : // Do not use this function. See |X509_STORE_CTX_set_verify_cb| for details.</span>
<span id="L5289"><span class="lineNum">    5289</span>              : OPENSSL_EXPORT void X509_STORE_set_verify_cb(</span>
<span id="L5290"><span class="lineNum">    5290</span>              :     X509_STORE *store, X509_STORE_CTX_verify_cb verify_cb);</span>
<span id="L5291"><span class="lineNum">    5291</span>              : </span>
<span id="L5292"><span class="lineNum">    5292</span>              : // X509_STORE_set_verify_cb_func is a deprecated alias for</span>
<span id="L5293"><span class="lineNum">    5293</span>              : // |X509_STORE_set_verify_cb|.</span>
<span id="L5294"><span class="lineNum">    5294</span>              : #define X509_STORE_set_verify_cb_func(store, func) \</span>
<span id="L5295"><span class="lineNum">    5295</span>              :   X509_STORE_set_verify_cb((store), (func))</span>
<span id="L5296"><span class="lineNum">    5296</span>              : </span>
<span id="L5297"><span class="lineNum">    5297</span>              : // X509_STORE_CTX_set_chain configures |ctx| to use |sk| for untrusted</span>
<span id="L5298"><span class="lineNum">    5298</span>              : // intermediate certificates to use in verification. This function is redundant</span>
<span id="L5299"><span class="lineNum">    5299</span>              : // with the |chain| parameter of |X509_STORE_CTX_init|. Use the parameter</span>
<span id="L5300"><span class="lineNum">    5300</span>              : // instead.</span>
<span id="L5301"><span class="lineNum">    5301</span>              : //</span>
<span id="L5302"><span class="lineNum">    5302</span>              : // WARNING: Despite the similar name, this function is unrelated to</span>
<span id="L5303"><span class="lineNum">    5303</span>              : // |X509_STORE_CTX_get0_chain|.</span>
<span id="L5304"><span class="lineNum">    5304</span>              : //</span>
<span id="L5305"><span class="lineNum">    5305</span>              : // WARNING: This function saves a pointer to |sk| without copying or</span>
<span id="L5306"><span class="lineNum">    5306</span>              : // incrementing reference counts. |sk| must outlive |ctx| and may not be mutated</span>
<span id="L5307"><span class="lineNum">    5307</span>              : // for the duration of the certificate verification.</span>
<span id="L5308"><span class="lineNum">    5308</span>              : OPENSSL_EXPORT void X509_STORE_CTX_set_chain(X509_STORE_CTX *ctx,</span>
<span id="L5309"><span class="lineNum">    5309</span>              :                                              STACK_OF(X509) *sk);</span>
<span id="L5310"><span class="lineNum">    5310</span>              : </span>
<span id="L5311"><span class="lineNum">    5311</span>              : // The following flags do nothing. The corresponding non-standard options have</span>
<span id="L5312"><span class="lineNum">    5312</span>              : // been removed.</span>
<span id="L5313"><span class="lineNum">    5313</span>              : #define X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT 0</span>
<span id="L5314"><span class="lineNum">    5314</span>              : #define X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS 0</span>
<span id="L5315"><span class="lineNum">    5315</span>              : #define X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS 0</span>
<span id="L5316"><span class="lineNum">    5316</span>              : </span>
<span id="L5317"><span class="lineNum">    5317</span>              : // X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS does nothing, but is necessary in</span>
<span id="L5318"><span class="lineNum">    5318</span>              : // OpenSSL to enable standard wildcard matching. In BoringSSL, this behavior is</span>
<span id="L5319"><span class="lineNum">    5319</span>              : // always enabled.</span>
<span id="L5320"><span class="lineNum">    5320</span>              : #define X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS 0</span>
<span id="L5321"><span class="lineNum">    5321</span>              : </span>
<span id="L5322"><span class="lineNum">    5322</span>              : // X509_STORE_get0_objects returns a non-owning pointer of |store|'s internal</span>
<span id="L5323"><span class="lineNum">    5323</span>              : // object list. Although this function is not const, callers must not modify</span>
<span id="L5324"><span class="lineNum">    5324</span>              : // the result of this function.</span>
<span id="L5325"><span class="lineNum">    5325</span>              : //</span>
<span id="L5326"><span class="lineNum">    5326</span>              : // WARNING: This function is not thread-safe. If |store| is shared across</span>
<span id="L5327"><span class="lineNum">    5327</span>              : // multiple threads, callers cannot safely inspect the result of this function,</span>
<span id="L5328"><span class="lineNum">    5328</span>              : // because another thread may have concurrently added to it. In particular,</span>
<span id="L5329"><span class="lineNum">    5329</span>              : // |X509_LOOKUP_add_dir| treats this list as a cache and may add to it in the</span>
<span id="L5330"><span class="lineNum">    5330</span>              : // course of certificate verification. This API additionally prevents fixing</span>
<span id="L5331"><span class="lineNum">    5331</span>              : // some quadratic worst-case behavior in |X509_STORE| and may be removed in the</span>
<span id="L5332"><span class="lineNum">    5332</span>              : // future. Use |X509_STORE_get1_objects| instead.</span>
<span id="L5333"><span class="lineNum">    5333</span>              : OPENSSL_EXPORT STACK_OF(X509_OBJECT) *X509_STORE_get0_objects(</span>
<span id="L5334"><span class="lineNum">    5334</span>              :     X509_STORE *store);</span>
<span id="L5335"><span class="lineNum">    5335</span>              : </span>
<span id="L5336"><span class="lineNum">    5336</span>              : // X509_PURPOSE_get_by_sname returns the |X509_PURPOSE_*| constant corresponding</span>
<span id="L5337"><span class="lineNum">    5337</span>              : // a short name |sname|, or -1 if |sname| was not recognized.</span>
<span id="L5338"><span class="lineNum">    5338</span>              : //</span>
<span id="L5339"><span class="lineNum">    5339</span>              : // Use |X509_PURPOSE_*| constants directly instead. The short names used by this</span>
<span id="L5340"><span class="lineNum">    5340</span>              : // function look like &quot;sslserver&quot; or &quot;smimeencrypt&quot;, so they do not make</span>
<span id="L5341"><span class="lineNum">    5341</span>              : // especially good APIs.</span>
<span id="L5342"><span class="lineNum">    5342</span>              : //</span>
<span id="L5343"><span class="lineNum">    5343</span>              : // This function differs from OpenSSL, which returns an &quot;index&quot; to be passed to</span>
<span id="L5344"><span class="lineNum">    5344</span>              : // |X509_PURPOSE_get0|, followed by |X509_PURPOSE_get_id|, to finally obtain an</span>
<span id="L5345"><span class="lineNum">    5345</span>              : // |X509_PURPOSE_*| value suitable for use with |X509_VERIFY_PARAM_set_purpose|.</span>
<span id="L5346"><span class="lineNum">    5346</span>              : OPENSSL_EXPORT int X509_PURPOSE_get_by_sname(const char *sname);</span>
<span id="L5347"><span class="lineNum">    5347</span>              : </span>
<span id="L5348"><span class="lineNum">    5348</span>              : // X509_PURPOSE_get0 returns the |X509_PURPOSE| object corresponding to |id|,</span>
<span id="L5349"><span class="lineNum">    5349</span>              : // which should be one of the |X509_PURPOSE_*| constants, or NULL if none</span>
<span id="L5350"><span class="lineNum">    5350</span>              : // exists.</span>
<span id="L5351"><span class="lineNum">    5351</span>              : //</span>
<span id="L5352"><span class="lineNum">    5352</span>              : // This function differs from OpenSSL, which takes an &quot;index&quot;, returned from</span>
<span id="L5353"><span class="lineNum">    5353</span>              : // |X509_PURPOSE_get_by_sname|. In BoringSSL, indices and |X509_PURPOSE_*| IDs</span>
<span id="L5354"><span class="lineNum">    5354</span>              : // are the same.</span>
<span id="L5355"><span class="lineNum">    5355</span>              : OPENSSL_EXPORT const X509_PURPOSE *X509_PURPOSE_get0(int id);</span>
<span id="L5356"><span class="lineNum">    5356</span>              : </span>
<span id="L5357"><span class="lineNum">    5357</span>              : // X509_PURPOSE_get_id returns |purpose|'s ID. This will be one of the</span>
<span id="L5358"><span class="lineNum">    5358</span>              : // |X509_PURPOSE_*| constants.</span>
<span id="L5359"><span class="lineNum">    5359</span>              : OPENSSL_EXPORT int X509_PURPOSE_get_id(const X509_PURPOSE *purpose);</span>
<span id="L5360"><span class="lineNum">    5360</span>              : </span>
<span id="L5361"><span class="lineNum">    5361</span>              : // The following constants are values for the legacy Netscape certificate type</span>
<span id="L5362"><span class="lineNum">    5362</span>              : // X.509 extension, a precursor to extended key usage. These values correspond</span>
<span id="L5363"><span class="lineNum">    5363</span>              : // to the DER encoding of the first byte of the BIT STRING. That is, 0x80 is</span>
<span id="L5364"><span class="lineNum">    5364</span>              : // bit zero and 0x01 is bit seven.</span>
<span id="L5365"><span class="lineNum">    5365</span>              : //</span>
<span id="L5366"><span class="lineNum">    5366</span>              : // TODO(davidben): These constants are only used by OpenVPN, which deprecated</span>
<span id="L5367"><span class="lineNum">    5367</span>              : // the feature in 2017. The documentation says it was removed, but they did not</span>
<span id="L5368"><span class="lineNum">    5368</span>              : // actually remove it. See if OpenVPN will accept a patch to finish this.</span>
<span id="L5369"><span class="lineNum">    5369</span>              : #define NS_SSL_CLIENT 0x80</span>
<span id="L5370"><span class="lineNum">    5370</span>              : #define NS_SSL_SERVER 0x40</span>
<span id="L5371"><span class="lineNum">    5371</span>              : #define NS_SMIME 0x20</span>
<span id="L5372"><span class="lineNum">    5372</span>              : #define NS_OBJSIGN 0x10</span>
<span id="L5373"><span class="lineNum">    5373</span>              : #define NS_SSL_CA 0x04</span>
<span id="L5374"><span class="lineNum">    5374</span>              : #define NS_SMIME_CA 0x02</span>
<span id="L5375"><span class="lineNum">    5375</span>              : #define NS_OBJSIGN_CA 0x01</span>
<span id="L5376"><span class="lineNum">    5376</span>              : #define NS_ANY_CA (NS_SSL_CA | NS_SMIME_CA | NS_OBJSIGN_CA)</span>
<span id="L5377"><span class="lineNum">    5377</span>              : </span>
<span id="L5378"><span class="lineNum">    5378</span>              : </span>
<span id="L5379"><span class="lineNum">    5379</span>              : // Private structures.</span>
<span id="L5380"><span class="lineNum">    5380</span>              : </span>
<span id="L5381"><span class="lineNum">    5381</span>              : struct X509_algor_st {</span>
<span id="L5382"><span class="lineNum">    5382</span>              :   ASN1_OBJECT *algorithm;</span>
<span id="L5383"><span class="lineNum">    5383</span>              :   ASN1_TYPE *parameter;</span>
<span id="L5384"><span class="lineNum">    5384</span>              : } /* X509_ALGOR */;</span>
<span id="L5385"><span class="lineNum">    5385</span>              : </span>
<span id="L5386"><span class="lineNum">    5386</span>              : </span>
<span id="L5387"><span class="lineNum">    5387</span>              : #if defined(__cplusplus)</span>
<span id="L5388"><span class="lineNum">    5388</span>              : }  // extern C</span>
<span id="L5389"><span class="lineNum">    5389</span>              : #endif</span>
<span id="L5390"><span class="lineNum">    5390</span>              : </span>
<span id="L5391"><span class="lineNum">    5391</span>              : #if !defined(BORINGSSL_NO_CXX)</span>
<span id="L5392"><span class="lineNum">    5392</span>              : extern &quot;C++&quot; {</span>
<span id="L5393"><span class="lineNum">    5393</span>              : </span>
<span id="L5394"><span class="lineNum">    5394</span>              : BSSL_NAMESPACE_BEGIN</span>
<span id="L5395"><span class="lineNum">    5395</span>              : </span>
<span id="L5396"><span class="lineNum">    5396</span>              : BORINGSSL_MAKE_DELETER(ACCESS_DESCRIPTION, ACCESS_DESCRIPTION_free)</span>
<span id="L5397"><span class="lineNum">    5397</span>              : BORINGSSL_MAKE_DELETER(AUTHORITY_KEYID, AUTHORITY_KEYID_free)</span>
<span id="L5398"><span class="lineNum">    5398</span>              : BORINGSSL_MAKE_DELETER(BASIC_CONSTRAINTS, BASIC_CONSTRAINTS_free)</span>
<span id="L5399"><span class="lineNum">    5399</span>              : // TODO(davidben): Move this to conf.h and rename to CONF_VALUE_free.</span>
<span id="L5400"><span class="lineNum">    5400</span>              : BORINGSSL_MAKE_DELETER(CONF_VALUE, X509V3_conf_free)</span>
<span id="L5401"><span class="lineNum">    5401</span>              : BORINGSSL_MAKE_DELETER(DIST_POINT, DIST_POINT_free)</span>
<span id="L5402"><span class="lineNum">    5402</span>              : BORINGSSL_MAKE_DELETER(GENERAL_NAME, GENERAL_NAME_free)</span>
<span id="L5403"><span class="lineNum">    5403</span>              : BORINGSSL_MAKE_DELETER(GENERAL_SUBTREE, GENERAL_SUBTREE_free)</span>
<span id="L5404"><span class="lineNum">    5404</span>              : BORINGSSL_MAKE_DELETER(NAME_CONSTRAINTS, NAME_CONSTRAINTS_free)</span>
<span id="L5405"><span class="lineNum">    5405</span>              : BORINGSSL_MAKE_DELETER(NETSCAPE_SPKI, NETSCAPE_SPKI_free)</span>
<span id="L5406"><span class="lineNum">    5406</span>              : BORINGSSL_MAKE_DELETER(POLICY_MAPPING, POLICY_MAPPING_free)</span>
<span id="L5407"><span class="lineNum">    5407</span>              : BORINGSSL_MAKE_DELETER(POLICYINFO, POLICYINFO_free)</span>
<span id="L5408"><span class="lineNum">    5408</span>              : BORINGSSL_MAKE_DELETER(RSA_PSS_PARAMS, RSA_PSS_PARAMS_free)</span>
<span id="L5409"><span class="lineNum">    5409</span> <span class="tlaGNC tlaBgGNC">           1 : BORINGSSL_MAKE_DELETER(X509, X509_free)</span></span>
<span id="L5410"><span class="lineNum">    5410</span>              : BORINGSSL_MAKE_UP_REF(X509, X509_up_ref)</span>
<span id="L5411"><span class="lineNum">    5411</span>              : BORINGSSL_MAKE_DELETER(X509_ALGOR, X509_ALGOR_free)</span>
<span id="L5412"><span class="lineNum">    5412</span>              : BORINGSSL_MAKE_DELETER(X509_ATTRIBUTE, X509_ATTRIBUTE_free)</span>
<span id="L5413"><span class="lineNum">    5413</span>              : BORINGSSL_MAKE_DELETER(X509_CRL, X509_CRL_free)</span>
<span id="L5414"><span class="lineNum">    5414</span>              : BORINGSSL_MAKE_UP_REF(X509_CRL, X509_CRL_up_ref)</span>
<span id="L5415"><span class="lineNum">    5415</span>              : BORINGSSL_MAKE_DELETER(X509_EXTENSION, X509_EXTENSION_free)</span>
<span id="L5416"><span class="lineNum">    5416</span>              : BORINGSSL_MAKE_DELETER(X509_INFO, X509_INFO_free)</span>
<span id="L5417"><span class="lineNum">    5417</span>              : BORINGSSL_MAKE_DELETER(X509_LOOKUP, X509_LOOKUP_free)</span>
<span id="L5418"><span class="lineNum">    5418</span>              : BORINGSSL_MAKE_DELETER(X509_NAME, X509_NAME_free)</span>
<span id="L5419"><span class="lineNum">    5419</span>              : BORINGSSL_MAKE_DELETER(X509_NAME_ENTRY, X509_NAME_ENTRY_free)</span>
<span id="L5420"><span class="lineNum">    5420</span>              : BORINGSSL_MAKE_DELETER(X509_OBJECT, X509_OBJECT_free)</span>
<span id="L5421"><span class="lineNum">    5421</span>              : BORINGSSL_MAKE_DELETER(X509_PUBKEY, X509_PUBKEY_free)</span>
<span id="L5422"><span class="lineNum">    5422</span>              : BORINGSSL_MAKE_DELETER(X509_REQ, X509_REQ_free)</span>
<span id="L5423"><span class="lineNum">    5423</span>              : BORINGSSL_MAKE_DELETER(X509_REVOKED, X509_REVOKED_free)</span>
<span id="L5424"><span class="lineNum">    5424</span>              : BORINGSSL_MAKE_DELETER(X509_SIG, X509_SIG_free)</span>
<span id="L5425"><span class="lineNum">    5425</span>              : BORINGSSL_MAKE_DELETER(X509_STORE, X509_STORE_free)</span>
<span id="L5426"><span class="lineNum">    5426</span>              : BORINGSSL_MAKE_UP_REF(X509_STORE, X509_STORE_up_ref)</span>
<span id="L5427"><span class="lineNum">    5427</span>              : BORINGSSL_MAKE_DELETER(X509_STORE_CTX, X509_STORE_CTX_free)</span>
<span id="L5428"><span class="lineNum">    5428</span>              : BORINGSSL_MAKE_DELETER(X509_VERIFY_PARAM, X509_VERIFY_PARAM_free)</span>
<span id="L5429"><span class="lineNum">    5429</span>              : </span>
<span id="L5430"><span class="lineNum">    5430</span>              : BSSL_NAMESPACE_END</span>
<span id="L5431"><span class="lineNum">    5431</span>              : </span>
<span id="L5432"><span class="lineNum">    5432</span>              : }  // extern C++</span>
<span id="L5433"><span class="lineNum">    5433</span>              : #endif  // !BORINGSSL_NO_CXX</span>
<span id="L5434"><span class="lineNum">    5434</span>              : </span>
<span id="L5435"><span class="lineNum">    5435</span>              : #define X509_R_AKID_MISMATCH 100</span>
<span id="L5436"><span class="lineNum">    5436</span>              : #define X509_R_BAD_PKCS7_VERSION 101</span>
<span id="L5437"><span class="lineNum">    5437</span>              : #define X509_R_BAD_X509_FILETYPE 102</span>
<span id="L5438"><span class="lineNum">    5438</span>              : #define X509_R_BASE64_DECODE_ERROR 103</span>
<span id="L5439"><span class="lineNum">    5439</span>              : #define X509_R_CANT_CHECK_DH_KEY 104</span>
<span id="L5440"><span class="lineNum">    5440</span>              : #define X509_R_CERT_ALREADY_IN_HASH_TABLE 105</span>
<span id="L5441"><span class="lineNum">    5441</span>              : #define X509_R_CRL_ALREADY_DELTA 106</span>
<span id="L5442"><span class="lineNum">    5442</span>              : #define X509_R_CRL_VERIFY_FAILURE 107</span>
<span id="L5443"><span class="lineNum">    5443</span>              : #define X509_R_IDP_MISMATCH 108</span>
<span id="L5444"><span class="lineNum">    5444</span>              : #define X509_R_INVALID_BIT_STRING_BITS_LEFT 109</span>
<span id="L5445"><span class="lineNum">    5445</span>              : #define X509_R_INVALID_DIRECTORY 110</span>
<span id="L5446"><span class="lineNum">    5446</span>              : #define X509_R_INVALID_FIELD_NAME 111</span>
<span id="L5447"><span class="lineNum">    5447</span>              : #define X509_R_INVALID_PSS_PARAMETERS 112</span>
<span id="L5448"><span class="lineNum">    5448</span>              : #define X509_R_INVALID_TRUST 113</span>
<span id="L5449"><span class="lineNum">    5449</span>              : #define X509_R_ISSUER_MISMATCH 114</span>
<span id="L5450"><span class="lineNum">    5450</span>              : #define X509_R_KEY_TYPE_MISMATCH 115</span>
<span id="L5451"><span class="lineNum">    5451</span>              : #define X509_R_KEY_VALUES_MISMATCH 116</span>
<span id="L5452"><span class="lineNum">    5452</span>              : #define X509_R_LOADING_CERT_DIR 117</span>
<span id="L5453"><span class="lineNum">    5453</span>              : #define X509_R_LOADING_DEFAULTS 118</span>
<span id="L5454"><span class="lineNum">    5454</span>              : #define X509_R_NEWER_CRL_NOT_NEWER 119</span>
<span id="L5455"><span class="lineNum">    5455</span>              : #define X509_R_NOT_PKCS7_SIGNED_DATA 120</span>
<span id="L5456"><span class="lineNum">    5456</span>              : #define X509_R_NO_CERTIFICATES_INCLUDED 121</span>
<span id="L5457"><span class="lineNum">    5457</span>              : #define X509_R_NO_CERT_SET_FOR_US_TO_VERIFY 122</span>
<span id="L5458"><span class="lineNum">    5458</span>              : #define X509_R_NO_CRLS_INCLUDED 123</span>
<span id="L5459"><span class="lineNum">    5459</span>              : #define X509_R_NO_CRL_NUMBER 124</span>
<span id="L5460"><span class="lineNum">    5460</span>              : #define X509_R_PUBLIC_KEY_DECODE_ERROR 125</span>
<span id="L5461"><span class="lineNum">    5461</span>              : #define X509_R_PUBLIC_KEY_ENCODE_ERROR 126</span>
<span id="L5462"><span class="lineNum">    5462</span>              : #define X509_R_SHOULD_RETRY 127</span>
<span id="L5463"><span class="lineNum">    5463</span>              : #define X509_R_UNKNOWN_KEY_TYPE 128</span>
<span id="L5464"><span class="lineNum">    5464</span>              : #define X509_R_UNKNOWN_NID 129</span>
<span id="L5465"><span class="lineNum">    5465</span>              : #define X509_R_UNKNOWN_PURPOSE_ID 130</span>
<span id="L5466"><span class="lineNum">    5466</span>              : #define X509_R_UNKNOWN_TRUST_ID 131</span>
<span id="L5467"><span class="lineNum">    5467</span>              : #define X509_R_UNSUPPORTED_ALGORITHM 132</span>
<span id="L5468"><span class="lineNum">    5468</span>              : #define X509_R_WRONG_LOOKUP_TYPE 133</span>
<span id="L5469"><span class="lineNum">    5469</span>              : #define X509_R_WRONG_TYPE 134</span>
<span id="L5470"><span class="lineNum">    5470</span>              : #define X509_R_NAME_TOO_LONG 135</span>
<span id="L5471"><span class="lineNum">    5471</span>              : #define X509_R_INVALID_PARAMETER 136</span>
<span id="L5472"><span class="lineNum">    5472</span>              : #define X509_R_SIGNATURE_ALGORITHM_MISMATCH 137</span>
<span id="L5473"><span class="lineNum">    5473</span>              : #define X509_R_DELTA_CRL_WITHOUT_CRL_NUMBER 138</span>
<span id="L5474"><span class="lineNum">    5474</span>              : #define X509_R_INVALID_FIELD_FOR_VERSION 139</span>
<span id="L5475"><span class="lineNum">    5475</span>              : #define X509_R_INVALID_VERSION 140</span>
<span id="L5476"><span class="lineNum">    5476</span>              : #define X509_R_NO_CERTIFICATE_FOUND 141</span>
<span id="L5477"><span class="lineNum">    5477</span>              : #define X509_R_NO_CERTIFICATE_OR_CRL_FOUND 142</span>
<span id="L5478"><span class="lineNum">    5478</span>              : #define X509_R_NO_CRL_FOUND 143</span>
<span id="L5479"><span class="lineNum">    5479</span>              : #define X509_R_INVALID_POLICY_EXTENSION 144</span>
<span id="L5480"><span class="lineNum">    5480</span>              : </span>
<span id="L5481"><span class="lineNum">    5481</span>              : #endif  // OPENSSL_HEADER_X509_H</span>
        </pre>
              </td>
            </tr>
          </table>
          <br>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="ruler"><img src="../../../../../../../../glass.png" width=3 height=3 alt=""></td></tr>
            <tr><td class="versionInfo">Generated by: <a href="https://github.com//linux-test-project/lcov" target="_parent">LCOV version 2.0-1</a></td></tr>
          </table>
          <br>

</body>
</html>
